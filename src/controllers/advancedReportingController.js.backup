const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const XLSX = require('xlsx')
const csvWriter = require('csv-writer')
const xml2js = require('xml2js')
const PDFDocument = require('pdfkit')
const puppeteer = require('puppeteer')
const handlebars = require('handlebars')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Advanced Reporting Controller Functions

// Generate comprehensive event report
const generateEventReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { eventId, format = 'pdf', includeDetails = true } = req.query

    if (!eventId) {
      return res.status(400).json({ error: 'Event ID is required' })
    }

    // Get event data with all related information
    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                contestants: {
                  include: {
                    contestant: {
                      include: {
                        user: true
                      }
                    }
                  }
                },
                assignments: {
                  include: {
                    judge: {
                      include: {
                        user: true
                      }
                    }
                  }
                },
                scores: {
                  include: {
                    judge: {
                      include: {
                        user: true
                      }
                    },
                    contestant: {
                      include: {
                        user: true
                      }
                    }
                  }
                }
              }
            }
          }
        },
        organizer: {
          include: {
            user: true
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Calculate comprehensive statistics
    const stats = {
      totalContests: event.contests.length,
      totalCategories: event.contests.reduce((sum, contest) => sum + contest.categories.length, 0),
      totalContestants: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.contestants.length, 0), 0),
      totalJudges: new Set(event.contests.flatMap(contest => 
        contest.categories.flatMap(category => 
          category.assignments.map(assignment => assignment.judgeId)
        )
      )).size,
      totalScores: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.scores.length, 0), 0),
      averageScore: 0,
      completionRate: 0
    }

    // Calculate average score and completion rate
    if (stats.totalScores > 0) {
      const totalScoreValue = event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => 
          catSum + category.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0), 0)
      stats.averageScore = totalScoreValue / stats.totalScores
    }

    const totalPossibleScores = stats.totalCategories * stats.totalJudges * stats.totalContestants
    if (totalPossibleScores > 0) {
      stats.completionRate = (stats.totalScores / totalPossibleScores) * 100
    }

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generateEventPDFReport(res, event, stats, includeDetails)
      case 'excel':
        return await generateEventExcelReport(res, event, stats, includeDetails)
      case 'csv':
        return await generateEventCSVReport(res, event, stats, includeDetails)
      case 'xml':
        return await generateXMLReport(res, event, stats, includeDetails)
      case 'json':
        return await generateJSONReport(res, event, stats, includeDetails)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, csv, xml, json' })
    }
  } catch (error) {
    log.error('Event report generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate event report' })
  }
}

// Generate PDF report using Puppeteer
const generateEventPDFReport = async (res, event, stats, includeDetails) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    // Create HTML template
    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Event Report - ${event.name}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
          .stat-card { border: 1px solid #ddd; padding: 15px; text-align: center; }
          .stat-value { font-size: 24px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; margin-top: 5px; }
          .section { margin-bottom: 30px; }
          .section h2 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 5px; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
          .footer { margin-top: 50px; text-align: center; color: #666; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>Event Report</h1>
          <h2>${event.name}</h2>
          <p>Generated on: ${new Date().toLocaleDateString()}</p>
        </div>

        <div class="stats">
          <div class="stat-card">
            <div class="stat-value">${stats.totalContests}</div>
            <div class="stat-label">Total Contests</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.totalCategories}</div>
            <div class="stat-label">Total Categories</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.totalContestants}</div>
            <div class="stat-label">Total Contestants</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.totalJudges}</div>
            <div class="stat-label">Total Judges</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.totalScores}</div>
            <div class="stat-label">Scores Submitted</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${stats.averageScore.toFixed(2)}</div>
            <div class="stat-label">Average Score</div>
          </div>
        </div>

        ${includeDetails ? `
        <div class="section">
          <h2>Event Details</h2>
          <p><strong>Description:</strong> ${event.description || 'N/A'}</p>
          <p><strong>Start Date:</strong> ${new Date(event.startDate).toLocaleDateString()}</p>
          <p><strong>End Date:</strong> ${new Date(event.endDate).toLocaleDateString()}</p>
          <p><strong>Location:</strong> ${event.location || 'N/A'}</p>
          <p><strong>Organizer:</strong> ${event.organizer?.user?.firstName || ''} ${event.organizer?.user?.lastName || ''}</p>
        </div>

        <div class="section">
          <h2>Contest Summary</h2>
          <table>
            <thead>
              <tr>
                <th>Contest Name</th>
                <th>Categories</th>
                <th>Contestants</th>
                <th>Scores</th>
              </tr>
            </thead>
            <tbody>
              ${event.contests.map(contest => `
                <tr>
                  <td>${contest.name}</td>
                  <td>${contest.categories.length}</td>
                  <td>${contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0)}</td>
                  <td>${contest.categories.reduce((sum, cat) => sum + cat.assignments.length, 0)}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
        ` : ''}

        <div class="footer">
          <p>Report generated by Event Manager System</p>
        </div>
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ 
      format: 'A4', 
      printBackground: true,
      margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' }
    })

    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.pdf"')
    res.send(pdf)
  } catch (error) {
    log.error('PDF generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate PDF report' })
  }
}

// Generate Excel report
const generateEventExcelReport = async (res, event, stats, includeDetails) => {
  try {
    const workbook = XLSX.utils.book_new()

    // Summary sheet
    const summaryData = [
      ['Event Report Summary'],
      [''],
      ['Event Name', event.name],
      ['Start Date', new Date(event.startDate).toLocaleDateString()],
      ['End Date', new Date(event.endDate).toLocaleDateString()],
      ['Location', event.location || 'N/A'],
      ['Organizer', `${event.organizer?.user?.firstName} ${event.organizer?.user?.lastName}`],
      [''],
      ['Statistics'],
      ['Total Contests', stats.totalContests],
      ['Total Categories', stats.totalCategories],
      ['Total Contestants', stats.totalContestants],
      ['Total Judges', stats.totalJudges],
      ['Scores Submitted', stats.totalScores],
      ['Average Score', stats.averageScore.toFixed(2)],
      ['Completion Rate', stats.completionRate.toFixed(1) + '%']
    ]

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

    if (includeDetails) {
      // Contests sheet
      const contestsData = [
        ['Contest Name', 'Categories', 'Contestants', 'Scores Submitted', 'Average Score']
      ]

      event.contests.forEach(contest => {
        const totalContestants = contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0)
        const totalScores = contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0)
        const avgScore = totalScores > 0 ? 
          contest.categories.reduce((sum, cat) => 
            sum + cat.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0) / totalScores : 0

        contestsData.push([
          contest.name,
          contest.categories.length,
          totalContestants,
          totalScores,
          avgScore.toFixed(2)
        ])
      })

      const contestsSheet = XLSX.utils.aoa_to_sheet(contestsData)
      XLSX.utils.book_append_sheet(workbook, contestsSheet, 'Contests')

      // Categories sheet
      const categoriesData = [
        ['Contest', 'Category', 'Contestants', 'Judges', 'Scores', 'Average Score']
      ]

      event.contests.forEach(contest => {
        contest.categories.forEach(category => {
          const avgScore = category.scores.length > 0 ? 
            category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0

          categoriesData.push([
            contest.name,
            category.name,
            category.contestants.length,
            category.assignments.length,
            category.scores.length,
            avgScore.toFixed(2)
          ])
        })
      })

      const categoriesSheet = XLSX.utils.aoa_to_sheet(categoriesData)
      XLSX.utils.book_append_sheet(workbook, categoriesSheet, 'Categories')
    }

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.xlsx"')
    res.send(buffer)
  } catch (error) {
    log.error('Excel generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate Excel report' })
  }
}

// Generate CSV report
const generateEventCSVReport = async (res, event, stats, includeDetails) => {
  try {
    const csvData = []
    
    // Header
    csvData.push(['Event Report', event.name])
    csvData.push(['Generated', new Date().toISOString()])
    csvData.push([''])
    
    // Statistics
    csvData.push(['Statistics'])
    csvData.push(['Total Contests', stats.totalContests])
    csvData.push(['Total Categories', stats.totalCategories])
    csvData.push(['Total Contestants', stats.totalContestants])
    csvData.push(['Total Judges', stats.totalJudges])
    csvData.push(['Scores Submitted', stats.totalScores])
    csvData.push(['Average Score', stats.averageScore.toFixed(2)])
    csvData.push(['Completion Rate', stats.completionRate.toFixed(1) + '%'])
    csvData.push([''])

    if (includeDetails) {
      // Contest details
      csvData.push(['Contest Details'])
      csvData.push(['Contest Name', 'Categories', 'Contestants', 'Scores', 'Average Score'])
      
      event.contests.forEach(contest => {
        const totalContestants = contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0)
        const totalScores = contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0)
        const avgScore = totalScores > 0 ? 
          contest.categories.reduce((sum, cat) => 
            sum + cat.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0) / totalScores : 0

        csvData.push([
          contest.name,
          contest.categories.length,
          totalContestants,
          totalScores,
          avgScore.toFixed(2)
        ])
      })
    }

    const csvContent = csvData.map(row => row.map(cell => '"' + cell + '"').join(',')).join('\n')
    
    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.csv"')
    res.send(csvContent)
  } catch (error) {
    log.error('CSV generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate CSV report' })
  }
}

// Generate XML report
const generateXMLReport = async (res, event, stats, includeDetails) => {
  try {
    const builder = new xml2js.Builder({
      rootName: 'EventReport',
      xmldec: { version: '1.0', encoding: 'UTF-8' }
    })

    const reportData = {
      $: {
        eventId: event.id,
        generatedAt: new Date().toISOString()
      },
      Event: {
        Name: event.name,
        Description: event.description || '',
        StartDate: event.startDate,
        EndDate: event.endDate,
        Location: event.location || '',
        Organizer: {
          FirstName: event.organizer?.user?.firstName || '',
          LastName: event.organizer?.user?.lastName || ''
        }
      },
      Statistics: {
        TotalContests: stats.totalContests,
        TotalCategories: stats.totalCategories,
        TotalContestants: stats.totalContestants,
        TotalJudges: stats.totalJudges,
        ScoresSubmitted: stats.totalScores,
        AverageScore: stats.averageScore.toFixed(2),
        CompletionRate: stats.completionRate.toFixed(1) + '%'
      }
    }

    if (includeDetails) {
      reportData.Contests = {
        Contest: event.contests.map(contest => ({
          $: { id: contest.id },
          Name: contest.name,
          Categories: contest.categories.length,
          Contestants: contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0),
          Scores: contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0),
          Category: contest.categories.map(category => ({
            $: { id: category.id },
            Name: category.name,
            Contestants: category.contestants.length,
            Judges: category.assignments.length,
            Scores: category.scores.length,
            AverageScore: category.scores.length > 0 ? 
              (category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length).toFixed(2) : '0.00'
          }))
        }))
      }
    }

    const xml = builder.buildObject(reportData)
    
    res.setHeader('Content-Type', 'application/xml')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.xml"')
    res.send(xml)
  } catch (error) {
    log.error('XML generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate XML report' })
  }
}

// Generate JSON report
const generateJSONReport = async (res, event, stats, includeDetails) => {
  try {
    const reportData = {
      eventId: event.id,
      generatedAt: new Date().toISOString(),
      event: {
        name: event.name,
        description: event.description,
        startDate: event.startDate,
        endDate: event.endDate,
        location: event.location,
        organizer: {
          firstName: event.organizer?.user?.firstName,
          lastName: event.organizer?.user?.lastName
        }
      },
      statistics: stats
    }

    if (includeDetails) {
      reportData.contests = event.contests.map(contest => ({
        id: contest.id,
        name: contest.name,
        categories: contest.categories.length,
        contestants: contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0),
        scores: contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0),
        categories: contest.categories.map(category => ({
          id: category.id,
          name: category.name,
          contestants: category.contestants.length,
          judges: category.assignments.length,
          scores: category.scores.length,
          averageScore: category.scores.length > 0 ? 
            category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0
        }))
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.json"')
    res.json(reportData)
  } catch (error) {
    log.error('JSON generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate JSON report' })
  }
}

// Generate judge performance report
const generateJudgePerformanceReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { judgeId, eventId, format = 'pdf' } = req.query

    if (!judgeId && !eventId) {
      return res.status(400).json({ error: 'Either judgeId or eventId is required' })
    }

    let whereClause = {}
    if (judgeId) whereClause.judgeId = judgeId
    if (eventId) {
      whereClause.category = {
        contest: {
          eventId: eventId
        }
      }
    }

    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        judge: {
          include: {
            user: true
          }
        },
        contestant: {
          include: {
            user: true
          }
        },
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    if (scores.length === 0) {
      return res.status(404).json({ error: 'No scores found for the specified criteria' })
    }

    // Calculate performance metrics
    const judgeStats = {}
    scores.forEach(score => {
      const judgeId = score.judgeId
      if (!judgeStats[judgeId]) {
        judgeStats[judgeId] = {
          judge: score.judge,
          totalScores: 0,
          totalScoreValue: 0,
          averageScore: 0,
          categories: new Set(),
          events: new Set(),
          scores: []
        }
      }
      
      judgeStats[judgeId].totalScores++
      judgeStats[judgeId].totalScoreValue += score.score
      judgeStats[judgeId].categories.add(score.categoryId)
      judgeStats[judgeId].events.add(score.category.contest.eventId)
      judgeStats[judgeId].scores.push(score)
    })

    // Calculate averages
    Object.values(judgeStats).forEach(stat => {
      stat.averageScore = stat.totalScoreValue / stat.totalScores
      stat.categoriesCount = stat.categories.size
      stat.eventsCount = stat.events.size
    })

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generateJudgePDFReport(res, judgeStats)
      case 'excel':
        return await generateJudgeExcelReport(res, judgeStats)
      case 'csv':
        return await generateJudgeCSVReport(res, judgeStats)
      case 'json':
        return await generateJudgeJSONReport(res, judgeStats)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, csv, json' })
    }
  } catch (error) {
    log.error('Judge performance report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate judge performance report' })
  }
}

// Generate judge PDF report
const generateJudgePDFReport = async (res, judgeStats) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Judge Performance Report</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .judge-card { border: 1px solid #ddd; margin-bottom: 20px; padding: 15px; }
          .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
          .stat-item { text-align: center; }
          .stat-value { font-size: 20px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>Judge Performance Report</h1>
          <p>Generated on: ${new Date().toLocaleDateString()}</p>
        </div>

        ${Object.values(judgeStats).map(stat => `
          <div class="judge-card">
            <h2>${stat.judge.user.firstName} ${stat.judge.user.lastName}</h2>
            <div class="stats">
              <div class="stat-item">
                <div class="stat-value">${stat.totalScores}</div>
                <div class="stat-label">Total Scores</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stat.averageScore.toFixed(2)}</div>
                <div class="stat-label">Average Score</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stat.categoriesCount}</div>
                <div class="stat-label">Categories</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${stat.eventsCount}</div>
                <div class="stat-label">Events</div>
              </div>
            </div>
          </div>
        `).join('')}
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ format: 'A4', printBackground: true })
    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.pdf"')
    res.send(pdf)
  } catch (error) {
    log.error('Judge PDF generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate judge PDF report' })
  }
}

// Generate judge Excel report
const generateJudgeExcelReport = async (res, judgeStats) => {
  try {
    const workbook = XLSX.utils.book_new()

    const judgeData = [
      ['Judge Name', 'Total Scores', 'Average Score', 'Categories', 'Events']
    ]

    Object.values(judgeStats).forEach(stat => {
      judgeData.push([
        `${stat.judge.user.firstName} ${stat.judge.user.lastName}`,
        stat.totalScores,
        stat.averageScore.toFixed(2),
        stat.categoriesCount,
        stat.eventsCount
      ])
    })

    const judgeSheet = XLSX.utils.aoa_to_sheet(judgeData)
    XLSX.utils.book_append_sheet(workbook, judgeSheet, 'Judge Performance')

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.xlsx"')
    res.send(buffer)
  } catch (error) {
    log.error('Judge Excel generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate judge Excel report' })
  }
}

// Generate judge CSV report
const generateJudgeCSVReport = async (res, judgeStats) => {
  try {
    const csvData = [
      ['Judge Performance Report'],
      ['Generated', new Date().toISOString()],
      [''],
      ['Judge Name', 'Total Scores', 'Average Score', 'Categories', 'Events']
    ]

    Object.values(judgeStats).forEach(stat => {
      csvData.push([
        `"${stat.judge.user.firstName} ${stat.judge.user.lastName}"`,
        stat.totalScores,
        stat.averageScore.toFixed(2),
        stat.categoriesCount,
        stat.eventsCount
      ])
    })

    const csvContent = csvData.map(row => row.join(',')).join('\n')
    
    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.csv"')
    res.send(csvContent)
  } catch (error) {
    log.error('Judge CSV generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate judge CSV report' })
  }
}

// Generate judge JSON report
const generateJudgeJSONReport = async (res, judgeStats) => {
  try {
    const reportData = {
      generatedAt: new Date().toISOString(),
      judges: Object.values(judgeStats).map(stat => ({
        judgeId: stat.judge.id,
        name: `${stat.judge.user.firstName} ${stat.judge.user.lastName}`,
        totalScores: stat.totalScores,
        averageScore: stat.averageScore,
        categoriesCount: stat.categoriesCount,
        eventsCount: stat.eventsCount,
        scores: stat.scores.map(score => ({
          score: score.score,
          category: score.category.name,
          contest: score.category.contest.name,
          event: score.category.contest.event.name,
          contestant: `${score.contestant.user.firstName} ${score.contestant.user.lastName}`
        }))
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.json"')
    res.json(reportData)
  } catch (error) {
    log.error('Judge JSON generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate judge JSON report' })
  }
}

// Generate system analytics report
const generateSystemAnalyticsReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { format = 'pdf', period = '30' } = req.query

    // Get system statistics
    const stats = {
      totalUsers: await prisma.user.count(),
      totalEvents: await prisma.event.count(),
      totalContests: await prisma.contest.count(),
      totalCategories: await prisma.category.count(),
      totalScores: await prisma.score.count(),
      totalAssignments: await prisma.assignment.count(),
      totalFiles: await prisma.file.count()
    }

    // Get recent activity (last 30 days by default)
    const startDate = new Date()
    startDate.setDate(startDate.getDate() - parseInt(period))

    const recentActivity = await prisma.activityLog.findMany({
      where: {
        createdAt: {
          gte: startDate
        }
      },
      include: {
        user: {
          include: {
            user: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      take: 100
    })

    // Get user role distribution
    const userRoles = await prisma.user.groupBy({
      by: ['role'],
      _count: {
        role: true
      }
    })

    // Get event status distribution
    const eventStatuses = await prisma.event.groupBy({
      by: ['status'],
      _count: {
        status: true
      }
    })

    const analyticsData = {
      stats,
      recentActivity,
      userRoles,
      eventStatuses,
      period: parseInt(period)
    }

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generateAnalyticsPDFReport(res, analyticsData)
      case 'excel':
        return await generateAnalyticsExcelReport(res, analyticsData)
      case 'json':
        return await generateAnalyticsJSONReport(res, analyticsData)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, json' })
    }
  } catch (error) {
    log.error('System analytics report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate system analytics report' })
  }
}

// Generate analytics PDF report
const generateAnalyticsPDFReport = async (res, analyticsData) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>System Analytics Report</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
          .stat-card { border: 1px solid #ddd; padding: 15px; text-align: center; }
          .stat-value { font-size: 24px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; margin-top: 5px; }
          .section { margin-bottom: 30px; }
          .section h2 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 5px; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>System Analytics Report</h1>
          <p>Period: Last ${analyticsData.period} days</p>
          <p>Generated on: ${new Date().toLocaleDateString()}</p>
        </div>

        <div class="stats">
          <div class="stat-card">
            <div class="stat-value">${analyticsData.stats.totalUsers}</div>
            <div class="stat-label">Total Users</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${analyticsData.stats.totalEvents}</div>
            <div class="stat-label">Total Events</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${analyticsData.stats.totalContests}</div>
            <div class="stat-label">Total Contests</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">${analyticsData.stats.totalScores}</div>
            <div class="stat-label">Total Scores</div>
          </div>
        </div>

        <div class="section">
          <h2>User Role Distribution</h2>
          <table>
            <thead>
              <tr>
                <th>Role</th>
                <th>Count</th>
                <th>Percentage</th>
              </tr>
            </thead>
            <tbody>
              ${analyticsData.userRoles.map(role => `
                <tr>
                  <td>${role.role}</td>
                  <td>${role._count.role}</td>
                  <td>${((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1)}%</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>

        <div class="section">
          <h2>Recent Activity (Last ${analyticsData.period} days)</h2>
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>User</th>
                <th>Action</th>
                <th>Entity</th>
              </tr>
            </thead>
            <tbody>
              ${analyticsData.recentActivity.slice(0, 20).map(activity => `
                <tr>
                  <td>${new Date(activity.createdAt).toLocaleDateString()}</td>
                  <td>${(activity.user?.user?.firstName || '')} ${(activity.user?.user?.lastName || '')}</td>
                  <td>${activity.action}</td>
                  <td>${activity.entityType}</td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ format: 'A4', printBackground: true })
    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.pdf"')
    res.send(pdf)
  } catch (error) {
    log.error('Analytics PDF generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate analytics PDF report' })
  }
}

// Generate analytics Excel report
const generateAnalyticsExcelReport = async (res, analyticsData) => {
  try {
    const workbook = XLSX.utils.book_new()

    // Summary sheet
    const summaryData = [
      ['System Analytics Report'],
      ['Generated', new Date().toISOString()],
      ['Period', `Last ${analyticsData.period} days`],
      [''],
      ['Statistics'],
      ['Total Users', analyticsData.stats.totalUsers],
      ['Total Events', analyticsData.stats.totalEvents],
      ['Total Contests', analyticsData.stats.totalContests],
      ['Total Categories', analyticsData.stats.totalCategories],
      ['Total Scores', analyticsData.stats.totalScores],
      ['Total Assignments', analyticsData.stats.totalAssignments],
      ['Total Files', analyticsData.stats.totalFiles]
    ]

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

    // User roles sheet
    const rolesData = [
      ['Role', 'Count', 'Percentage']
    ]

    analyticsData.userRoles.forEach(role => {
      rolesData.push([
        role.role,
        role._count.role,
        ((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1) + '%'
      ])
    })

    const rolesSheet = XLSX.utils.aoa_to_sheet(rolesData)
    XLSX.utils.book_append_sheet(workbook, rolesSheet, 'User Roles')

    // Recent activity sheet
    const activityData = [
      ['Date', 'User', 'Action', 'Entity Type', 'Entity ID']
    ]

    analyticsData.recentActivity.forEach(activity => {
      activityData.push([
        new Date(activity.createdAt).toLocaleDateString(),
        `${activity.user?.user?.firstName} ${activity.user?.user?.lastName}`,
        activity.action,
        activity.entityType,
        activity.entityId
      ])
    })

    const activitySheet = XLSX.utils.aoa_to_sheet(activityData)
    XLSX.utils.book_append_sheet(workbook, activitySheet, 'Recent Activity')

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.xlsx"')
    res.send(buffer)
  } catch (error) {
    log.error('Analytics Excel generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate analytics Excel report' })
  }
}

// Generate analytics JSON report
const generateAnalyticsJSONReport = async (res, analyticsData) => {
  try {
    const reportData = {
      generatedAt: new Date().toISOString(),
      period: analyticsData.period,
      statistics: analyticsData.stats,
      userRoles: analyticsData.userRoles.map(role => ({
        role: role.role,
        count: role._count.role,
        percentage: ((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1)
      })),
      eventStatuses: analyticsData.eventStatuses.map(status => ({
        status: status.status,
        count: status._count.status
      })),
      recentActivity: analyticsData.recentActivity.map(activity => ({
        date: activity.createdAt,
        user: `${activity.user?.user?.firstName} ${activity.user?.user?.lastName}`,
        action: activity.action,
        entityType: activity.entityType,
        entityId: activity.entityId
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.json"')
    res.json(reportData)
  } catch (error) {
    log.error('Analytics JSON generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate analytics JSON report' })
  }
}

// Generate contest results report with email integration
const generateContestResultsReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { contestId, format = 'pdf', emailTo = null, includeDetails = true } = req.query

    if (!contestId) {
      return res.status(400).json({ error: 'Contest ID is required' })
    }

    // Get contest data with all related information
    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            contestants: {
              include: {
                contestant: {
                  include: {
                    user: true
                  }
                }
              }
            },
            scores: {
              include: {
                judge: {
                  include: {
                    user: true
                  }
                },
                contestant: {
                  include: {
                    user: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Generate report data
    const reportData = {
      contest: {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        startDate: contest.startDate,
        endDate: contest.endDate,
        event: contest.event
      },
      categories: contest.categories.map(category => {
        const contestants = category.contestants.map(cc => {
          const scores = category.scores.filter(s => s.contestantId === cc.contestantId)
          const totalScore = scores.reduce((sum, score) => sum + score.score, 0)
          const averageScore = scores.length > 0 ? totalScore / scores.length : 0

          return {
            contestant: cc.contestant.user,
            totalScore,
            averageScore,
            scores: scores.map(s => ({
              judge: s.judge.user.name,
              score: s.score,
              comment: s.comment,
              createdAt: s.createdAt
            }))
          }
        }).sort((a, b) => b.totalScore - a.totalScore)

        return {
          id: category.id,
          name: category.name,
          description: category.description,
          maxScore: category.maxScore,
          contestants
        }
      }),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `contest-results-${contest.id}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(reportData, 'contest-results')
    } else if (format === 'excel') {
      filename = `contest-results-${contest.id}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(reportData, 'contest-results')
    } else if (format === 'csv') {
      filename = `contest-results-${contest.id}.csv`
      contentType = 'text/csv'
      fileData = await generateCSVReport(reportData, 'contest-results')
    } else {
      filename = `contest-results-${contest.id}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(reportData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: `Contest Results Report - ${contest.name}`,
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        log.error('Email sending error:', emailError, { error: error.message, stack: error.stack })
        // Continue with file download if email fails
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    log.error('Contest results report generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate contest results report' })
  }
}

// Generate audit report with email integration
const generateAuditReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { eventId, startDate, endDate, format = 'pdf', emailTo = null } = req.query

    // Get audit logs
    const whereClause = {}
    if (eventId) whereClause.eventId = eventId
    if (startDate && endDate) {
      whereClause.createdAt = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      }
    }

    const auditLogs = await prisma.activityLog.findMany({
      where: whereClause,
      include: {
        user: true
      },
      orderBy: { createdAt: 'desc' }
    })

    // Generate report data
    const reportData = {
      filters: {
        eventId,
        startDate,
        endDate
      },
      summary: {
        totalLogs: auditLogs.length,
        uniqueUsers: [...new Set(auditLogs.map(log => log.userId))].length,
        dateRange: {
          start: auditLogs.length > 0 ? auditLogs[auditLogs.length - 1].createdAt : null,
          end: auditLogs.length > 0 ? auditLogs[0].createdAt : null
        }
      },
      logs: auditLogs.map(log => ({
        id: log.id,
        action: log.action,
        resourceType: log.resourceType,
        resourceId: log.resourceId,
        userId: log.userId,
        userName: log.user.name,
        userRole: log.user.role,
        ipAddress: log.ipAddress,
        userAgent: log.userAgent,
        createdAt: log.createdAt,
        details: log.details
      })),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `audit-report-${Date.now()}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(reportData, 'audit')
    } else if (format === 'excel') {
      filename = `audit-report-${Date.now()}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(reportData, 'audit')
    } else {
      filename = `audit-report-${Date.now()}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(reportData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: 'Audit Report',
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Audit report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        log.error('Email sending error:', emailError, { error: error.message, stack: error.stack })
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    log.error('Audit report generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate audit report' })
  }
}

// Generate performance report with email integration
const generatePerformanceReport = async (req, res) => {
  const log = createRequestLogger(req, 'advancedreporting')
  try {
    const { judgeId, categoryId, format = 'pdf', emailTo = null } = req.query

    // Get performance data
    const whereClause = {}
    if (judgeId) whereClause.judgeId = judgeId
    if (categoryId) whereClause.categoryId = categoryId

    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        judge: {
          include: {
            user: true
          }
        },
        contestant: {
          include: {
            user: true
          }
        },
        category: true
      },
      orderBy: { createdAt: 'desc' }
    })

    // Calculate performance metrics
    const performanceData = {
      filters: {
        judgeId,
        categoryId
      },
      summary: {
        totalScores: scores.length,
        averageScore: scores.length > 0 ? scores.reduce((sum, s) => sum + s.score, 0) / scores.length : 0,
        uniqueContestants: [...new Set(scores.map(s => s.contestantId))].length,
        uniqueCategories: [...new Set(scores.map(s => s.categoryId))].length
      },
      scores: scores.map(score => ({
        id: score.id,
        score: score.score,
        comment: score.comment,
        judge: score.judge.user.name,
        contestant: score.contestant.user.name,
        category: score.category.name,
        createdAt: score.createdAt
      })),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `performance-report-${Date.now()}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(performanceData, 'performance')
    } else if (format === 'excel') {
      filename = `performance-report-${Date.now()}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(performanceData, 'performance')
    } else {
      filename = `performance-report-${Date.now()}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(performanceData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: 'Performance Report',
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Performance report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        log.error('Email sending error:', emailError, { error: error.message, stack: error.stack })
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    log.error('Performance report generation error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to generate performance report' })
  }
}

// Helper function to generate PDF reports
const generatePDFReport = async (data, reportType) => {
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()
  
  // Generate HTML content based on report type
  let htmlContent = ''
  
  if (reportType === 'contest-results') {
    htmlContent = generateContestResultsHTML(data)
  } else if (reportType === 'audit') {
    htmlContent = generateAuditHTML(data)
  } else if (reportType === 'performance') {
    htmlContent = generatePerformanceHTML(data)
  }
  
  await page.setContent(htmlContent)
  const pdf = await page.pdf({ format: 'A4' })
  
  await browser.close()
  return pdf
}

// Helper function to generate Excel reports
const generateExcelReport = async (data, reportType) => {
  const workbook = XLSX.utils.book_new()
  
  if (reportType === 'contest-results') {
    const worksheet = XLSX.utils.json_to_sheet(data.categories.flatMap(cat => 
      cat.contestants.map(contestant => ({
        Category: cat.name,
        Contestant: contestant.contestant.name,
        TotalScore: contestant.totalScore,
        AverageScore: contestant.averageScore
      }))
    ))
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Contest Results')
  } else if (reportType === 'audit') {
    const worksheet = XLSX.utils.json_to_sheet(data.logs)
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Audit Logs')
  } else if (reportType === 'performance') {
    const worksheet = XLSX.utils.json_to_sheet(data.scores)
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Performance Data')
  }
  
  return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
}

// Helper function to generate CSV reports
const generateCSVReport = async (data, reportType) => {
  let csvData = []
  
  if (reportType === 'contest-results') {
    csvData = data.categories.flatMap(cat => 
      cat.contestants.map(contestant => ({
        Category: cat.name,
        Contestant: contestant.contestant.name,
        TotalScore: contestant.totalScore,
        AverageScore: contestant.averageScore
      }))
    )
  } else if (reportType === 'audit') {
    csvData = data.logs
  } else if (reportType === 'performance') {
    csvData = data.scores
  }
  
  const csv = XLSX.utils.sheet_to_csv(XLSX.utils.json_to_sheet(csvData))
  return csv
}

// Helper functions to generate HTML content
const generateContestResultsHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Contest Results Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .category { margin-bottom: 30px; }
        .contestant { margin-bottom: 10px; padding: 10px; border: 1px solid #ddd; }
        .score { font-weight: bold; color: #2c5aa0; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Contest Results Report</h1>
        <h2>${data.contest.name}</h2>
        <p>Generated on: ${new Date(data.generatedAt).toLocaleDateString()}</p>
      </div>
      ${data.categories.map(cat => `
        <div class="category">
          <h3>${cat.name}</h3>
          ${cat.contestants.map(contestant => `
            <div class="contestant">
              <strong>${contestant.contestant.name}</strong>
              <span class="score">Total: ${contestant.totalScore} | Average: ${contestant.averageScore.toFixed(2)}</span>
            </div>
          `).join('')}
        </div>
      `).join('')}
    </body>
    </html>
  `
}

const generateAuditHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Audit Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Audit Report</h1>
        <p>Generated on: ${new Date(data.generatedAt).toLocaleDateString()}</p>
        <p>Total Logs: ${data.summary.totalLogs}</p>
      </div>
      <table>
        <tr>
          <th>Date</th>
          <th>User</th>
          <th>Action</th>
          <th>Resource</th>
          <th>IP Address</th>
        </tr>
        ${data.logs.map(log => `
          <tr>
            <td>${new Date(log.createdAt).toLocaleString()}</td>
            <td>${log.userName} (${log.userRole})</td>
            <td>${log.action}</td>
            <td>${log.resourceType} - ${log.resourceId}</td>
            <td>${log.ipAddress}</td>
          </tr>
        `).join('')}
      </table>
    </body>
    </html>
  `
}

const generatePerformanceHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Performance Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Performance Report</h1>
        <p>Generated on: ${new Date(data.generatedAt).toLocaleDateString()}</p>
        <p>Total Scores: ${data.summary.totalScores} | Average Score: ${data.summary.averageScore.toFixed(2)}</p>
      </div>
      <table>
        <tr>
          <th>Date</th>
          <th>Judge</th>
          <th>Contestant</th>
          <th>Category</th>
          <th>Score</th>
          <th>Comment</th>
        </tr>
        ${data.scores.map(score => `
          <tr>
            <td>${new Date(score.createdAt).toLocaleString()}</td>
            <td>${score.judge}</td>
            <td>${score.contestant}</td>
            <td>${score.category}</td>
            <td>${score.score}</td>
            <td>${score.comment || ''}</td>
          </tr>
        `).join('')}
      </table>
    </body>
    </html>
  `
}

module.exports = {
  generateEventReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  generateContestResultsReport
}
