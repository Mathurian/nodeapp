const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const getAllEvents = async (req, res) => {
  const log = createRequestLogger(req, 'events')
  try {
    log.debug('Fetching all events')
    const events = await prisma.event.findMany({
      include: {
        _count: {
          select: {
            contests: true,
            archivedEvents: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    // Compute status based on archived flag and dates
    const now = new Date()
    const eventsWithStatus = events.map(event => {
      let status = 'DRAFT'
      
      if (event.archived) {
        status = 'ARCHIVED'
      } else if (new Date(event.startDate) <= now && new Date(event.endDate) >= now) {
        status = 'ACTIVE'
      } else if (new Date(event.endDate) < now) {
        status = 'COMPLETED'
      }

      return {
        ...event,
        status
      }
    })

    log.info('Events retrieved successfully', { count: eventsWithStatus.length })
    res.json({ data: eventsWithStatus })
  } catch (error) {
    log.error('Get events error', { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEventById = async (req, res) => {
  const log = createRequestLogger(req, 'events')
  try {
    const { id } = req.params
    log.debug('Fetching event by ID', { eventId: id })

    const event = await prisma.event.findUnique({
      where: { id },
      include: {
        contests: {
          include: {
            _count: {
              select: {
                categories: true,
                contestants: true
              }
            }
          }
        },
        _count: {
          select: {
            contests: true
          }
        }
      }
    })

    if (!event) {
      log.warn('Event not found', { eventId: id })
      return res.status(404).json({ error: 'Event not found' })
    }

    // Compute status based on archived flag and dates
    const now = new Date()
    let status = 'DRAFT'
    
    if (event.archived) {
      status = 'ARCHIVED'
    } else if (new Date(event.startDate) <= now && new Date(event.endDate) >= now) {
      status = 'ACTIVE'
    } else if (new Date(event.endDate) < now) {
      status = 'COMPLETED'
    }

    log.info('Event retrieved successfully', { eventId: id, name: event.name, status })
    res.json({
      ...event,
      status
    })
  } catch (error) {
    log.error('Get event error', { error: error.message, stack: error.stack, eventId: req.params.id })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createEvent = async (req, res) => {
  const log = createRequestLogger(req, 'events')
  try {
    const { name, description, startDate, endDate, maxContestants, location } = req.body
    log.info('Event creation requested', { name, startDate, endDate, userId: req.user?.id })

    // Validate required fields
    if (!name || !startDate || !endDate) {
      log.warn('Event creation failed: missing required fields', { name, hasStartDate: !!startDate, hasEndDate: !!endDate })
      return res.status(400).json({ error: 'Name, start date, and end date are required' })
    }

    // Validate date format
    const start = new Date(startDate)
    const end = new Date(endDate)
    
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      log.warn('Event creation failed: invalid date format', { startDate, endDate })
      return res.status(400).json({ error: 'Invalid date format' })
    }

    if (start >= end) {
      log.warn('Event creation failed: end date must be after start date', { startDate, endDate })
      return res.status(400).json({ error: 'End date must be after start date' })
    }

    // Validate maxContestants if provided
    if (maxContestants !== undefined && (maxContestants < 0 || !Number.isInteger(maxContestants))) {
      log.warn('Event creation failed: invalid maxContestants', { maxContestants })
      return res.status(400).json({ error: "Max contestants must be a positive integer" })
    }

    log.debug('Creating event record', { name, startDate, endDate })
    const event = await prisma.event.create({
      data: {
        name,
        description: description || null,
        maxContestants: maxContestants || null,
        location: location || null,
        startDate: start,
        endDate: end
      }
    })

    log.info('Event created successfully', { eventId: event.id, name: event.name })
    res.status(201).json(event)
  } catch (error) {
    log.error('Create event error', { error: error.message, stack: error.stack, name: req.body.name })
    if (error.code === 'P2002') {
      res.status(400).json({ error: 'Event with this name already exists' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const updateEvent = async (req, res) => {
  const log = createRequestLogger(req, 'events')
  try {
    const { id } = req.params
    const { name, description, startDate, endDate, maxContestants, location } = req.body
    log.info('Event update requested', { eventId: id, name, userId: req.user?.id })

    // Validate required fields
    if (!name || !startDate || !endDate) {
      log.warn('Event update failed: missing required fields', { eventId: id, name, hasStartDate: !!startDate, hasEndDate: !!endDate })
      return res.status(400).json({ error: 'Name, start date, and end date are required' })
    }

    // Validate date format
    const start = new Date(startDate)
    const end = new Date(endDate)
    
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      log.warn('Event update failed: invalid date format', { eventId: id, startDate, endDate })
      return res.status(400).json({ error: 'Invalid date format' })
    }

    if (start >= end) {
      log.warn('Event update failed: end date must be after start date', { eventId: id, startDate, endDate })
      return res.status(400).json({ error: 'End date must be after start date' })
    }

    // Validate maxContestants if provided
    if (maxContestants !== undefined && (maxContestants < 0 || !Number.isInteger(maxContestants))) {
      log.warn('Event update failed: invalid maxContestants', { eventId: id, maxContestants })
      return res.status(400).json({ error: "Max contestants must be a positive integer" })
    }

    log.debug('Updating event record', { eventId: id, name })
    const event = await prisma.event.update({
      where: { id },
      data: {
        name,
        description: description || null,
        maxContestants: maxContestants || null,
        location: location || null,
        startDate: start,
        endDate: end
      }
    })

    log.info('Event updated successfully', { eventId: id, name: event.name })
    res.json(event)
  } catch (error) {
    log.error('Update event error', { error: error.message, stack: error.stack, eventId: req.params.id })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Event not found' })
    } else if (error.code === 'P2002') {
      res.status(400).json({ error: 'Event with this name already exists' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const deleteEvent = async (req, res) => {
  const log = createRequestLogger(req, 'events')
  try {
    const { id } = req.params
    log.info('Event deletion requested', { eventId: id, userId: req.user?.id })

    const eventToDelete = await prisma.event.findUnique({
      where: { id },
      select: { id: true, name: true }
    })

    if (!eventToDelete) {
      log.warn('Event deletion failed: event not found', { eventId: id })
      return res.status(404).json({ error: 'Event not found' })
    }

    log.debug('Deleting event record', { eventId: id, name: eventToDelete.name })
    await prisma.event.delete({
      where: { id }
    })

    log.info('Event deleted successfully', { eventId: id, name: eventToDelete.name })
    res.status(204).send()
  } catch (error) {
    log.error('Delete event error', { error: error.message, stack: error.stack, eventId: req.params.id })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllEvents,
  getEventById,
  createEvent,
  updateEvent,
  deleteEvent
}
