const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const getStats = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role
    
    log.debug('Fetching auditor stats', { userId, userRole })
    
    // Count categories by certification status
    const totalCategories = await prisma.category.count()
    const categoriesWithCertifications = await prisma.category.findMany({
      include: {
        categoryCertifications: true
      }
    })

    const pendingAudits = categoriesWithCertifications.filter(c => {
      const hasTally = c.categoryCertifications?.some(cert => cert.role === 'TALLY_MASTER')
      const hasAuditor = c.categoryCertifications?.some(cert => cert.role === 'AUDITOR')
      return hasTally && !hasAuditor
    }).length

    const completedAudits = categoriesWithCertifications.filter(c =>
      c.categoryCertifications?.some(cert => cert.role === 'AUDITOR')
    ).length

    const stats = {
      totalCategories,
      pendingAudits,
      completedAudits
    }

    log.info('Auditor stats fetched successfully', { stats, userId })
    res.json(stats)
  } catch (error) {
    log.error('Get auditor stats error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPendingAudits = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { page = 1, limit = 20 } = req.query
    const offset = (parseInt(page) - 1) * parseInt(limit)
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Fetching pending audits', { page, limit, userId, userRole })

    const categories = await prisma.category.findMany({
      include: {
        contest: {
          select: {
            id: true,
            eventId: true,
            name: true,
            description: true,
            createdAt: true,
            updatedAt: true,
            contestantNumberingMode: true,
            nextContestantNumber: true,
            event: true
            // Exclude archived field which doesn't exist in DB
          }
        },
        categoryCertifications: true
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: parseInt(limit)
    })

    // Filter for categories where:
    // 1. All scores have been certified by judges
    // 2. Tally Master has certified the category totals (totalsCertified = true)
    // 3. Auditor has NOT certified yet
    const pendingCategories = categories.filter(cat => {
      const hasTally = cat.categoryCertifications?.some(cert => cert.role === 'TALLY_MASTER')
      const hasAuditor = cat.categoryCertifications?.some(cert => cert.role === 'AUDITOR')
      return hasTally && !hasAuditor
    })

    // Note: Total is approximate since we filter in memory
    log.info('Pending audits fetched successfully', { count: pendingCategories.length, page, limit, userId })
    res.json({
      categories: pendingCategories,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: pendingCategories.length,
        pages: Math.ceil(pendingCategories.length / parseInt(limit))
      }
    })
  } catch (error) {
    log.error('Get pending audits error', {
      error: error.message,
      stack: error.stack,
      page: req.query?.page,
      limit: req.query?.limit
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCompletedAudits = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { page = 1, limit = 20 } = req.query
    const offset = (parseInt(page) - 1) * parseInt(limit)
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Fetching completed audits', { page, limit, userId, userRole })

    const categories = await prisma.category.findMany({
      include: {
        contest: {
          select: {
            id: true,
            eventId: true,
            name: true,
            description: true,
            createdAt: true,
            updatedAt: true,
            contestantNumberingMode: true,
            nextContestantNumber: true,
            event: true
            // Exclude archived field which doesn't exist in DB
          }
        },
        categoryCertifications: true
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: parseInt(limit)
    })

    // Filter for categories with final certification
    const completedCategories = categories.filter(cat => 
      cat.categoryCertifications?.some(cert => cert.role === 'AUDITOR')
    )

    // Note: Total is approximate since we filter in memory
    log.info('Completed audits fetched successfully', { count: completedCategories.length, page, limit, userId })
    res.json({
      categories: completedCategories,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: completedCategories.length,
        pages: Math.ceil(completedCategories.length / parseInt(limit))
      }
    })
  } catch (error) {
    log.error('Get completed audits error', {
      error: error.message,
      stack: error.stack,
      page: req.query?.page,
      limit: req.query?.limit
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const finalCertification = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role

    log.info('Final certification requested', { categoryId, userId, userRole })

    if (!categoryId) {
      log.warn('Final certification failed: categoryId missing', { userId })
      return res.status(400).json({ error: 'Category ID is required' })
    }

    // Verify category exists
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        }
      }
    })

    if (!category) {
      log.warn('Final certification failed: category not found', { categoryId, userId })
      return res.status(404).json({ error: 'Category not found' })
    }

    // Validate RoleAssignment for AUDITOR role
    const { validateCategoryAssignment } = require('../utils/roleAssignmentCheck')
    try {
      await validateCategoryAssignment(req.user.id, req.user.role, categoryId)
    } catch (assignmentError) {
      log.warn('Final certification failed: insufficient permissions', { categoryId, userId, userRole, error: assignmentError.message })
      return res.status(403).json({ error: assignmentError.message })
    }

    log.debug('Creating auditor category certification', { categoryId, userId })

    // Create an Auditor category certification record (aligned with new schema)
    const certification = await prisma.categoryCertification.create({
      data: {
        categoryId,
        userId: req.user.id,
        role: 'AUDITOR',
        comments: 'Auditor category certification (final for audit)'
      }
    })

    log.info('Final certification completed successfully', { categoryId, certificationId: certification.id, userId })
    res.json({ message: 'Final certification completed' })
  } catch (error) {
    log.error('Final certification error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectAudit = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId } = req.params
    const { reason } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    log.info('Reject audit requested', { categoryId, reason, userId, userRole })

    // Record rejection as an activity only (schema no longer has generic Certification types)
    const activityLog = await prisma.activityLog.create({
      data: {
        userId: req.user.id,
        action: 'AUDIT_REJECTED',
        resourceType: 'CATEGORY',
        resourceId: categoryId,
        details: { reason: reason || 'No reason provided' }
      }
    })

    log.info('Audit rejected successfully', { categoryId, activityLogId: activityLog.id, userId })
    res.json({ message: 'Audit rejected' })
  } catch (error) {
    log.error('Reject audit error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getScoreVerification = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId, contestantId } = req.params
    const userId = req.user.id
    const userRole = req.user.role

    log.debug('Get score verification requested', { categoryId, contestantId, userId, userRole })

    if (!categoryId) {
      log.warn('Get score verification failed: categoryId missing', { userId })
      return res.status(400).json({ error: 'Category ID is required' })
    }

    // Verify category exists
    const categoryExists = await prisma.category.findUnique({
      where: { id: categoryId }
    })

    if (!categoryExists) {
      log.warn('Get score verification failed: category not found', { categoryId, userId })
      return res.status(404).json({ error: 'Category not found' })
    }

    // Validate RoleAssignment for AUDITOR role
    const { validateCategoryAssignment } = require('../utils/roleAssignmentCheck')
    try {
      await validateCategoryAssignment(req.user.id, req.user.role, categoryId)
    } catch (assignmentError) {
      log.warn('Get score verification failed: insufficient permissions', { categoryId, userId, userRole, error: assignmentError.message })
      return res.status(403).json({ error: assignmentError.message })
    }

    log.debug('Fetching scores for verification', { categoryId, contestantId })

    const scores = await prisma.score.findMany({
      where: {
        categoryId,
        ...(contestantId && { contestantId })
      },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        },
        contestant: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            contestantNumber: true
          }
        },
        criterion: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        }
      },
      orderBy: [
        { contestant: { name: 'asc' } },
        { criterion: { order: 'asc' } }
      ]
    })

    // Group scores by contestant for easier verification
    const groupedScores = scores.reduce((acc, score) => {
      const key = score.contestantId
      if (!acc[key]) {
        acc[key] = {
          contestant: score.contestant,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      return acc
    }, {})

    // Calculate averages
    Object.values(groupedScores).forEach(group => {
      group.averageScore = group.scores.length > 0 ? group.totalScore / group.scores.length : 0
    })

    log.info('Score verification data fetched successfully', { categoryId, contestantId, scoreCount: scores.length, contestantCount: Object.keys(groupedScores).length, userId })
    res.json({
      categoryId,
      scores: Object.values(groupedScores),
      totalScores: scores.length,
      uniqueContestants: Object.keys(groupedScores).length
    })
  } catch (error) {
    log.error('Get score verification error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId,
      contestantId: req.params.contestantId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const verifyScore = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { scoreId } = req.params
    const { verified, comments, issues } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    log.info('Verify score requested', { scoreId, verified, userId, userRole })

    const score = await prisma.score.findUnique({
      where: { id: scoreId },
      include: {
        judge: true,
        contestant: true,
        criterion: true,
        category: true
      }
    })

    if (!score) {
      log.warn('Verify score failed: score not found', { scoreId, userId })
      return res.status(404).json({ error: 'Score not found' })
    }

    log.debug('Updating score verification', { scoreId, verified })

    // Update score with verification data
    const updatedScore = await prisma.score.update({
      where: { id: scoreId },
      data: {
        verified,
        verificationComments: comments,
        verificationIssues: issues,
        verifiedBy: req.user.id,
        verifiedAt: new Date()
      }
    })

    log.info('Score verified successfully', { scoreId, verified, userId })
    res.json(updatedScore)
  } catch (error) {
    log.error('Verify score error', {
      error: error.message,
      stack: error.stack,
      scoreId: req.params.scoreId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTallyMasterStatus = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role

    log.debug('Get tally master status requested', { categoryId, userId, userRole })

    // Validate RoleAssignment for AUDITOR role
    const { validateCategoryAssignment } = require('../utils/roleAssignmentCheck')
    try {
      await validateCategoryAssignment(req.user.id, req.user.role, categoryId)
    } catch (assignmentError) {
      log.warn('Get tally master status failed: insufficient permissions', { categoryId, userId, userRole, error: assignmentError.message })
      return res.status(403).json({ error: assignmentError.message })
    }

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true,
            criterion: true
          }
        },
        certifications: true
      }
    })

    if (!category) {
      log.warn('Get tally master status failed: category not found', { categoryId, userId })
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate tally master status
    const totalScores = category.scores.length
    const verifiedScores = category.scores.filter(s => s.verified).length
    const pendingVerification = totalScores - verifiedScores

    // Check certification status from Certification records
    const tallyMasterCert = category.certifications?.some(c => c.type === 'TALLY_MASTER')
    const auditorCert = category.certifications?.some(c => c.type === 'AUDITOR')
    const finalCert = category.certifications?.some(c => c.type === 'FINAL')

    const tallyStatus = {
      categoryId: category.id,
      categoryName: category.name,
      totalScores,
      verifiedScores,
      pendingVerification,
      verificationProgress: totalScores > 0 ? (verifiedScores / totalScores * 100).toFixed(2) : 0,
      tallyMasterCertified: tallyMasterCert || false,
      auditorCertified: auditorCert || false,
      finalCertified: finalCert || false
    }

    log.info('Tally master status fetched successfully', { categoryId, totalScores, verifiedScores, userId })
    res.json(tallyStatus)
  } catch (error) {
    log.error('Get tally master status error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationWorkflow = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role

    log.debug('Get certification workflow requested', { categoryId, userId, userRole })

    // Validate RoleAssignment for AUDITOR role
    const { validateCategoryAssignment } = require('../utils/roleAssignmentCheck')
    try {
      await validateCategoryAssignment(req.user.id, req.user.role, categoryId)
    } catch (assignmentError) {
      log.warn('Get certification workflow failed: insufficient permissions', { categoryId, userId, userRole, error: assignmentError.message })
      return res.status(403).json({ error: assignmentError.message })
    }

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true,
            criterion: true
          }
        },
        certifications: true
      }
    })

    if (!category) {
      log.warn('Get certification workflow failed: category not found', { categoryId, userId })
      return res.status(404).json({ error: 'Category not found' })
    }

    // Check certification status from Certification records
    const tallyMasterCert = category.certifications?.find(c => c.type === 'TALLY_MASTER')
    const auditorCert = category.certifications?.find(c => c.type === 'AUDITOR')
    const finalCert = category.certifications?.find(c => c.type === 'FINAL')

    const workflow = {
      categoryId: category.id,
      categoryName: category.name,
      contestName: category.contest.name,
      eventName: category.contest.event.name,
      steps: [
        {
          name: 'Judge Scoring',
          status: category.scores.length > 0 ? 'COMPLETED' : 'PENDING',
          completedAt: category.scores.length > 0 ? category.scores[0].createdAt : null,
          details: `${category.scores.length} scores submitted`
        },
        {
          name: 'Tally Master Review',
          status: tallyMasterCert ? 'COMPLETED' : 'PENDING',
          completedAt: tallyMasterCert?.createdAt || null,
          details: tallyMasterCert ? 'Totals certified' : 'Pending tally review'
        },
        {
          name: 'Auditor Verification',
          status: auditorCert ? 'COMPLETED' : 'PENDING',
          completedAt: auditorCert?.createdAt || null,
          details: auditorCert ? 'Final certification completed' : 'Pending auditor review'
        },
        {
          name: 'Board Approval',
          status: finalCert ? 'COMPLETED' : 'PENDING',
          completedAt: finalCert?.createdAt || null,
          details: finalCert ? 'Board approved' : 'Pending board approval'
        }
      ],
      currentStep: finalCert ? 4 : auditorCert ? 3 : tallyMasterCert ? 2 : 1,
      overallStatus: finalCert ? 'APPROVED' : auditorCert ? 'AUDITOR_CERTIFIED' : tallyMasterCert ? 'TALLY_CERTIFIED' : 'PENDING'
    }

    log.info('Certification workflow fetched successfully', { categoryId, currentStep: workflow.currentStep, overallStatus: workflow.overallStatus, userId })
    res.json(workflow)
  } catch (error) {
    log.error('Get certification workflow error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateSummaryReport = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId, includeDetails = false } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    log.info('Generate summary report requested', { categoryId, includeDetails, userId, userRole })

    if (!categoryId) {
      log.warn('Generate summary report failed: categoryId missing', { userId })
      return res.status(400).json({ error: 'Category ID is required' })
    }

    // Validate RoleAssignment for AUDITOR role
    const { validateCategoryAssignment } = require('../utils/roleAssignmentCheck')
    try {
      await validateCategoryAssignment(req.user.id, req.user.role, categoryId)
    } catch (assignmentError) {
      log.warn('Generate summary report failed: insufficient permissions', { categoryId, userId, userRole, error: assignmentError.message })
      return res.status(403).json({ error: assignmentError.message })
    }

    log.debug('Fetching category data for summary report', { categoryId })

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        },
        certifications: true
      }
    })

    if (!category) {
      log.warn('Generate summary report failed: category not found', { categoryId, userId })
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate summary statistics
    const totalScores = category.scores.length
    const uniqueContestants = new Set(category.scores.map(s => s.contestantId)).size
    const uniqueJudges = new Set(category.scores.map(s => s.judgeId)).size
    const averageScore = totalScores > 0 ? category.scores.reduce((sum, s) => sum + s.score, 0) / totalScores : 0
    const maxScore = Math.max(...category.scores.map(s => s.score), 0)
    const minScore = Math.min(...category.scores.map(s => s.score), 0)

    // Group by contestant for rankings
    const contestantScores = category.scores.reduce((acc, score) => {
      const key = score.contestantId
      if (!acc[key]) {
        acc[key] = {
          contestant: score.contestant,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      return acc
    }, {})

    // Calculate averages and rankings
    const rankings = Object.values(contestantScores).map(group => {
      group.averageScore = group.scores.length > 0 ? group.totalScore / group.scores.length : 0
      return group
    }).sort((a, b) => b.averageScore - a.averageScore)

    // Add rank to each contestant
    rankings.forEach((contestant, index) => {
      contestant.rank = index + 1
    })

    const summaryReport = {
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        scoreCap: category.scoreCap
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      statistics: {
        totalScores,
        uniqueContestants,
        uniqueJudges,
        averageScore: parseFloat(averageScore.toFixed(2)),
        maxScore,
        minScore,
        scoreRange: maxScore - minScore
      },
      rankings: includeDetails ? rankings : rankings.map(r => ({
        rank: r.rank,
        contestant: r.contestant,
        totalScore: r.totalScore,
        averageScore: parseFloat(r.averageScore.toFixed(2)),
        scoreCount: r.scores.length
      })),
      certification: {
        tallyMasterCertified: category.certifications?.some(c => c.type === 'TALLY_MASTER') || false,
        auditorCertified: category.certifications?.some(c => c.type === 'AUDITOR') || false,
        finalCertified: category.certifications?.some(c => c.type === 'FINAL') || false,
        certifications: category.certifications || []
      },
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id
    }

    log.info('Summary report generated successfully', { categoryId, totalScores, uniqueContestants, uniqueJudges, userId })
    res.json(summaryReport)
  } catch (error) {
    log.error('Generate summary report error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.body?.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAuditHistory = async (req, res) => {
  const log = createRequestLogger(req, 'auditor')
  try {
    const { categoryId, page = 1, limit = 20 } = req.query
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get audit history requested', { categoryId, page, limit, userId, userRole })

    const whereClause = {
      ...(categoryId && { categoryId }),
      resourceType: 'CATEGORY'
    }

    const auditLogs = await prisma.activityLog.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    })

    const total = await prisma.activityLog.count({
      where: whereClause
    })

    log.info('Audit history fetched successfully', { categoryId, count: auditLogs.length, total, page, limit, userId })
    res.json({
      auditLogs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    })
  } catch (error) {
    log.error('Get audit history error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.query?.categoryId,
      page: req.query?.page,
      limit: req.query?.limit
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getPendingAudits,
  getCompletedAudits,
  finalCertification,
  rejectAudit,
  getScoreVerification,
  verifyScore,
  getTallyMasterStatus,
  getCertificationWorkflow,
  generateSummaryReport,
  getAuditHistory
}
