const { PrismaClient } = require('@prisma/client')
const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

/**
 * Create a new score removal request
 */
const createScoreRemovalRequest = async (req, res) => {
  const log = createRequestLogger(req, 'scoreRemoval')
  try {
    const { judgeId, categoryId, reason } = req.body

    if (!judgeId || !categoryId || !reason) {
      return res.status(400).json({ error: 'Judge ID, category ID, and reason are required' })
    }

    // Verify category exists
    const category = await prisma.category.findUnique({
      where: { id: categoryId }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Verify judge exists (judgeId now directly references Judge.id)
    const judge = await prisma.judge.findUnique({
      where: { id: judgeId }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    // Check if user is authorized (Board or Admin)
    const user = req.user
    if (user.role !== 'BOARD' && user.role !== 'ADMIN') {
      return res.status(403).json({ error: 'Only Board and Admin can initiate score removal requests' })
    }

    // Create the request
    const request = await prisma.scoreRemovalRequest.create({
      data: {
        judgeId,
        categoryId,
        reason: reason.trim(),
        requestedBy: user.id,
        status: 'PENDING'
      },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        category: {
          select: {
            id: true,
            name: true
          }
        }
      }
    })

    res.json({
      success: true,
      message: 'Score removal request created. Awaiting co-signatures.',
      request
    })
  } catch (error) {
    log.error('Create score removal request error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to create score removal request', message: error.message })
  }
}

/**
 * Get all score removal requests
 */
const getScoreRemovalRequests = async (req, res) => {
  const log = createRequestLogger(req, 'scoreRemoval')
  try {
    const { status } = req.query

    const where = {}
    if (status) {
      where.status = status
    }

    const requests = await prisma.scoreRemovalRequest.findMany({
      where,
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        category: {
          include: {
            contest: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        requestedByUser: {
          select: {
            id: true,
            name: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json({
      success: true,
      requests
    })
  } catch (error) {
    log.error('Get score removal requests error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to retrieve score removal requests' })
  }
}

/**
 * Get a specific score removal request
 */
const getScoreRemovalRequest = async (req, res) => {
  const log = createRequestLogger(req, 'scoreRemoval')
  try {
    const { id } = req.params

    const request = await prisma.scoreRemovalRequest.findUnique({
      where: { id },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        category: {
          include: {
            contest: {
              select: {
                id: true,
                name: true
              }
            }
          }
        },
        requestedByUser: {
          select: {
            id: true,
            name: true
          }
        }
      }
    })

    if (!request) {
      return res.status(404).json({ error: 'Score removal request not found' })
    }

    res.json({
      success: true,
      request
    })
  } catch (error) {
    log.error('Get score removal request error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to retrieve score removal request' })
  }
}

/**
 * Sign a score removal request
 */
const signScoreRemovalRequest = async (req, res) => {
  const log = createRequestLogger(req, 'scoreRemoval')
  try {
    const { id } = req.params
    const { signatureName } = req.body

    if (!signatureName) {
      return res.status(400).json({ error: 'Signature name is required' })
    }

    const request = await prisma.scoreRemovalRequest.findUnique({
      where: { id }
    })

    if (!request) {
      return res.status(404).json({ error: 'Score removal request not found' })
    }

    if (request.status === 'APPROVED') {
      return res.status(400).json({ error: 'Request has already been approved' })
    }

    const user = req.user
    const signedAt = new Date()

    // Determine which signature field to update based on user role
    const updateData = {}

    if (user.role === 'AUDITOR' && !request.auditorSignature) {
      updateData.auditorSignature = signatureName
      updateData.auditorSignedAt = signedAt
      updateData.auditorSignedBy = user.id
    } else if (user.role === 'TALLY_MASTER' && !request.tallySignature) {
      updateData.tallySignature = signatureName
      updateData.tallySignedAt = signedAt
      updateData.tallySignedBy = user.id
    } else if (user.role === 'BOARD' && !request.boardSignature) {
      updateData.boardSignature = signatureName
      updateData.boardSignedAt = signedAt
      updateData.boardSignedBy = user.id
    } else {
      return res.status(400).json({ error: 'You have already signed this request or your signature is not required' })
    }

    // Check if all required signatures are present
    const hasAuditorSignature = request.auditorSignature || updateData.auditorSignature
    const hasTallySignature = request.tallySignature || updateData.tallySignature
    const hasBoardSignature = request.boardSignature || updateData.boardSignature

    if (hasAuditorSignature && hasTallySignature && hasBoardSignature) {
      updateData.status = 'APPROVED'
      updateData.updatedAt = signedAt
    }

    const updatedRequest = await prisma.scoreRemovalRequest.update({
      where: { id },
      data: updateData,
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        category: {
          include: {
            contest: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    })

    res.json({
      success: true,
      message: 'Request signed successfully',
      request: updatedRequest,
      allSigned: updateData.status === 'APPROVED'
    })
  } catch (error) {
    log.error('Sign score removal request error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to sign score removal request', message: error.message })
  }
}

/**
 * Execute approved score removal request (remove all scores for the judge in the category)
 */
const executeScoreRemoval = async (req, res) => {
  const log = createRequestLogger(req, 'scoreRemoval')
  try {
    const { id } = req.params

    const request = await prisma.scoreRemovalRequest.findUnique({
      where: { id },
      include: {
        judge: {
          select: {
            id: true
          }
        },
        category: {
          select: {
            id: true
          }
        }
      }
    })

    if (!request) {
      return res.status(404).json({ error: 'Score removal request not found' })
    }

    if (request.status !== 'APPROVED') {
      return res.status(400).json({ error: 'Request must be approved before execution' })
    }

    // Delete all scores from this judge in this category
    const deletedScores = await prisma.score.deleteMany({
      where: {
        categoryId: request.categoryId,
        judgeId: request.judgeId
      }
    })

    // Update request status to COMPLETED
    await prisma.scoreRemovalRequest.update({
      where: { id },
      data: {
        status: 'COMPLETED'
      }
    })

    res.json({
      success: true,
      message: 'Score removal executed successfully',
      deletedCount: deletedScores.count
    })
  } catch (error) {
    log.error('Execute score removal error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to execute score removal', message: error.message })
  }
}

module.exports = {
  createScoreRemovalRequest,
  getScoreRemovalRequests,
  getScoreRemovalRequest,
  signScoreRemovalRequest,
  executeScoreRemoval
}

