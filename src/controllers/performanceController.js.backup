const os = require('os')
const fs = require('fs').promises
const path = require('path')
const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Log performance metrics with sampling and PII removal
const logPerformance = async (req, res, next) => {
  const startTime = Date.now()
  
  res.on('finish', async () => {
    try {
      // Sample rate: only log a percentage of requests (default 20%)
      const sampleRate = parseFloat(process.env.PERF_SAMPLE_RATE || '0.2')
      if (Math.random() > sampleRate) {
        return // Skip logging this request
      }
      
      const responseTime = Date.now() - startTime
      
      await prisma.performanceLog.create({
        data: {
          endpoint: req.route?.path || req.path.split('?')[0], // Use route path if available, otherwise clean path
          method: req.method,
          responseTime,
          statusCode: res.statusCode,
          userId: req.user?.id || null,
          ipAddress: null, // PII removed
          userAgent: null, // PII removed
          eventId: req.query?.eventId || null,
          contestId: req.query?.contestId || null,
          categoryId: req.query?.categoryId || null
        }
      })
    } catch (error) {
      // Silently fail performance logging to avoid impacting request handling
      // Only log errors in development
      if (process.env.NODE_ENV === 'development') {
        log.error('Performance logging error:', error, { error: error.message, stack: error.stack })
      }
    }
  })
  
  next()
}

const getPerformanceStats = async (req, res) => {
  const log = createRequestLogger(req, 'performance')
  try {
    const { timeRange = '24h', endpoint, method } = req.query
    
    // Calculate time range
    const now = new Date()
    let startTime
    switch (timeRange) {
      case '1h':
        startTime = new Date(now.getTime() - 60 * 60 * 1000)
        break
      case '24h':
        startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000)
        break
      case '7d':
        startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        break
      case '30d':
        startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
        break
      default:
        startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000)
    }
    
    const whereClause = {
      createdAt: {
        gte: startTime
      },
      ...(endpoint && { endpoint }),
      ...(method && { method })
    }
    
    // Get performance statistics
    const stats = await prisma.performanceLog.aggregate({
      where: whereClause,
      _avg: {
        responseTime: true
      },
      _min: {
        responseTime: true
      },
      _max: {
        responseTime: true
      },
      _count: {
        id: true
      }
    })
    
    // Get response time distribution
    const responseTimeDistribution = await prisma.performanceLog.groupBy({
      by: ['statusCode'],
      where: whereClause,
      _count: {
        id: true
      },
      _avg: {
        responseTime: true
      }
    })
    
    // Get top slow endpoints
    const slowEndpoints = await prisma.performanceLog.groupBy({
      by: ['endpoint'],
      where: whereClause,
      _avg: {
        responseTime: true
      },
      _count: {
        id: true
      },
      orderBy: {
        _avg: {
          responseTime: 'desc'
        }
      },
      take: 10
    })
    
    // Get error rates
    const errorStats = await prisma.performanceLog.groupBy({
      by: ['statusCode'],
      where: {
        ...whereClause,
        statusCode: {
          gte: 400
        }
      },
      _count: {
        id: true
      }
    })
    
    res.json({
      timeRange,
      totalRequests: stats._count.id,
      averageResponseTime: Math.round(stats._avg.responseTime || 0),
      minResponseTime: stats._min.responseTime || 0,
      maxResponseTime: stats._max.responseTime || 0,
      responseTimeDistribution,
      slowEndpoints,
      errorStats,
      errorRate: stats._count.id > 0 ? 
        (errorStats.reduce((sum, stat) => sum + stat._count.id, 0) / stats._count.id * 100).toFixed(2) : 0
    })
  } catch (error) {
    log.error('Get performance stats error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getSystemMetrics = async (req, res) => {
  const log = createRequestLogger(req, 'performance')
  try {
    // CPU and Memory usage
    const cpuUsage = process.cpuUsage()
    const memoryUsage = process.memoryUsage()
    
    // System information
    const systemInfo = {
      platform: os.platform(),
      arch: os.arch(),
      hostname: os.hostname(),
      uptime: os.uptime(),
      loadAverage: os.loadavg(),
      totalMemory: os.totalmem(),
      freeMemory: os.freemem(),
      cpuCount: os.cpus().length
    }
    
    // Database connection status
    const dbStatus = await prisma.$queryRaw`SELECT 1 as status`
    
    // Disk usage (if possible)
    let diskUsage = null
    try {
      const stats = await fs.stat(path.join(__dirname, '../../'))
      diskUsage = {
        available: true,
        path: path.join(__dirname, '../../')
      }
    } catch (error) {
      diskUsage = { available: false, error: error.message }
    }
    
    res.json({
      timestamp: new Date().toISOString(),
      process: {
        pid: process.pid,
        uptime: process.uptime(),
        cpuUsage: {
          user: cpuUsage.user,
          system: cpuUsage.system
        },
        memoryUsage: {
          rss: memoryUsage.rss,
          heapTotal: memoryUsage.heapTotal,
          heapUsed: memoryUsage.heapUsed,
          external: memoryUsage.external
        }
      },
      system: systemInfo,
      database: {
        status: dbStatus ? 'connected' : 'disconnected',
        connectionCount: await prisma.$queryRaw`SELECT count(*) as count FROM pg_stat_activity WHERE state = 'active'`
      },
      disk: diskUsage
    })
  } catch (error) {
    log.error('Get system metrics error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPerformanceLogs = async (req, res) => {
  const log = createRequestLogger(req, 'performance')
  try {
    const { 
      page = 1, 
      limit = 50, 
      endpoint, 
      method, 
      statusCode, 
      userId,
      minResponseTime,
      maxResponseTime,
      startDate,
      endDate
    } = req.query
    
    const whereClause = {
      ...(endpoint && { endpoint: { contains: endpoint } }),
      ...(method && { method }),
      ...(statusCode && { statusCode: parseInt(statusCode) }),
      ...(userId && { userId }),
      ...(minResponseTime && { responseTime: { gte: parseInt(minResponseTime) } }),
      ...(maxResponseTime && { responseTime: { lte: parseInt(maxResponseTime) } }),
      ...(startDate && endDate && {
        createdAt: {
          gte: new Date(startDate),
          lte: new Date(endDate)
        }
      })
    }
    
    const logs = await prisma.performanceLog.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    })
    
    const total = await prisma.performanceLog.count({
      where: whereClause
    })
    
    res.json({
      logs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    })
  } catch (error) {
    log.error('Get performance logs error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const clearPerformanceLogs = async (req, res) => {
  const log = createRequestLogger(req, 'performance')
  try {
    const { olderThan } = req.body
    
    let whereClause = {}
    if (olderThan) {
      whereClause = {
        createdAt: {
          lt: new Date(olderThan)
        }
      }
    }
    
    const result = await prisma.performanceLog.deleteMany({
      where: whereClause
    })
    
    res.json({ 
      message: `Cleared ${result.count} performance log entries`,
      count: result.count
    })
  } catch (error) {
    log.error('Clear performance logs error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getHealthCheck = async (req, res) => {
  const log = createRequestLogger(req, 'performance')
  try {
    const checks = {
      database: false,
      memory: false,
      disk: false,
      uptime: false
    }
    
    // Database check
    try {
      await prisma.$queryRaw`SELECT 1`
      checks.database = true
    } catch (error) {
      log.error('Database health check failed:', error, { error: error.message, stack: error.stack })
    }
    
    // Memory check
    const memoryUsage = process.memoryUsage()
    const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100
    checks.memory = memoryUsagePercent < 90 // Less than 90% memory usage
    
    // Disk check (basic)
    try {
      await fs.access(path.join(__dirname, '../../'))
      checks.disk = true
    } catch (error) {
      log.error('Disk health check failed:', error, { error: error.message, stack: error.stack })
    }
    
    // Uptime check
    checks.uptime = process.uptime() > 0
    
    const allHealthy = Object.values(checks).every(check => check === true)
    
    res.status(allHealthy ? 200 : 503).json({
      status: allHealthy ? 'healthy' : 'unhealthy',
      timestamp: new Date().toISOString(),
      checks,
      uptime: process.uptime(),
      memory: {
        used: memoryUsage.heapUsed,
        total: memoryUsage.heapTotal,
        percent: memoryUsagePercent.toFixed(2)
      }
    })
  } catch (error) {
    log.error('Health check error:', error, { error: error.message, stack: error.stack })
    res.status(503).json({ 
      status: 'unhealthy',
      error: 'Health check failed',
      timestamp: new Date().toISOString()
    })
  }
}

module.exports = {
  logPerformance,
  getPerformanceStats,
  getSystemMetrics,
  getPerformanceLogs,
  clearPerformanceLogs,
  getHealthCheck
}
