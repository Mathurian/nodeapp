const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const getAllResults = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const userRole = req.user.role
    const userId = req.user.id

    let whereClause = {}
    let selectClause = {
      id: true,
      score: true,
      comment: true,
      createdAt: true,
      updatedAt: true,
      categoryId: true,
      contestantId: true,
      judgeId: true,
      criterionId: true,
      isCertified: true,
      certifiedBy: true,
      certifiedAt: true,
      category: {
        select: {
          id: true,
          name: true,
          description: true,
          scoreCap: true,
          totalsCertified: true,
          contestId: true,
          contest: {
            select: {
              id: true,
              name: true,
              description: true,
              eventId: true,
              createdAt: true,
              updatedAt: true,
              event: {
                select: {
                  id: true,
                  name: true,
                  startDate: true,
                  endDate: true,
                  createdAt: true,
                  updatedAt: true
                }
              }
            }
          }
        }
      },
      contestant: {
        select: {
          id: true,
          name: true,
          email: true,
          contestantNumber: true
        }
      },
      judge: {
        select: {
          id: true,
          name: true,
          email: true
        }
      },
      criterion: {
        select: {
          id: true,
          name: true,
          maxScore: true,
          categoryId: true,
          createdAt: true,
          updatedAt: true
        }
      }
    }

    // Role-based filtering
    switch (userRole) {
      case 'ADMIN':
      case 'ORGANIZER':
        // Full access to all results
        break
      
      case 'BOARD':
        // All results
        break
      
      case 'JUDGE':
        // Get the Judge record linked to this User
        const judgeUser = await prisma.user.findUnique({
          where: { id: userId },
          include: { judge: true }
        })
        
        if (!judgeUser || !judgeUser.judge) {
          return res.json([]) // No judge record linked
        }
        
        // Results for assigned categories/contests
        whereClause = {
          OR: [
            { judgeId: judgeUser.judge.id },
            { category: { judges: { some: { judgeId: judgeUser.judge.id } } } }
          ]
        }
        break
      
      case 'TALLY_MASTER':
        // All results
        break
      
      case 'AUDITOR':
        // All results
        break
      
      case 'CONTESTANT':
        // Find the Contestant record linked to this User
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { contestantId: true }
        })
        
        if (!user || !user.contestantId) {
          // If no contestant record linked to user, return empty results
          return res.json([])
        }
        
        // Get visibility settings
        const canViewOverallResults = await prisma.systemSetting.findUnique({
          where: { key: 'contestant_can_view_overall_results' }
        })
        const canViewOverall = (canViewOverallResults?.value || 'true') === 'true'
        
        // First, get certified category IDs (can't filter on nested relations with select)
        const certifiedCategories = await prisma.category.findMany({
          where: { totalsCertified: true },
          select: { id: true }
        })
        const certifiedCategoryIds = certifiedCategories.map(c => c.id)
        
        if (certifiedCategoryIds.length === 0) {
          // No certified categories yet
          return res.json({ results: [], pagination: { page: 1, limit: 50, total: 0, pages: 0 } })
        }
        
        // Own results only - filter to only certified categories
        if (canViewOverall) {
          // Can view overall results - show all results for certified categories
          whereClause = {
            categoryId: { in: certifiedCategoryIds }
          }
        } else {
          // Only own results from certified categories
          whereClause = {
            contestantId: user.contestantId,
            categoryId: { in: certifiedCategoryIds }
          }
        }
        break
      
      default:
        return res.status(403).json({ error: 'Insufficient permissions' })
    }

    // When using select, orderBy cannot use nested relations
    // Prisma limitation: can only order by direct fields or scalar fields of the model
    // Use createdAt for ordering, then sort client-side if needed
    let results
    try {
      results = await prisma.score.findMany({
        where: whereClause,
        select: selectClause,
        orderBy: { createdAt: 'desc' },
        skip: parseInt(req.query.offset || 0),
        take: parseInt(req.query.limit || 50)
      })
    } catch (prismaError) {
      // Log the full error details
      log.error('Prisma query error details:', {
        code: prismaError.code,
        meta: prismaError.meta,
        message: prismaError.message,
        where: whereClause,
        selectKeys: Object.keys(selectClause, { error: error.message, stack: error.stack })
      })
      throw prismaError
    }

    const total = await prisma.score.count({
      where: whereClause
    })

    // Calculate totals for each result
    const resultsWithTotals = await Promise.all(results.map(async (result) => {
      // Get all scores for this contestant in this category
      const categoryScores = await prisma.score.findMany({
        where: {
          categoryId: result.categoryId,
          contestantId: result.contestantId
        },
        select: {
          id: true,
          score: true,
          categoryId: true,
          contestantId: true,
          criterionId: true,
          category: {
            select: {
              id: true,
              name: true,
              scoreCap: true,
              totalsCertified: true
            }
          },
          criterion: {
            select: {
              id: true,
              name: true,
              maxScore: true,
              categoryId: true,
              createdAt: true,
              updatedAt: true
            }
          }
        }
      })
      
      // Calculate totals
      const earned = categoryScores.reduce((sum, s) => sum + (s.score || 0), 0)
      const categoryMax = result.category?.scoreCap || 0
      const possible = categoryMax || result.category?.scoreCap || 0
      
      return {
        ...result,
        certificationStatus: result.isCertified ? 'CERTIFIED' : 'PENDING',
        certifiedBy: result.certifiedBy,
        certifiedAt: result.certifiedAt,
        totalEarned: earned,
        totalPossible: possible
      }
    }))

    const page = parseInt(req.query.page || 1)
    const limit = parseInt(req.query.limit || 50)
    
    res.json({
      results: resultsWithTotals,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    log.error('Get results error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          }
        }
      }
    })

    res.json(categories)
  } catch (error) {
    log.error('Get categories error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestantResults = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const { contestantId } = req.params
    const userRole = req.user.role
    const userId = req.user.id

    // Role-based access control
    let whereClause = { contestantId }

    // CONTESTANT can only see their own results
    if (userRole === 'CONTESTANT') {
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { contestantId: true }
      })
      
      if (!user || !user.contestantId || user.contestantId !== contestantId) {
        return res.status(403).json({ error: 'Access denied. You can only view your own results.' })
      }
    } else if (userRole === 'JUDGE') {
      // Judge can see results for contestants they scored
      const judgeUser = await prisma.user.findUnique({
        where: { id: userId },
        include: { judge: true }
      })
      
      if (!judgeUser || !judgeUser.judge) {
        return res.json([])
      }
      
      // Filter to only scores from this judge
      whereClause.judgeId = judgeUser.judge.id
    } else if (!['ADMIN', 'ORGANIZER', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'EMCEE'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }

    const results = await prisma.score.findMany({
      where: whereClause,
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    log.error('Get contestant results error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoryResults = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const { categoryId } = req.params
    const userRole = req.user.role
    const userId = req.user.id

    // Verify category exists
    const category = await prisma.category.findUnique({
      where: { id: categoryId }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Role-based access control
    let whereClause = { categoryId }

    if (userRole === 'CONTESTANT') {
      // Contestants can only see their own scores
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { contestantId: true }
      })
      
      if (!user || !user.contestantId) {
        return res.json([])
      }
      
      whereClause.contestantId = user.contestantId
    } else if (userRole === 'JUDGE') {
      // Judges can see scores for categories they're assigned to
      const judgeUser = await prisma.user.findUnique({
        where: { id: userId },
        include: { judge: true }
      })
      
      if (!judgeUser || !judgeUser.judge) {
        return res.json([])
      }
      
      // Check assignment
      const assignment = await prisma.assignment.findFirst({
        where: {
          judgeId: judgeUser.judge.id,
          categoryId,
          status: { in: ['ACTIVE', 'COMPLETED', 'PENDING'] }
        }
      })
      
      if (!assignment) {
        // Also check if they have any scores in this category
        const hasScores = await prisma.score.findFirst({
          where: {
            categoryId,
            judgeId: judgeUser.judge.id
          }
        })
        
        if (!hasScores) {
          return res.status(403).json({ error: 'Not assigned to this category' })
        }
      }
    } else if (!['ADMIN', 'ORGANIZER', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'EMCEE'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }

    // Get all scores for this category
    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        contestant: true,
        judge: true,
        category: true,
        criterion: true
      }
    })

    // Group by contestant and calculate totals
    const resultsMap = new Map()
    
    scores.forEach((score) => {
      if (!score.contestant) return // Skip if no contestant
      
      const contestantId = score.contestantId
      
      if (!resultsMap.has(contestantId)) {
        resultsMap.set(contestantId, {
          contestant: score.contestant,
          category: score.category,
          totalScore: 0,
          averageScore: 0,
          scoreCount: 0,
          scores: []
        })
      }
      
      const result = resultsMap.get(contestantId)
      if (score.score !== null && score.score !== undefined) {
        result.totalScore += score.score
        result.scoreCount++
      }
      result.scores.push(score)
    })
    
    // Calculate averages and create final results array
    const results = Array.from(resultsMap.values()).map(result => ({
      ...result,
      averageScore: result.scoreCount > 0 ? result.totalScore / result.scoreCount : 0
    }))
    
    // Sort by total score descending
    results.sort((a, b) => b.totalScore - a.totalScore)
    
    // Add ranking
    results.forEach((result, index) => {
      result.rank = index + 1
    })

    res.json(results)
  } catch (error) {
    log.error('Get category results error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestResults = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const { contestId } = req.params
    const userRole = req.user.role
    const userId = req.user.id

    // Verify contest exists
    const contest = await prisma.contest.findUnique({
      where: { id: contestId }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Role-based access control
    let whereClause = {
      category: {
        contestId
      }
    }

    if (userRole === 'CONTESTANT') {
      // Contestants can only see their own scores
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { contestantId: true }
      })
      
      if (!user || !user.contestantId) {
        return res.json([])
      }
      
      whereClause.contestantId = user.contestantId
    } else if (userRole === 'JUDGE') {
      // Judges can see scores for contests they're assigned to
      const judgeUser = await prisma.user.findUnique({
        where: { id: userId },
        include: { judge: true }
      })
      
      if (!judgeUser || !judgeUser.judge) {
        return res.json([])
      }
      
      // Check assignment at contest or category level
      const assignment = await prisma.assignment.findFirst({
        where: {
          judgeId: judgeUser.judge.id,
          contestId,
          status: { in: ['ACTIVE', 'COMPLETED', 'PENDING'] }
        }
      })
      
      if (!assignment) {
        // Check if they have any scores in this contest
        const hasScores = await prisma.score.findFirst({
          where: {
            judgeId: judgeUser.judge.id,
            category: {
              contestId
            }
          }
        })
        
        if (!hasScores) {
          return res.status(403).json({ error: 'Not assigned to this contest' })
        }
      }
    } else if (!['ADMIN', 'ORGANIZER', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'EMCEE'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }

    const results = await prisma.score.findMany({
      where: whereClause,
      include: {
        category: true,
        contestant: true,
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    log.error('Get contest results error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEventResults = async (req, res) => {
  const log = createRequestLogger(req, 'results')
  try {
    const { eventId } = req.params
    const userRole = req.user.role
    const userId = req.user.id

    // Verify event exists
    const event = await prisma.event.findUnique({
      where: { id: eventId }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Role-based access control
    let whereClause = {
      category: {
        contest: {
          eventId
        }
      }
    }

    if (userRole === 'CONTESTANT') {
      // Contestants can only see their own scores
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { contestantId: true }
      })
      
      if (!user || !user.contestantId) {
        return res.json([])
      }
      
      whereClause.contestantId = user.contestantId
    } else if (userRole === 'JUDGE') {
      // Judges can see scores for events they're assigned to
      const judgeUser = await prisma.user.findUnique({
        where: { id: userId },
        include: { judge: true }
      })
      
      if (!judgeUser || !judgeUser.judge) {
        return res.json([])
      }
      
      // Check assignment at event, contest, or category level
      const assignment = await prisma.assignment.findFirst({
        where: {
          judgeId: judgeUser.judge.id,
          eventId,
          status: { in: ['ACTIVE', 'COMPLETED', 'PENDING'] }
        }
      })
      
      if (!assignment) {
        // Check if they have any scores in this event
        const hasScores = await prisma.score.findFirst({
          where: {
            judgeId: judgeUser.judge.id,
            category: {
              contest: {
                eventId
              }
            }
          }
        })
        
        if (!hasScores) {
          return res.status(403).json({ error: 'Not assigned to this event' })
        }
      }
    } else if (!['ADMIN', 'ORGANIZER', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'EMCEE'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }

    const results = await prisma.score.findMany({
      where: whereClause,
      include: {
        category: {
          include: {
            contest: true
          }
        },
        contestant: true,
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    log.error('Get event results error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllResults,
  getCategories,
  getContestantResults,
  getCategoryResults,
  getContestResults,
  getEventResults
}
