const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const getAllCategories = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    log.debug('Fetching all categories')
    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          },
          // Don't select archived field if it doesn't exist
        },
        criteria: {
          orderBy: { createdAt: 'asc' }
        },
        _count: {
          select: {
            criteria: true,
            scores: true,
            contestants: true,
            judges: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    }).catch(async (error) => {
      // If error is about archived column, retry without selecting it
      if (error.code === 'P2022' && error.meta?.column?.includes('archived')) {
        log.debug('Retrying category fetch without archived field')
        return await prisma.category.findMany({
          include: {
            contest: {
              select: {
                id: true,
                eventId: true,
                name: true,
                description: true,
                createdAt: true,
                updatedAt: true,
                contestantNumberingMode: true,
                nextContestantNumber: true,
                event: true
              }
            },
            criteria: {
              orderBy: { createdAt: 'asc' }
            },
            _count: {
              select: {
                criteria: true,
                scores: true,
                contestants: true,
                judges: true
              }
            }
          },
          orderBy: { createdAt: 'desc' }
        })
      }
      throw error
    })

    log.info('Categories retrieved successfully', { count: categories.length })
    res.json(categories)
  } catch (error) {
    log.error('Get categories error', { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoryById = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { id } = req.params
    log.debug('Fetching category by ID', { categoryId: id })

    const category = await prisma.category.findUnique({
      where: { id },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        criteria: true,
        contestants: true,
        judges: true,
        scores: true
      }
    })

    if (!category) {
      log.warn('Category not found', { categoryId: id })
      return res.status(404).json({ error: 'Category not found' })
    }

    log.info('Category retrieved successfully', { categoryId: id, name: category.name })
    res.json(category)
  } catch (error) {
    log.error('Get category error', { error: error.message, stack: error.stack, categoryId: req.params.id })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoriesByContest = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { contestId } = req.params
    log.debug('Fetching categories by contest', { contestId })

    const categories = await prisma.category.findMany({
      where: { contestId },
      include: {
        criteria: {
          orderBy: { createdAt: 'asc' }
        },
        _count: {
          select: {
            criteria: true,
            scores: true,
            contestants: true,
            judges: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Categories retrieved successfully', { contestId, count: categories.length })
    res.json(categories)
  } catch (error) {
    log.error('Get categories by contest error', { error: error.message, stack: error.stack, contestId: req.params.contestId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createCategory = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { name, description, scoreCap, order, templateId } = req.body
    // Get contestId from params (for /contest/:contestId route) or body (for generic / route)
    const contestId = req.params.contestId || req.body.contestId
    log.info('Category creation requested', { name, contestId, templateId, userId: req.user?.id })

    if (!name) {
      log.warn('Category creation failed: name is required', { contestId })
      return res.status(400).json({ error: 'Name is required' })
    }

    if (!contestId) {
      log.warn('Category creation failed: contestId is required')
      return res.status(400).json({ error: 'Contest ID is required' })
    }

    log.debug('Creating category record', { name, contestId })
    const category = await prisma.category.create({
      data: {
        name,
        description: description || null,
        scoreCap: scoreCap || null,
        contestId
      }
    })

    // Copy criteria from template if templateId is provided
    if (templateId) {
      log.debug('Copying criteria from template', { templateId, categoryId: category.id })
      const template = await prisma.categoryTemplate.findUnique({
        where: { id: templateId },
        include: { criteria: true }
      })

      if (template && template.criteria && template.criteria.length > 0) {
        log.debug('Copying criteria to category', { templateId, categoryId: category.id, criteriaCount: template.criteria.length })
        await prisma.criterion.createMany({
          data: template.criteria.map(c => ({
            categoryId: category.id,
            name: c.name,
            maxScore: c.maxScore
          }))
        })
        log.info('Criteria copied from template', { templateId, categoryId: category.id, criteriaCount: template.criteria.length })
      }
    }

    log.info('Category created successfully', { categoryId: category.id, name: category.name, contestId })
    res.status(201).json(category)
  } catch (error) {
    log.error('Create category error', { error: error.message, stack: error.stack, contestId: req.params.contestId || req.body.contestId, name: req.body.name })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateCategory = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { id } = req.params
    const { name, description, maxScore } = req.body
    log.info('Category update requested', { categoryId: id, name, userId: req.user?.id })

    log.debug('Updating category record', { categoryId: id })
    const category = await prisma.category.update({
      where: { id },
      data: {
        name,
        description,
        maxScore
      }
    })

    log.info('Category updated successfully', { categoryId: id, name: category.name })
    res.json(category)
  } catch (error) {
    log.error('Update category error', { error: error.message, stack: error.stack, categoryId: req.params.id })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteCategory = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { id } = req.params
    log.info('Category deletion requested', { categoryId: id, userId: req.user?.id })

    const categoryToDelete = await prisma.category.findUnique({
      where: { id },
      select: { id: true, name: true }
    })

    if (!categoryToDelete) {
      log.warn('Category deletion failed: category not found', { categoryId: id })
      return res.status(404).json({ error: 'Category not found' })
    }

    log.debug('Deleting category record', { categoryId: id, name: categoryToDelete.name })
    await prisma.category.delete({
      where: { id }
    })

    log.info('Category deleted successfully', { categoryId: id, name: categoryToDelete.name })
    res.status(204).send()
  } catch (error) {
    log.error('Delete category error', { error: error.message, stack: error.stack, categoryId: req.params.id })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get criteria for a category
const getCategoryCriteria = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { categoryId } = req.params
    log.debug('Fetching criteria for category', { categoryId })

    const criteria = await prisma.criterion.findMany({
      where: { categoryId },
      orderBy: { createdAt: 'asc' }
    })

    log.info('Category criteria retrieved successfully', { categoryId, count: criteria.length })
    res.json(criteria)
  } catch (error) {
    log.error('Get category criteria error', { error: error.message, stack: error.stack, categoryId: req.params.categoryId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Create criterion for a category
const createCriterion = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { categoryId } = req.params
    const { name, maxScore } = req.body
    log.info('Criterion creation requested', { categoryId, name, maxScore, userId: req.user?.id })

    if (!name || !maxScore) {
      log.warn('Criterion creation failed: missing required fields', { categoryId, hasName: !!name, hasMaxScore: !!maxScore })
      return res.status(400).json({ error: 'Name and maxScore are required' })
    }

    log.debug('Creating criterion record', { categoryId, name, maxScore })
    const criterion = await prisma.criterion.create({
      data: {
        categoryId,
        name,
        maxScore: parseInt(maxScore)
      }
    })

    log.info('Criterion created successfully', { criterionId: criterion.id, categoryId, name: criterion.name })
    res.status(201).json(criterion)
  } catch (error) {
    log.error('Create criterion error', { error: error.message, stack: error.stack, categoryId: req.params.categoryId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update criterion
const updateCriterion = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { criterionId } = req.params
    const { name, maxScore } = req.body
    log.info('Criterion update requested', { criterionId, name, maxScore, userId: req.user?.id })

    if (!name || !maxScore) {
      log.warn('Criterion update failed: missing required fields', { criterionId, hasName: !!name, hasMaxScore: !!maxScore })
      return res.status(400).json({ error: 'Name and maxScore are required' })
    }

    log.debug('Updating criterion record', { criterionId })
    const criterion = await prisma.criterion.update({
      where: { id: criterionId },
      data: {
        name,
        maxScore: parseInt(maxScore)
      }
    })

    log.info('Criterion updated successfully', { criterionId, name: criterion.name })
    res.json(criterion)
  } catch (error) {
    log.error('Update criterion error', { error: error.message, stack: error.stack, criterionId: req.params.criterionId })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Criterion not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Delete criterion
const deleteCriterion = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { criterionId } = req.params
    log.info('Criterion deletion requested', { criterionId, userId: req.user?.id })

    const criterionToDelete = await prisma.criterion.findUnique({
      where: { id: criterionId },
      select: { id: true, name: true, categoryId: true }
    })

    if (!criterionToDelete) {
      log.warn('Criterion deletion failed: criterion not found', { criterionId })
      return res.status(404).json({ error: 'Criterion not found' })
    }

    log.debug('Deleting criterion record', { criterionId, name: criterionToDelete.name })
    await prisma.criterion.delete({
      where: { id: criterionId }
    })

    log.info('Criterion deleted successfully', { criterionId, name: criterionToDelete.name, categoryId: criterionToDelete.categoryId })
    res.status(204).send()
  } catch (error) {
    log.error('Delete criterion error', { error: error.message, stack: error.stack, criterionId: req.params.criterionId })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Criterion not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Update category with optional timeLimit
const updateCategoryWithTimeLimit = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { id } = req.params
    const { name, description, scoreCap, timeLimit, contestantMin, contestantMax } = req.body
    log.info('Category update with time limit requested', { categoryId: id, userId: req.user?.id })

    const updateData = {}
    if (name) updateData.name = name
    if (description !== undefined) updateData.description = description
    if (scoreCap !== undefined) updateData.scoreCap = scoreCap
    if (timeLimit !== undefined) updateData.timeLimit = timeLimit
    if (contestantMin !== undefined) updateData.contestantMin = contestantMin
    if (contestantMax !== undefined) updateData.contestantMax = contestantMax

    log.debug('Updating category with time limit', { categoryId: id, updateData })
    const category = await prisma.category.update({
      where: { id },
      data: updateData
    })

    log.info('Category updated successfully', { categoryId: id, name: category.name })
    res.json(category)
  } catch (error) {
    log.error('Update category with time limit error', { error: error.message, stack: error.stack, categoryId: req.params.id })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Category not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const bulkDeleteCategories = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { contestId } = req.params
    const { categoryIds } = req.body
    log.info('Bulk category deletion requested', { contestId, categoryIdsCount: categoryIds?.length, userId: req.user?.id })

    if (!categoryIds || !Array.isArray(categoryIds) || categoryIds.length === 0) {
      log.warn('Bulk category deletion failed: invalid categoryIds', { contestId })
      return res.status(400).json({ error: 'Category IDs array is required' })
    }

    // Verify all categories belong to the contest
    log.debug('Verifying categories belong to contest', { contestId, categoryIdsCount: categoryIds.length })
    const categories = await prisma.category.findMany({
      where: {
        id: { in: categoryIds },
        contestId
      }
    })

    if (categories.length !== categoryIds.length) {
      log.warn('Bulk category deletion failed: some categories not found', { contestId, found: categories.length, requested: categoryIds.length })
      return res.status(400).json({ 
        error: 'Some categories not found or do not belong to this contest',
        found: categories.length,
        requested: categoryIds.length
      })
    }

    // Delete categories (cascade will handle related data)
    log.debug('Deleting categories', { contestId, categoryIdsCount: categoryIds.length })
    const result = await prisma.category.deleteMany({
      where: {
        id: { in: categoryIds },
        contestId
      }
    })

    log.info('Bulk categories deleted successfully', { contestId, deletedCount: result.count })
    res.json({
      message: `${result.count} categories deleted successfully`,
      deletedCount: result.count,
      deletedCategories: categories.map(c => ({ id: c.id, name: c.name }))
    })
  } catch (error) {
    log.error('Bulk delete categories error', { error: error.message, stack: error.stack, contestId: req.params.contestId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const bulkUpdateCategories = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { contestId } = req.params
    const { categoryIds, updates } = req.body
    log.info('Bulk category update requested', { contestId, categoryIdsCount: categoryIds?.length, userId: req.user?.id })

    if (!categoryIds || !Array.isArray(categoryIds) || categoryIds.length === 0) {
      log.warn('Bulk category update failed: invalid categoryIds', { contestId })
      return res.status(400).json({ error: 'Category IDs array is required' })
    }

    if (!updates || typeof updates !== 'object') {
      log.warn('Bulk category update failed: invalid updates object', { contestId })
      return res.status(400).json({ error: 'Updates object is required' })
    }

    // Verify all categories belong to the contest
    log.debug('Verifying categories belong to contest', { contestId, categoryIdsCount: categoryIds.length })
    const categories = await prisma.category.findMany({
      where: {
        id: { in: categoryIds },
        contestId
      }
    })

    if (categories.length !== categoryIds.length) {
      log.warn('Bulk category update failed: some categories not found', { contestId, found: categories.length, requested: categoryIds.length })
      return res.status(400).json({ 
        error: 'Some categories not found or do not belong to this contest',
        found: categories.length,
        requested: categoryIds.length
      })
    }

    // Prepare update data (only allow specific fields)
    const allowedFields = ['name', 'description', 'scoreCap', 'timeLimit', 'contestantMin', 'contestantMax']
    const updateData = {}
    
    allowedFields.forEach(field => {
      if (updates[field] !== undefined) {
        updateData[field] = updates[field]
      }
    })

    if (Object.keys(updateData).length === 0) {
      log.warn('Bulk category update failed: no valid fields to update', { contestId })
      return res.status(400).json({ error: 'No valid fields to update' })
    }

    // Update categories
    log.debug('Updating categories', { contestId, categoryIdsCount: categoryIds.length, updateData })
    const result = await prisma.category.updateMany({
      where: {
        id: { in: categoryIds },
        contestId
      },
      data: updateData
    })

    log.info('Bulk categories updated successfully', { contestId, updatedCount: result.count })
    res.json({
      message: `${result.count} categories updated successfully`,
      updatedCount: result.count,
      updates: updateData
    })
  } catch (error) {
    log.error('Bulk update categories error', { error: error.message, stack: error.stack, contestId: req.params.contestId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const bulkDeleteCriteria = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { categoryId } = req.params
    const { criterionIds } = req.body
    log.info('Bulk criterion deletion requested', { categoryId, criterionIdsCount: criterionIds?.length, userId: req.user?.id })

    if (!criterionIds || !Array.isArray(criterionIds) || criterionIds.length === 0) {
      log.warn('Bulk criterion deletion failed: invalid criterionIds', { categoryId })
      return res.status(400).json({ error: 'Criterion IDs array is required' })
    }

    // Verify all criteria belong to the category
    log.debug('Verifying criteria belong to category', { categoryId, criterionIdsCount: criterionIds.length })
    const criteria = await prisma.criterion.findMany({
      where: {
        id: { in: criterionIds },
        categoryId
      }
    })

    if (criteria.length !== criterionIds.length) {
      log.warn('Bulk criterion deletion failed: some criteria not found', { categoryId, found: criteria.length, requested: criterionIds.length })
      return res.status(400).json({ 
        error: 'Some criteria not found or do not belong to this category',
        found: criteria.length,
        requested: criterionIds.length
      })
    }

    // Delete criteria
    log.debug('Deleting criteria', { categoryId, criterionIdsCount: criterionIds.length })
    const result = await prisma.criterion.deleteMany({
      where: {
        id: { in: criterionIds },
        categoryId
      }
    })

    log.info('Bulk criteria deleted successfully', { categoryId, deletedCount: result.count })
    res.json({
      message: `${result.count} criteria deleted successfully`,
      deletedCount: result.count,
      deletedCriteria: criteria.map(c => ({ id: c.id, name: c.name }))
    })
  } catch (error) {
    log.error('Bulk delete criteria error', { error: error.message, stack: error.stack, categoryId: req.params.categoryId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const bulkUpdateCriteria = async (req, res) => {
  const log = createRequestLogger(req, 'categories')
  try {
    const { categoryId } = req.params
    const { criterionIds, updates } = req.body
    log.info('Bulk criterion update requested', { categoryId, criterionIdsCount: criterionIds?.length, userId: req.user?.id })

    if (!criterionIds || !Array.isArray(criterionIds) || criterionIds.length === 0) {
      log.warn('Bulk criterion update failed: invalid criterionIds', { categoryId })
      return res.status(400).json({ error: 'Criterion IDs array is required' })
    }

    if (!updates || typeof updates !== 'object') {
      log.warn('Bulk criterion update failed: invalid updates object', { categoryId })
      return res.status(400).json({ error: 'Updates object is required' })
    }

    // Verify all criteria belong to the category
    log.debug('Verifying criteria belong to category', { categoryId, criterionIdsCount: criterionIds.length })
    const criteria = await prisma.criterion.findMany({
      where: {
        id: { in: criterionIds },
        categoryId
      }
    })

    if (criteria.length !== criterionIds.length) {
      log.warn('Bulk criterion update failed: some criteria not found', { categoryId, found: criteria.length, requested: criterionIds.length })
      return res.status(400).json({ 
        error: 'Some criteria not found or do not belong to this category',
        found: criteria.length,
        requested: criterionIds.length
      })
    }

    // Prepare update data (only allow specific fields)
    const allowedFields = ['name', 'maxScore']
    const updateData = {}
    
    allowedFields.forEach(field => {
      if (updates[field] !== undefined) {
        updateData[field] = updates[field]
      }
    })

    if (Object.keys(updateData).length === 0) {
      log.warn('Bulk criterion update failed: no valid fields to update', { categoryId })
      return res.status(400).json({ error: 'No valid fields to update' })
    }

    // Update criteria one by one (Prisma doesn't support bulk update with different values)
    log.debug('Updating criteria', { categoryId, criterionIdsCount: criterionIds.length, updateData })
    const updatePromises = criterionIds.map(id => 
      prisma.criterion.update({
        where: { id },
        data: updateData
      })
    )

    await Promise.all(updatePromises)

    log.info('Bulk criteria updated successfully', { categoryId, updatedCount: criterionIds.length })
    res.json({
      message: `${criterionIds.length} criteria updated successfully`,
      updatedCount: criterionIds.length,
      updates: updateData
    })
  } catch (error) {
    log.error('Bulk update criteria error', { error: error.message, stack: error.stack, categoryId: req.params.categoryId })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoriesByContest,
  createCategory,
  updateCategory,
  deleteCategory,
  getCategoryCriteria,
  createCriterion,
  updateCriterion,
  deleteCriterion,
  updateCategoryWithTimeLimit,
  bulkDeleteCategories,
  bulkUpdateCategories,
  bulkDeleteCriteria,
  bulkUpdateCriteria
}
