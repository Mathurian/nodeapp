const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Database browser functions
const getDatabaseTables = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get database tables requested', { userId, userRole })

    // Get table information from pg_tables
    const tables = await prisma.$queryRaw`
      SELECT 
        schemaname,
        tablename,
        tableowner,
        hasindexes,
        hasrules,
        hastriggers
      FROM pg_tables 
      WHERE schemaname = 'public'
      ORDER BY tablename
    `

    // Get table row counts
    const tableCounts = await Promise.all(
      tables.map(async (table) => {
        try {
          const countResult = await prisma.$queryRawUnsafe(
            `SELECT COUNT(*) as count FROM "${table.tablename}"`
          )
          return {
            ...table,
            rowCount: parseInt(countResult[0].count)
          }
        } catch (error) {
          log.warn('Failed to count rows for table', { tableName: table.tablename, error: error.message })
          return {
            ...table,
            rowCount: null,
            error: 'Unable to count rows'
          }
        }
      })
    )

    log.info('Database tables fetched successfully', { tableCount: tableCounts.length, userId })
    res.json({
      data: {
        tables: tableCounts,
        totalTables: tableCounts.length
      }
    })
  } catch (error) {
    log.error('Get database tables error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: "Internal server error" })
  }
}

// Get table structure
const getTableStructure = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { tableName } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get table structure requested', { tableName, userId, userRole })

    const structure = await prisma.$queryRaw`
      SELECT column_name, data_type, is_nullable, column_default
      FROM information_schema.columns
      WHERE table_schema = 'public' AND table_name = ${tableName}
      ORDER BY ordinal_position
    `
    
    log.info('Table structure fetched successfully', { tableName, columnCount: structure.length, userId })
    res.json({ columns: structure })
  } catch (error) {
    log.error('Get table structure error', {
      error: error.message,
      stack: error.stack,
      tableName: req.params?.tableName
    })
    res.status(500).json({ error: "Internal server error" })
  }
}

// Get table data
const getTableData = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { tableName } = req.params
    const { page = 1, limit = 50, orderBy, orderDirection = 'asc' } = req.query
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get table data requested', { tableName, page, limit, orderBy, orderDirection, userId, userRole })

    if (!tableName) {
      log.warn('Table name missing for get table data', { userId })
      return res.status(400).json({ error: 'Table name is required' })
    }

    const offset = (parseInt(page) - 1) * parseInt(limit)
    const safeLimit = Math.min(parseInt(limit), 100) // Max 100 rows per page

    // Build ORDER BY clause
    let orderClause = ''
    if (orderBy) {
      const safeOrderBy = orderBy.replace(/[^a-zA-Z0-9_]/g, '') // Sanitize
      const safeDirection = orderDirection.toLowerCase() === 'desc' ? 'DESC' : 'ASC'
      orderClause = `ORDER BY "${safeOrderBy}" ${safeDirection}`
    }

    // Get total count
    const countResult = await prisma.$queryRawUnsafe(
      `SELECT COUNT(*) as count FROM "${tableName}"`
    )
    const totalRows = parseInt(countResult[0]?.count || 0)

    // Get data
    const data = await prisma.$queryRawUnsafe(
      `SELECT * FROM "${tableName}" ${orderClause} LIMIT ${safeLimit} OFFSET ${offset}`
    )

    log.info('Table data fetched successfully', { tableName, rowCount: data.length, totalRows, page, userId })
    
    // Extract column names from first row if data exists
    const columns = data.length > 0 ? Object.keys(data[0]) : []
    
    // Format response to match frontend expectations
    res.json({
      data: {
        rows: data,
        columns: columns,
        rowCount: totalRows,
        pagination: {
          page: parseInt(page),
          limit: safeLimit,
          totalRows,
          totalPages: Math.ceil(totalRows / safeLimit),
          hasNext: offset + safeLimit < totalRows,
          hasPrev: parseInt(page) > 1
        },
        tableName
      }
    })
  } catch (error) {
    log.error('Get table data error', {
      error: error.message,
      stack: error.stack,
      tableName: req.params?.tableName
    })
    res.status(500).json({ error: "Internal server error" })
  }
}

const executeDatabaseQuery = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { query } = req.body
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Execute database query requested', { queryLength: query?.length, userId, userRole })
    
    if (!query || typeof query !== "string") {
      log.warn('Invalid query provided', { userId })
      return res.status(400).json({ error: "Query is required" })
    }

    // Basic SQL injection protection
    const dangerousKeywords = ["DROP", "DELETE", "UPDATE", "INSERT", "ALTER", "CREATE", "TRUNCATE"]
    const upperQuery = query.toUpperCase()
    
    if (dangerousKeywords.some(keyword => upperQuery.includes(keyword))) {
      log.warn('Dangerous SQL keyword detected in query', { userId, dangerousKeywords: dangerousKeywords.filter(k => upperQuery.includes(k)) })
      return res.status(400).json({ error: "Only SELECT queries are allowed" })
    }

    const startTime = Date.now()
    const results = await prisma.$queryRawUnsafe(query)
    const executionTime = Date.now() - startTime

    // Convert results to array format
    const rows = Array.isArray(results) ? results : [results]
    const columns = rows.length > 0 ? Object.keys(rows[0]) : []

    log.info('Database query executed successfully', { rowCount: rows.length, executionTime, userId })
    res.json({
      columns,
      rows,
      rowCount: rows.length,
      executionTime
    })
  } catch (error) {
    log.error('Execute database query error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: "Query execution failed: " + error.message })
  }
}

const getStats = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get admin stats requested', { userId, userRole })

    // Get basic counts
    // Note: JudgeCertification.certifiedAt is non-nullable (has @default(now()))
    // So pending certifications don't exist in this model
    const [totalUsers, totalEvents, totalContests, totalCategories, totalScores, activeUsersCount] = await Promise.all([
      prisma.user.count(),
      prisma.event.count(),
      prisma.contest.count(),
      prisma.category.count(),
      prisma.score.count(),
      prisma.user.count({ where: { isActive: true } })
    ])
    
    // Calculate uptime from process start time
    let uptimeSeconds = 0
    let uptimeFormatted = 'N/A'
    try {
      // Get process uptime from systemd if available
      const { execSync } = require('child_process')
      try {
        const uptimeOutput = execSync('systemctl show event-manager.service -p ActiveEnterTimestamp --value', { encoding: 'utf-8', timeout: 1000 })
        if (uptimeOutput && uptimeOutput.trim()) {
          const startTime = new Date(uptimeOutput.trim())
          uptimeSeconds = Math.floor((Date.now() - startTime.getTime()) / 1000)
        }
      } catch (e) {
        // Fallback: calculate from process start time
        uptimeSeconds = Math.floor(process.uptime())
      }
      
      // Format uptime in human-readable format
      const days = Math.floor(uptimeSeconds / 86400)
      const hours = Math.floor((uptimeSeconds % 86400) / 3600)
      const minutes = Math.floor((uptimeSeconds % 3600) / 60)
      const seconds = uptimeSeconds % 60
      
      const parts = []
      if (days > 0) parts.push(`${days} day${days !== 1 ? 's' : ''}`)
      if (hours > 0) parts.push(`${hours} hour${hours !== 1 ? 's' : ''}`)
      if (minutes > 0 && days === 0) parts.push(`${minutes} minute${minutes !== 1 ? 's' : ''}`)
      if (seconds > 0 && days === 0 && hours === 0) parts.push(`${seconds} second${seconds !== 1 ? 's' : ''}`)
      
      uptimeFormatted = parts.length > 0 ? parts.join(', ') : 'Just started'
    } catch (error) {
      log.warn('Could not calculate uptime', { error: error.message })
      uptimeFormatted = 'N/A'
    }

    // Get certification breakdown by role
    const certificationBreakdown = {
      judge: 0,
      tallyMaster: 0,
      auditor: 0,
      board: 0
    }
    
    try {
      // Count pending certifications by role
      // Judge certifications (pending = not certified yet)
      const pendingJudgeCerts = await prisma.$queryRaw`
        SELECT COUNT(*) as count
        FROM categories c
        LEFT JOIN "JudgeCertification" jc ON jc."categoryId" = c.id
        WHERE jc.id IS NULL
      `
      certificationBreakdown.judge = parseInt(pendingJudgeCerts[0]?.count || 0)
      
      // Tally Master certifications (pending = not certified yet)
      const pendingTallyCerts = await prisma.categoryCertification.count({
        where: {
          role: 'TALLY_MASTER'
        }
      })
      const totalCategoriesForTally = await prisma.category.count()
      certificationBreakdown.tallyMaster = Math.max(0, totalCategoriesForTally - pendingTallyCerts)
      
      // Auditor certifications (pending = not certified yet)
      const pendingAuditorCerts = await prisma.categoryCertification.count({
        where: {
          role: 'AUDITOR'
        }
      })
      certificationBreakdown.auditor = Math.max(0, totalCategoriesForTally - pendingAuditorCerts)
      
      // Board/Admin/Organizer certifications
      const pendingBoardCerts = await prisma.categoryCertification.count({
        where: {
          role: { in: ['BOARD', 'ORGANIZER', 'ADMIN'] }
        }
      })
      certificationBreakdown.board = Math.max(0, totalCategoriesForTally - pendingBoardCerts)
    } catch (error) {
      log.warn('Could not get certification breakdown', { error: error.message })
    }

    // Get database size
    let databaseSize = '0 bytes'
    try {
      const dbSizeResult = await prisma.$queryRaw`
        SELECT pg_size_pretty(pg_database_size(current_database())) as size
      `
      databaseSize = dbSizeResult[0]?.size || '0 bytes'
    } catch (error) {
      log.warn('Could not get database size', { error: error.message })
    }

    // Get last backup
    let lastBackup = null
    try {
      const lastBackupRecord = await prisma.backupLog.findFirst({
        where: { status: 'COMPLETED' },
        orderBy: { createdAt: 'desc' },
        select: { createdAt: true }
      })
      lastBackup = lastBackupRecord?.createdAt || null
    } catch (error) {
      log.warn('Could not get last backup', { error: error.message })
    }

    // Pending certifications are always 0 since certifiedAt has a default value
    const pendingCert = 0

    const stats = {
      totalUsers,
      totalEvents,
      totalContests,
      totalCategories,
      totalScores,
      activeUsers: activeUsersCount,
      pendingCertifications: pendingCert,
      certificationBreakdown,
      systemHealth: 'HEALTHY',
      lastBackup: lastBackup ? lastBackup.toISOString() : null,
      databaseSize,
      uptime: uptimeFormatted,
      uptimeSeconds
    }

    log.info('Admin stats fetched successfully', { stats, userId })
    res.json(stats)
  } catch (error) {
    log.error('Get stats error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getLogs = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get logs requested', { userId, userRole })

    const logs = await prisma.activityLog.findMany({
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    log.info('Logs fetched successfully', { count: logs.length, userId })
    res.json(logs)
  } catch (error) {
    log.error('Get logs error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getActiveUsers = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get active users requested', { userId, userRole })

    const activeUsers = await prisma.user.findMany({
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true
      }
    })
    
    log.info('Active users fetched successfully', { count: activeUsers.length, userId })
    res.json(activeUsers)
  } catch (error) {
    log.error('Get active users error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getUsers = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get users requested', { userId, userRole })

    const users = await prisma.user.findMany({
      include: {
        judge: true,
        contestant: true
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Users fetched successfully', { count: users.length, userId })
    res.json(users)
  } catch (error) {
    log.error('Get users error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEvents = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get events requested', { userId, userRole })

    const events = await prisma.event.findMany({
      include: {
        _count: {
          select: {
            contests: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Events fetched successfully', { count: events.length, userId })
    res.json(events)
  } catch (error) {
    log.error('Get events error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContests = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get contests requested', { userId, userRole })

    const contests = await prisma.contest.findMany({
      include: {
        event: true,
        _count: {
          select: {
            categories: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Contests fetched successfully', { count: contests.length, userId })
    res.json(contests)
  } catch (error) {
    log.error('Get contests error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get categories requested', { userId, userRole })

    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          }
        },
        _count: {
          select: {
            criteria: true,
            contestants: true,
            judges: true,
            scores: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Categories fetched successfully', { count: categories.length, userId })
    res.json(categories)
  } catch (error) {
    log.error('Get categories error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getScores = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get scores requested', { userId, userRole })

    const scores = await prisma.score.findMany({
      include: {
        contestant: true,
        judge: true,
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    log.info('Scores fetched successfully', { count: scores.length, userId })
    res.json(scores)
  } catch (error) {
    log.error('Get scores error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getActivityLogs = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get activity logs requested', { userId, userRole })

    const logs = await prisma.activityLog.findMany({
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    log.info('Activity logs fetched successfully', { count: logs.length, userId })
    res.json(logs)
  } catch (error) {
    log.error('Get activity logs error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAuditLogs = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get audit logs requested', { userId, userRole })

    const logs = await prisma.activityLog.findMany({
      where: {
        action: {
          in: ['CERTIFY_SCORES', 'CERTIFY_TOTALS', 'FINAL_CERTIFICATION', 'APPROVE_CERTIFICATION', 'REJECT_CERTIFICATION']
        }
      },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    log.info('Audit logs fetched successfully', { count: logs.length, userId })
    res.json(logs)
  } catch (error) {
    log.error('Get audit logs error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const exportAuditLogs = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Export audit logs requested', { userId, userRole })

    const logs = await prisma.activityLog.findMany({
      where: {
        action: {
          in: ['CERTIFY_SCORES', 'CERTIFY_TOTALS', 'FINAL_CERTIFICATION', 'APPROVE_CERTIFICATION', 'REJECT_CERTIFICATION']
        }
      },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    log.info('Audit logs exported successfully', { count: logs.length, userId })
    res.json(logs)
  } catch (error) {
    log.error('Export audit logs error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const nodemailer = require('nodemailer')

const testConnection = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { type } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Test connection requested', { type, userId, userRole })
    
    switch (type) {
      case 'database':
        const result = await prisma.$queryRaw`SELECT 1 as test`
        if (result && result.length > 0) {
          log.info('Database connection test passed', { userId })
          return res.json({ status: 'success', message: 'Database connection test passed' })
        } else {
          log.warn('Database connection test failed', { userId })
          return res.status(500).json({ status: 'error', message: 'Database connection test failed' })
        }
        
      case 'email':
        // Get email settings from database
        const emailSettings = await prisma.systemSetting.findMany({
          where: { category: 'email' }
        })
        
        const emailConfig = {}
        emailSettings.forEach(setting => {
          // Handle both email_* and smtp_* prefixes
          let key = setting.key.replace('email_', '').replace('smtp_', '')
          emailConfig[key] = setting.value
        })
        
        log.debug('Email config retrieved', { emailConfig: { ...emailConfig, password: '***' }, userId })
        
        // Check if email is enabled
        if (emailConfig.enabled !== 'true') {
          log.warn('Email test failed - email disabled', { userId })
          return res.json({ 
            status: 'error', 
            message: 'Email is disabled in settings' 
          })
        }
        
        // Check if required settings exist
        if (!emailConfig.host || !emailConfig.user) {
          log.warn('Email test failed - incomplete configuration', { userId })
          return res.json({ 
            status: 'error', 
            message: 'Email configuration is incomplete. Please configure SMTP settings.' 
          })
        }
        
        // Validate host format (must be valid domain or IP)
        if (emailConfig.host.length < 3) {
          log.warn('Email test failed - invalid host', { host: emailConfig.host, userId })
          const errorResponse = { 
            status: 'error', 
            message: 'SMTP host is invalid. Host must be at least 3 characters long (e.g., smtp.gmail.com).' 
          }
          res.status(200).json(errorResponse)
          return
        }
        
        // Check for common invalid patterns
        if (emailConfig.host.match(/^[a-z]$/i)) {
          log.warn('Email test failed - invalid host pattern', { host: emailConfig.host, userId })
          return res.json({ 
            status: 'error', 
            message: 'SMTP host is invalid. Please enter a valid SMTP server address (e.g., smtp.gmail.com).' 
          })
        }
        
        // Validate port
        const portNum = parseInt(emailConfig.port)
        if (!emailConfig.port || isNaN(portNum) || portNum < 1 || portNum > 65535) {
          log.warn('Email test failed - invalid port', { port: emailConfig.port, userId })
          return res.json({ 
            status: 'error', 
            message: 'SMTP port is invalid. Please enter a valid port number (1-65535).' 
          })
        }
        
        try {
          // Determine secure/TLS settings
          // IMPORTANT: Port 587 MUST use STARTTLS (secure: false, requireTLS: true)
          // Port 465 MUST use direct SSL (secure: true)
          // The SSL checkbox is IGNORED for these standard ports
          const portNum = parseInt(emailConfig.port) || 587
          const isPort465 = portNum === 465
          const isPort587 = portNum === 587
          
          let secure = false
          let requireTLS = false
          
          if (isPort465) {
            // Port 465 requires direct SSL - ignore any other settings
            secure = true
            requireTLS = false
            log.debug('Using port 465 - forcing direct SSL', { userId })
          } else if (isPort587) {
            // Port 587 requires STARTTLS - ignore SSL checkbox, always use STARTTLS
            secure = false
            requireTLS = true
            log.debug('Using port 587 - forcing STARTTLS', { userId })
          } else {
            // For other ports, respect the secure setting
            const useSecure = emailConfig.secure === 'true' || emailConfig.secure === true
            secure = useSecure
            requireTLS = useSecure && !isPort465
            log.debug('Using custom port - respecting SSL setting', { port: portNum, useSecure, userId })
          }
          
          log.debug('SMTP connection configuration', { host: emailConfig.host, port: portNum, secure, requireTLS, userId })
          
          // Create transporter with proper TLS/SSL configuration
          const transporterConfig = {
            host: emailConfig.host,
            port: portNum,
            secure: secure, // MUST be false for port 587
            auth: {
              user: emailConfig.user,
              pass: emailConfig.password
            },
            // Add timeout for faster failure detection
            connectionTimeout: 10000,
            greetingTimeout: 10000,
            socketTimeout: 10000
          }
          
          // For port 587 (STARTTLS), we need requireTLS but NOT the tls option
          if (isPort587) {
            transporterConfig.requireTLS = true
            // Do NOT set tls option for STARTTLS - let nodemailer handle it
          } else if (isPort465) {
            // Port 465 uses direct SSL - secure: true is already set
          } else {
            // For other ports, add TLS options if using secure
            if (secure) {
              transporterConfig.tls = {
                rejectUnauthorized: false
              }
            } else if (requireTLS) {
              transporterConfig.requireTLS = true
            }
          }
          
          // Double-check: If port is 587, ensure secure is false and requireTLS is true
          if (isPort587) {
            transporterConfig.secure = false
            transporterConfig.requireTLS = true
            delete transporterConfig.tls
          }
          
          log.debug('Transporter config (final)', { 
            host: transporterConfig.host, 
            port: transporterConfig.port, 
            secure: transporterConfig.secure, 
            requireTLS: transporterConfig.requireTLS,
            hasTls: !!transporterConfig.tls,
            userId 
          })
          
          const transporter = nodemailer.createTransport(transporterConfig)
          
          // Test the connection using verify()
          log.debug('Verifying SMTP connection', { userId })
          await transporter.verify()
          
          log.info('SMTP connection verified successfully', { userId })
          
          // Send test email
          const result = await transporter.sendMail({
            from: emailConfig.from || emailConfig.user,
            to: req.user.email,
            subject: 'Test Email from Event Manager',
            text: 'This is a test email. Your email configuration is working correctly.',
            html: '<p>This is a test email. Your email configuration is working correctly.</p>'
          })
          
          // Log test email
          try {
            await prisma.emailLog.create({
              data: {
                to: req.user.email,
                subject: 'Test Email from Event Manager',
                status: 'SENT',
                sentAt: new Date(),
                messageId: result.messageId
              }
            })
          } catch (logError) {
            // Don't fail if logging fails
            log.warn('Failed to log test email:', logError.message)
          }
          
          log.info('Test email sent successfully', { messageId: result.messageId, to: req.user.email, userId })
          
          return res.json({ 
            status: 'success', 
            message: `Test email sent successfully to ${req.user.email}` 
          })
        } catch (emailError) {
          // Log failed test email
          try {
            await prisma.emailLog.create({
              data: {
                to: req.user.email,
                subject: 'Test Email from Event Manager',
                status: 'FAILED',
                sentAt: new Date(),
                errorMessage: emailError.message
              }
            })
          } catch (logError) {
            // Don't fail if logging fails
            log.warn('Failed to log test email error:', logError.message)
          }
          
          log.error('Email test error', {
            error: emailError.message,
            code: emailError.code,
            stack: emailError.stack,
            userId
          })
          return res.json({ 
            status: 'error', 
            message: `SMTP verification failed: ${emailError.message}` 
          })
        }
        
      case 'backup':
        log.info('Backup test passed', { userId })
        return res.json({ status: 'success', message: 'Backup test passed' })
        
      default:
        log.warn('Invalid test type requested', { type, userId })
        return res.status(400).json({ error: 'Invalid test type' })
    }
  } catch (error) {
    log.error('Test connection error', {
      error: error.message,
      stack: error.stack,
      type: req.params?.type
    })
    return res.status(500).json({ status: 'error', message: `Test failed: ${error.message}` })
  }
}

const forceLogoutAllUsers = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Force logout all users requested', { userId, userRole })

    // Increment session version for all users
    const result = await prisma.user.updateMany({
      data: {
        sessionVersion: {
          increment: 1
        }
      }
    })

    log.info('All users logged out successfully', { affectedUsers: result.count, userId })
    res.json({
      message: 'All users logged out successfully',
      affectedUsers: result.count
    })
  } catch (error) {
    log.error('Force logout all users error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const forceLogoutUser = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { id } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Force logout user requested', { targetUserId: id, userId, userRole })

    const user = await prisma.user.findUnique({
      where: { id },
      select: { id: true, name: true, email: true }
    })

    if (!user) {
      log.warn('User not found for force logout', { targetUserId: id, userId })
      return res.status(404).json({ error: 'User not found' })
    }

    // Increment session version to invalidate current sessions
    await prisma.user.update({
      where: { id },
      data: {
        sessionVersion: {
          increment: 1
        }
      }
    })

    log.info('User logged out successfully', { targetUserId: id, targetUserName: user.name, userId })
    res.json({
      message: `User ${user.name} logged out successfully`,
      user
    })
  } catch (error) {
    log.error('Force logout user error', {
      error: error.message,
      stack: error.stack,
      targetUserId: req.params?.id
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestantScores = async (req, res) => {
  const log = createRequestLogger(req, 'admin')
  try {
    const { contestantId } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.debug('Get contestant scores requested', { contestantId, userId, userRole })

    const contestant = await prisma.contestant.findUnique({
      where: { id: contestantId },
      include: {
        scores: {
          include: {
            category: {
              include: {
                contest: {
                  include: {
                    event: true
                  }
                }
              }
            },
            judge: true,
            criterion: true
          },
          orderBy: [
            { category: { createdAt: 'asc' } },
            { createdAt: 'asc' }
          ]
        },
        categoryContestants: {
          include: {
            category: {
              include: {
                contest: {
                  include: {
                    event: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contestant) {
      log.warn('Contestant not found', { contestantId, userId })
      return res.status(404).json({ error: 'Contestant not found' })
    }

    log.info('Contestant scores fetched successfully', { contestantId, scoreCount: contestant.scores.length, userId })
    res.json(contestant)
  } catch (error) {
    log.error('Get contestant scores error', {
      error: error.message,
      stack: error.stack,
      contestantId: req.params?.contestantId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getDatabaseTables,
  getTableStructure,
  getTableData,
  executeDatabaseQuery,
  getStats,
  getLogs,
  getActiveUsers,
  getUsers,
  getEvents,
  getContests,
  getCategories,
  getScores,
  getActivityLogs,
  getAuditLogs,
  exportAuditLogs,
  testConnection,
  forceLogoutAllUsers,
  forceLogoutUser,
  getContestantScores
}
