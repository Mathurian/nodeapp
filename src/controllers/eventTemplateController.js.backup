const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const createTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const { name, description, contests, categories } = req.body

    if (!name || !contests || !categories) {
      return res.status(400).json({ error: 'Name, contests, and categories are required' })
    }

    const template = await prisma.eventTemplate.create({
      data: {
        name,
        description: description || null,
        contests: JSON.stringify(contests),
        categories: JSON.stringify(categories),
        createdBy: req.user.id
      }
    })

    res.status(201).json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      createdAt: template.createdAt
    })
  } catch (error) {
    log.error('Create template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTemplates = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const templates = await prisma.eventTemplate.findMany({
      include: {
        creator: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    const formattedTemplates = templates.map(template => ({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      creator: template.creator,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt
    }))

    res.json(formattedTemplates)
  } catch (error) {
    log.error('Get templates error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const { id } = req.params

    const template = await prisma.eventTemplate.findUnique({
      where: { id },
      include: {
        creator: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    res.json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      creator: template.creator,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt
    })
  } catch (error) {
    log.error('Get template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const { id } = req.params
    const { name, description, contests, categories } = req.body

    if (!name || !contests || !categories) {
      return res.status(400).json({ error: 'Name, contests, and categories are required' })
    }

    const template = await prisma.eventTemplate.update({
      where: { id },
      data: {
        name,
        description: description || null,
        contests: JSON.stringify(contests),
        categories: JSON.stringify(categories)
      }
    })

    res.json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      updatedAt: template.updatedAt
    })
  } catch (error) {
    log.error('Update template error:', error, { error: error.message, stack: error.stack })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Template not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const deleteTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const { id } = req.params

    await prisma.eventTemplate.delete({
      where: { id }
    })

    res.json({ message: 'Template deleted successfully' })
  } catch (error) {
    log.error('Delete template error:', error, { error: error.message, stack: error.stack })
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Template not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const createEventFromTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'eventtemplate')
  try {
    const { templateId, eventName, eventDescription, startDate, endDate } = req.body

    if (!templateId || !eventName || !startDate || !endDate) {
      return res.status(400).json({ error: 'Template ID, event name, start date, and end date are required' })
    }

    const template = await prisma.eventTemplate.findUnique({
      where: { id: templateId }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    const contests = JSON.parse(template.contests)
    const categories = JSON.parse(template.categories)

    // Create the event
    const event = await prisma.event.create({
      data: {
        name: eventName,
        description: eventDescription || null,
        startDate: new Date(startDate),
        endDate: new Date(endDate)
      }
    })

    // Create contests from template
    for (const contestTemplate of contests) {
      const contest = await prisma.contest.create({
        data: {
          eventId: event.id,
          name: contestTemplate.name,
          description: contestTemplate.description || null
        }
      })

      // Create categories for this contest
      const contestCategories = categories.filter(cat => cat.contestId === contestTemplate.id)
      for (const categoryTemplate of contestCategories) {
        const createdCategory = await prisma.category.create({
          data: {
            contestId: contest.id,
            name: categoryTemplate.name,
            description: categoryTemplate.description || null,
            scoreCap: categoryTemplate.scoreCap || null,
            timeLimit: categoryTemplate.timeLimit || null,
            contestantMin: categoryTemplate.contestantMin || null,
            contestantMax: categoryTemplate.contestantMax || null
          }
        })

        // Copy criteria from template if they exist
        if (categoryTemplate.criteria && categoryTemplate.criteria.length > 0) {
          await prisma.criterion.createMany({
            data: categoryTemplate.criteria.map(c => ({
              categoryId: createdCategory.id,
              name: c.name,
              maxScore: c.maxScore || 10
            }))
          })
        }
      }
    }

    res.status(201).json({
      id: event.id,
      name: event.name,
      description: event.description,
      startDate: event.startDate,
      endDate: event.endDate,
      createdAt: event.createdAt
    })
  } catch (error) {
    log.error('Create event from template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  createTemplate,
  getTemplates,
  getTemplate,
  updateTemplate,
  deleteTemplate,
  createEventFromTemplate
}
