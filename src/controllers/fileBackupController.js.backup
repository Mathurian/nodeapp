const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const { exec } = require('child_process')
const { promisify } = require('util')
const { generateSecurePassword, encryptMetadata, decryptMetadata } = require('../middleware/fileEncryption')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')
const execAsync = promisify(exec)

// File Backup and Recovery Functions

// Create file backup
const createFileBackup = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const { backupType = 'FULL', description = '', includeMetadata = true } = req.body

    const backupId = `file-backup-${Date.now()}`
    const backupDir = path.join(__dirname, '../backups/files', backupId)
    
    // Create backup directory
    await fs.mkdir(backupDir, { recursive: true })

    let backupData = {
      id: backupId,
      type: backupType,
      description,
      createdAt: new Date().toISOString(),
      createdBy: req.user.id,
      status: 'IN_PROGRESS',
      files: [],
      metadata: {}
    }

    // Get all files to backup
    const files = await prisma.file.findMany({
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })

    let totalSize = 0
    let processedFiles = 0
    const errors = []

    for (const file of files) {
      try {
        // Check if file exists on disk
        const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
        
        if (!fileExists) {
          errors.push({ fileId: file.id, error: 'File not found on disk' })
          continue
        }

        // Create file backup entry
        const fileBackup = {
          id: file.id,
          filename: file.filename,
          originalName: file.originalName,
          mimeType: file.mimeType,
          size: file.size,
          category: file.category,
          uploadedAt: file.uploadedAt,
          uploadedBy: file.uploadedBy,
          isPublic: file.isPublic,
          checksum: file.checksum,
          metadata: includeMetadata ? file.metadata : null,
          user: file.user
        }

        // Copy file to backup directory
        const backupFilePath = path.join(backupDir, file.filename)
        await fs.copyFile(file.path, backupFilePath)

        // Verify backup integrity
        const stats = await fs.stat(backupFilePath)
        if (stats.size !== file.size) {
          errors.push({ fileId: file.id, error: 'Backup size mismatch' })
          await fs.unlink(backupFilePath)
          continue
        }

        backupData.files.push(fileBackup)
        totalSize += file.size
        processedFiles++

      } catch (error) {
        errors.push({ fileId: file.id, error: error.message })
      }
    }

    // Create backup manifest
    backupData.metadata = {
      totalFiles: files.length,
      processedFiles,
      totalSize,
      errors,
      backupVersion: '1.0',
      systemInfo: {
        nodeVersion: process.version,
        platform: process.platform,
        arch: process.arch
      }
    }

    // Save backup manifest
    const manifestPath = path.join(backupDir, 'manifest.json')
    await fs.writeFile(manifestPath, JSON.stringify(backupData, null, 2))

    // Create compressed backup
    const compressedPath = `${backupDir}.tar.gz`
    await execAsync(`tar -czf "${compressedPath}" -C "${path.dirname(backupDir)}" "${path.basename(backupDir)}"`)

    // Remove uncompressed directory
    await fs.rmdir(backupDir, { recursive: true })

    // Save backup record to database
    const backupRecord = await prisma.report.create({
      data: {
        name: `File Backup - ${backupType}`,
        description: description || `File backup created on ${new Date().toISOString()}`,
        type: 'FILE_BACKUP',
        parameters: {
          backupId,
          backupType,
          totalFiles: files.length,
          processedFiles,
          totalSize,
          errors: errors.length
        },
        generatedBy: req.user.id,
        status: 'COMPLETED'
      }
    })

    res.json({
      backup: backupRecord,
      backupData: {
        id: backupId,
        type: backupType,
        totalFiles: files.length,
        processedFiles,
        totalSize,
        errors: errors.length,
        compressedPath,
        manifestPath
      },
      message: 'File backup created successfully'
    })
  } catch (error) {
    log.error('Create file backup error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Restore file backup
const restoreFileBackup = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const { backupId } = req.params
    const { restoreOptions = {} } = req.body

    const backupDir = path.join(__dirname, '../backups/files', backupId)
    const compressedPath = `${backupDir}.tar.gz`

    // Check if backup exists
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (!backupExists) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Extract backup
    await execAsync(`tar -xzf "${compressedPath}" -C "${path.dirname(backupDir)}"`)

    // Read backup manifest
    const manifestPath = path.join(backupDir, 'manifest.json')
    const manifestData = await fs.readFile(manifestPath, 'utf8')
    const backupData = JSON.parse(manifestData)

    const restoreResults = {
      restored: 0,
      skipped: 0,
      errors: [],
      totalSize: 0
    }

    // Restore files
    for (const fileBackup of backupData.files) {
      try {
        // Check if file already exists
        const existingFile = await prisma.file.findUnique({
          where: { id: fileBackup.id }
        })

        if (existingFile && !restoreOptions.overwrite) {
          restoreResults.skipped++
          continue
        }

        // Restore file to original location
        const backupFilePath = path.join(backupDir, fileBackup.filename)
        const fileExists = await fs.access(backupFilePath).then(() => true).catch(() => false)
        
        if (!fileExists) {
          restoreResults.errors.push({ fileId: fileBackup.id, error: 'Backup file not found' })
          continue
        }

        // Create directory if it doesn't exist
        const targetDir = path.dirname(fileBackup.path || `/uploads/${fileBackup.filename}`)
        await fs.mkdir(targetDir, { recursive: true })

        // Copy file back
        const targetPath = fileBackup.path || `/uploads/${fileBackup.filename}`
        await fs.copyFile(backupFilePath, targetPath)

        // Update or create database record
        if (existingFile) {
          await prisma.file.update({
            where: { id: fileBackup.id },
            data: {
              filename: fileBackup.filename,
              originalName: fileBackup.originalName,
              mimeType: fileBackup.mimeType,
              size: fileBackup.size,
              category: fileBackup.category,
              path: targetPath,
              checksum: fileBackup.checksum,
              metadata: fileBackup.metadata,
              isPublic: fileBackup.isPublic
            }
          })
        } else {
          await prisma.file.create({
            data: {
              id: fileBackup.id,
              filename: fileBackup.filename,
              originalName: fileBackup.originalName,
              mimeType: fileBackup.mimeType,
              size: fileBackup.size,
              category: fileBackup.category,
              path: targetPath,
              uploadedBy: fileBackup.uploadedBy,
              uploadedAt: new Date(fileBackup.uploadedAt),
              checksum: fileBackup.checksum,
              metadata: fileBackup.metadata,
              isPublic: fileBackup.isPublic
            }
          })
        }

        restoreResults.restored++
        restoreResults.totalSize += fileBackup.size

      } catch (error) {
        restoreResults.errors.push({ fileId: fileBackup.id, error: error.message })
      }
    }

    // Clean up extracted files
    await fs.rmdir(backupDir, { recursive: true })

    // Log restore operation
    await prisma.report.create({
      data: {
        name: `File Restore - ${backupId}`,
        description: `File backup restored on ${new Date().toISOString()}`,
        type: 'FILE_RESTORE',
        parameters: {
          backupId,
          restoreResults
        },
        generatedBy: req.user.id,
        status: 'COMPLETED'
      }
    })

    res.json({
      restoreResults,
      message: 'File backup restored successfully'
    })
  } catch (error) {
    log.error('Restore file backup error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// List file backups
const listFileBackups = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const backups = await prisma.report.findMany({
      where: {
        type: {
          in: ['FILE_BACKUP', 'FILE_RESTORE']
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 50,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    res.json({
      backups,
      message: 'File backups retrieved successfully'
    })
  } catch (error) {
    log.error('List file backups error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete file backup
const deleteFileBackup = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const { backupId } = req.params

    // Find backup record
    const backup = await prisma.report.findFirst({
      where: {
        type: 'FILE_BACKUP',
        parameters: {
          path: ['backupId'],
          equals: backupId
        }
      }
    })

    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Delete backup files
    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (backupExists) {
      await fs.unlink(compressedPath)
    }

    // Delete backup record
    await prisma.report.delete({
      where: { id: backup.id }
    })

    res.json({ message: 'File backup deleted successfully' })
  } catch (error) {
    log.error('Delete file backup error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get backup details
const getBackupDetails = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const { backupId } = req.params

    const backup = await prisma.report.findFirst({
      where: {
        type: 'FILE_BACKUP',
        parameters: {
          path: ['backupId'],
          equals: backupId
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Check if backup file exists
    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)

    const stats = backupExists ? await fs.stat(compressedPath) : null

    res.json({
      backup: {
        ...backup,
        fileExists: backupExists,
        fileSize: stats ? stats.size : 0,
        lastModified: stats ? stats.mtime : null
      },
      message: 'Backup details retrieved successfully'
    })
  } catch (error) {
    log.error('Get backup details error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Download backup
const downloadBackup = async (req, res) => {
  const log = createRequestLogger(req, 'filebackup')
  try {
    const { backupId } = req.params

    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (!backupExists) {
      return res.status(404).json({ error: 'Backup file not found' })
    }

    const stats = await fs.stat(compressedPath)
    
    res.setHeader('Content-Type', 'application/gzip')
    res.setHeader('Content-Disposition', 'attachment; filename="' + backupId + '.tar.gz"')
    res.setHeader('Content-Length', stats.size)

    const fileStream = require('fs').createReadStream(compressedPath)
    fileStream.pipe(res)
  } catch (error) {
    log.error('Download backup error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  createFileBackup,
  restoreFileBackup,
  listFileBackups,
  deleteFileBackup,
  getBackupDetails,
  downloadBackup
}
