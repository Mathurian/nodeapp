const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const { generateSecurePassword, encryptMetadata, decryptMetadata, verifyFileIntegrity, secureDeleteFile } = require('../middleware/fileEncryption')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// File Management Interface Functions

// Get files with advanced search and filtering
const getFilesWithFilters = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { 
      search = '', 
      category = '', 
      uploadedBy = '', 
      dateFrom = '', 
      dateTo = '', 
      sizeMin = '', 
      sizeMax = '', 
      mimeType = '', 
      isPublic = '', 
      sortBy = 'uploadedAt', 
      sortOrder = 'desc', 
      page = 1, 
      limit = 20 
    } = req.query

    // Build where clause
    const where = {}
    
    if (search) {
      where.OR = [
        { filename: { contains: search, mode: 'insensitive' } },
        { originalName: { contains: search, mode: 'insensitive' } },
        { metadata: { contains: search, mode: 'insensitive' } }
      ]
    }
    
    if (category) {
      where.category = category
    }
    
    if (uploadedBy) {
      where.uploadedBy = uploadedBy
    }
    
    if (dateFrom || dateTo) {
      where.uploadedAt = {}
      if (dateFrom) where.uploadedAt.gte = new Date(dateFrom)
      if (dateTo) where.uploadedAt.lte = new Date(dateTo)
    }
    
    if (sizeMin || sizeMax) {
      where.size = {}
      if (sizeMin) where.size.gte = parseInt(sizeMin)
      if (sizeMax) where.size.lte = parseInt(sizeMax)
    }
    
    if (mimeType) {
      where.mimeType = { contains: mimeType, mode: 'insensitive' }
    }
    
    if (isPublic !== '') {
      where.isPublic = isPublic === 'true'
    }

    // Build orderBy clause
    const orderBy = {}
    orderBy[sortBy] = sortOrder

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit)

    // Get files with pagination
    const [files, totalCount] = await Promise.all([
      prisma.file.findMany({
        where,
        orderBy,
        skip,
        take: parseInt(limit),
        include: {
          user: {
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true
            }
          }
        }
      }),
      prisma.file.count({ where })
    ])

    // Get file statistics
    const stats = await prisma.file.aggregate({
      where,
      _count: { id: true },
      _sum: { size: true },
      _avg: { size: true }
    })

    // Get category distribution
    const categoryStats = await prisma.file.groupBy({
      by: ['category'],
      where,
      _count: { id: true },
      _sum: { size: true }
    })

    // Get uploader distribution
    const uploaderStats = await prisma.file.groupBy({
      by: ['uploadedBy'],
      where,
      _count: { id: true },
      _sum: { size: true }
    })

    res.json({
      files,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        totalCount,
        totalPages: Math.ceil(totalCount / parseInt(limit)),
        hasNext: skip + parseInt(limit) < totalCount,
        hasPrev: parseInt(page) > 1
      },
      stats: {
        totalFiles: stats._count.id,
        totalSize: stats._sum.size,
        averageSize: stats._avg.size,
        categoryDistribution: categoryStats,
        uploaderDistribution: uploaderStats
      }
    })
  } catch (error) {
    log.error('Get files with filters error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Bulk file operations
const bulkFileOperations = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { operation, fileIds, data } = req.body

    if (!operation || !fileIds || !Array.isArray(fileIds)) {
      return res.status(400).json({ error: 'Invalid operation parameters' })
    }

    let result = {}

    switch (operation) {
      case 'delete':
        result = await bulkDeleteFiles(fileIds)
        break
      case 'updateCategory':
        result = await bulkUpdateCategory(fileIds, data.category)
        break
      case 'updatePublicStatus':
        result = await bulkUpdatePublicStatus(fileIds, data.isPublic)
        break
      case 'download':
        result = await bulkDownloadFiles(fileIds)
        break
      case 'move':
        result = await bulkMoveFiles(fileIds, data.destination)
        break
      default:
        return res.status(400).json({ error: 'Invalid operation' })
    }

    res.json({
      operation,
      result,
      message: `Bulk ${operation} completed successfully`
    })
  } catch (error) {
    log.error('Bulk file operations error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File search suggestions
const getFileSearchSuggestions = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { query = '', limit = 10 } = req.query

    if (!query || query.length < 2) {
      return res.json({ suggestions: [] })
    }

    const suggestions = await prisma.file.findMany({
      where: {
        OR: [
          { filename: { contains: query, mode: 'insensitive' } },
          { originalName: { contains: query, mode: 'insensitive' } }
        ]
      },
      select: {
        id: true,
        filename: true,
        originalName: true,
        category: true,
        mimeType: true
      },
      take: parseInt(limit),
      orderBy: { uploadedAt: 'desc' }
    })

    res.json({ suggestions })
  } catch (error) {
    log.error('Get file search suggestions error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File analytics and insights
const getFileAnalytics = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { period = '30d' } = req.query

    // Calculate date range
    const now = new Date()
    const periodDays = period === '7d' ? 7 : period === '30d' ? 30 : period === '90d' ? 90 : 365
    const startDate = new Date(now.getTime() - (periodDays * 24 * 60 * 60 * 1000))

    // File upload trends
    const uploadTrends = await prisma.file.groupBy({
      by: ['uploadedAt'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { uploadedAt: 'asc' }
    })

    // Category distribution
    const categoryDistribution = await prisma.file.groupBy({
      by: ['category'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true }
    })

    // Top uploaders
    const topUploaders = await prisma.file.groupBy({
      by: ['uploadedBy'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    })

    // File type distribution
    const fileTypeDistribution = await prisma.file.groupBy({
      by: ['mimeType'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    })

    // Storage usage over time
    const storageUsage = await prisma.file.aggregate({
      where: {
        uploadedAt: { gte: startDate }
      },
      _sum: { size: true },
      _count: { id: true }
    })

    res.json({
      period,
      uploadTrends,
      categoryDistribution,
      topUploaders,
      fileTypeDistribution,
      storageUsage,
      generatedAt: new Date().toISOString()
    })
  } catch (error) {
    log.error('Get file analytics error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File integrity check
const checkFileIntegrity = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { fileId } = req.params

    const file = await prisma.file.findUnique({
      where: { id: fileId }
    })

    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }

    // Check if file exists on disk
    const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
    
    if (!fileExists) {
      return res.json({
        fileId,
        integrity: 'MISSING',
        message: 'File not found on disk',
        checksum: file.checksum,
        fileSize: file.size
      })
    }

    // Verify file integrity if checksum exists
    let integrityCheck = null
    if (file.checksum) {
      const isValid = await verifyFileIntegrity(file.path, file.checksum)
      integrityCheck = {
        checksum: file.checksum,
        isValid,
        status: isValid ? 'VALID' : 'INVALID'
      }
    }

    // Get actual file size
    const stats = await fs.stat(file.path)
    const actualSize = stats.size

    res.json({
      fileId,
      integrity: integrityCheck ? integrityCheck.status : 'UNKNOWN',
      fileExists: true,
      expectedSize: file.size,
      actualSize,
      sizeMatch: file.size === actualSize,
      checksum: integrityCheck,
      lastModified: stats.mtime,
      message: 'File integrity check completed'
    })
  } catch (error) {
    log.error('Check file integrity error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Bulk file integrity check
const bulkCheckFileIntegrity = async (req, res) => {
  const log = createRequestLogger(req, 'filemanagement')
  try {
    const { fileIds } = req.body

    if (!fileIds || !Array.isArray(fileIds)) {
      return res.status(400).json({ error: 'Invalid file IDs' })
    }

    const results = []
    
    for (const fileId of fileIds) {
      try {
        const file = await prisma.file.findUnique({
          where: { id: fileId }
        })

        if (!file) {
          results.push({ fileId, status: 'NOT_FOUND', error: 'File not found in database' })
          continue
        }

        const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
        
        if (!fileExists) {
          results.push({ fileId, status: 'MISSING', error: 'File not found on disk' })
          continue
        }

        let integrityCheck = null
        if (file.checksum) {
          const isValid = await verifyFileIntegrity(file.path, file.checksum)
          integrityCheck = {
            checksum: file.checksum,
            isValid,
            status: isValid ? 'VALID' : 'INVALID'
          }
        }

        const stats = await fs.stat(file.path)
        const actualSize = stats.size

        results.push({
          fileId,
          status: 'OK',
          integrity: integrityCheck ? integrityCheck.status : 'UNKNOWN',
          expectedSize: file.size,
          actualSize,
          sizeMatch: file.size === actualSize,
          checksum: integrityCheck
        })
      } catch (error) {
        results.push({ fileId, status: 'ERROR', error: error.message })
      }
    }

    res.json({
      results,
      totalChecked: fileIds.length,
      completedAt: new Date().toISOString()
    })
  } catch (error) {
    log.error('Bulk check file integrity error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper functions for bulk operations
const bulkDeleteFiles = async (fileIds) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      // Securely delete file from disk
      await secureDeleteFile(file.path)

      // Remove from database
      await prisma.file.delete({
        where: { id: fileId }
      })

      results.push({ fileId, status: 'DELETED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkUpdateCategory = async (fileIds, category) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      await prisma.file.update({
        where: { id: fileId },
        data: { category }
      })
      results.push({ fileId, status: 'UPDATED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkUpdatePublicStatus = async (fileIds, isPublic) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      await prisma.file.update({
        where: { id: fileId },
        data: { isPublic }
      })
      results.push({ fileId, status: 'UPDATED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkDownloadFiles = async (fileIds) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
      
      if (!fileExists) {
        results.push({ fileId, status: 'MISSING' })
        continue
      }

      results.push({ 
        fileId, 
        status: 'READY', 
        filename: file.filename,
        size: file.size,
        mimeType: file.mimeType
      })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkMoveFiles = async (fileIds, destination) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
      
      if (!fileExists) {
        results.push({ fileId, status: 'MISSING' })
        continue
      }

      // Create destination directory if it doesn't exist
      await fs.mkdir(destination, { recursive: true })

      // Move file
      const newPath = path.join(destination, file.filename)
      await fs.rename(file.path, newPath)

      // Update database
      await prisma.file.update({
        where: { id: fileId },
        data: { path: newPath }
      })

      results.push({ fileId, status: 'MOVED', newPath })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

module.exports = {
  getFilesWithFilters,
  bulkFileOperations,
  getFileSearchSuggestions,
  getFileAnalytics,
  checkFileIntegrity,
  bulkCheckFileIntegrity
}
