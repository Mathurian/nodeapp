const { PrismaClient } = require('@prisma/client')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

const getAllAssignments = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { status, judgeId, categoryId, contestId, eventId } = req.query
    const userId = req.user?.id
    const userRole = req.user?.role
    
    log.debug('Fetching assignments', { status, judgeId, categoryId, contestId, eventId, userId, userRole })
    
    const assignments = await prisma.assignment.findMany({
      where: {
        ...(status && { status }),
        ...(judgeId && { judgeId }),
        ...(categoryId && { categoryId }),
        ...(contestId && { contestId }),
        ...(eventId && { eventId }),
      },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            email: true,
            bio: true,
            isHeadJudge: true,
          }
        },
        assignedByUser: {
          select: {
            id: true,
            name: true,
            email: true,
            role: true,
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            scoreCap: true,
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
          }
        },
        event: {
          select: {
            id: true,
            name: true,
            startDate: true,
            endDate: true,
          }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { assignedAt: 'desc' }
      ]
    })
    
    log.info('Assignments fetched successfully', { count: assignments.length, userId })
    res.json(assignments)
  } catch (error) {
    log.error('Get assignments error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createAssignment = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { judgeId, categoryId, contestId, eventId, notes, priority } = req.body
    const userId = req.user.id
    const userRole = req.user.role
    
    log.info('Create assignment requested', { judgeId, categoryId, contestId, eventId, notes, priority, userId, userRole })
    
    // Must have judgeId and either categoryId OR contestId
    if (!judgeId) {
      log.warn('Create assignment failed: judgeId missing', { userId })
      return res.status(400).json({ error: 'judgeId is required' })
    }
    
    if (!categoryId && !contestId) {
      log.warn('Create assignment failed: categoryId or contestId missing', { judgeId, userId })
      return res.status(400).json({ error: 'Either categoryId or contestId is required' })
    }
    
    let finalContestId = contestId
    let finalEventId = eventId
    
    // If categoryId provided, fetch to get contestId and eventId
    if (categoryId) {
      const category = await prisma.category.findUnique({
        where: { id: categoryId },
        include: {
          contest: {
            include: {
              event: true
            }
          }
        }
      })
      
      if (!category) {
        log.warn('Create assignment failed: category not found', { categoryId, userId })
        return res.status(404).json({ error: 'Category not found' })
      }
      
      finalContestId = category.contestId
      finalEventId = category.contest.eventId
    } else {
      // If contestId provided without categoryId, fetch contest to get eventId
      if (contestId && !eventId) {
        const contest = await prisma.contest.findUnique({
          where: { id: contestId },
          include: { event: true }
        })
        
        if (!contest) {
          log.warn('Create assignment failed: contest not found', { contestId, userId })
          return res.status(404).json({ error: 'Contest not found' })
        }
        
        finalEventId = contest.eventId
      }
    }
    
    // Validate assignment doesn't already exist
    // If categoryId provided, check unique constraint
    if (categoryId) {
      const existingAssignment = await prisma.assignment.findUnique({
        where: { judgeId_categoryId: { judgeId, categoryId } }
      })
      
      if (existingAssignment) {
        log.warn('Create assignment failed: assignment already exists', { judgeId, categoryId, userId })
        return res.status(400).json({ error: 'Assignment already exists for this category' })
      }
    } else {
      // If contest-level assignment, check existing assignments
      const existingAssignments = await prisma.assignment.findMany({
        where: { 
          judgeId,
          contestId: finalContestId
        }
      })

      // If judge already has a contest-level assignment, return error
      const contestLevelAssignment = existingAssignments.find(a => a.categoryId === null)
      if (contestLevelAssignment) {
        log.warn('Create assignment failed: contest-level assignment already exists', { judgeId, contestId: finalContestId, userId })
        return res.status(400).json({ 
          error: 'Judge already has a contest-level assignment for this contest.' 
        })
      }

      // If judge has category-level assignments, upgrade to contest-level
      if (existingAssignments.length > 0) {
        log.debug('Upgrading partial assignments to contest-level', { judgeId, contestId: finalContestId, existingCount: existingAssignments.length })
        // Get all categories in this contest
        const allCategories = await prisma.category.findMany({
          where: { contestId: finalContestId }
        })

        const categoryIdsWithAssignments = new Set(existingAssignments.map(a => a.categoryId))

        // Create assignments for missing categories
        const categoriesToAdd = allCategories.filter(cat => 
          cat.id !== null && !categoryIdsWithAssignments.has(cat.id)
        )

        for (const category of categoriesToAdd) {
          await prisma.assignment.create({
            data: {
              judgeId,
              categoryId: category.id,
              contestId: finalContestId,
              eventId: finalEventId,
              assignedBy: req.user.id,
              notes: 'Upgraded from partial to full contest assignment',
              priority: priority || 1,
              status: 'ACTIVE'
            }
          })
        }

        log.info('Judge upgraded to contest-level assignment', { judgeId, contestId: finalContestId, addedAssignments: categoriesToAdd.length, userId })
        // Return success - already added missing assignments
        return res.status(200).json({ 
          message: 'Judge upgraded to contest-level assignment. Added missing category assignments.',
          addedAssignments: categoriesToAdd.length
        })
      }

      // If no existing assignments, proceed with creating contest-level assignment
      // (categoryId will be null for contest-level)
    }
    
    log.debug('Creating new assignment', { judgeId, categoryId, contestId: finalContestId, eventId: finalEventId })
    
    const assignment = await prisma.assignment.create({
      data: {
        judgeId,
        ...(categoryId && { categoryId }),
        contestId: finalContestId,
        eventId: finalEventId,
        assignedBy: req.user.id,
        notes,
        priority: priority || 1,
        status: 'PENDING'
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })

    // Create category_judges entry (required for certification workflow)
    if (categoryId) {
      // Verify judge exists (judgeId now directly references Judge.id)
      const judge = await prisma.judge.findUnique({
        where: { id: judgeId }
      })

      if (judge) {
        try {
          await prisma.categoryJudge.upsert({
            where: {
              categoryId_judgeId: {
                categoryId: categoryId,
                judgeId: judge.id
              }
            },
            create: {
              categoryId: categoryId,
              judgeId: judge.id
            },
            update: {}
          })
        } catch (error) {
          // Ignore duplicate entry errors
          if (error.code !== 'P2002') {
            log.error('Error creating CategoryJudge entry for category assignment', {
              error: error.message,
              stack: error.stack,
              categoryId,
              judgeId
            })
          }
        }
      }
    }
    
    // If this is a contest-level assignment (no categoryId), propagate to all categories
    if (!categoryId) {
      log.debug('Propagating contest-level assignment to all categories', { judgeId, contestId: finalContestId })
      // Get all categories in this contest
      const categories = await prisma.category.findMany({
        where: { contestId: finalContestId }
      })
      
      // Verify judge exists (judgeId now directly references Judge.id)
      const judge = await prisma.judge.findUnique({
        where: { id: judgeId }
      })
      
      if (judge) {
        // Create CategoryJudge entries for all categories
        for (const category of categories) {
          try {
            await prisma.categoryJudge.upsert({
              where: {
                categoryId_judgeId: {
                  categoryId: category.id,
                  judgeId: judge.id
                }
              },
              create: {
                categoryId: category.id,
                judgeId: judge.id
              },
              update: {}
            })
          } catch (error) {
            // Ignore duplicate entry errors
            if (error.code !== 'P2002') {
              log.error('Error creating CategoryJudge entry', {
                error: error.message,
                stack: error.stack,
                categoryId: category.id,
                judgeId
              })
            }
          }
        }
      }
    }
    
    log.info('Assignment created successfully', { assignmentId: assignment.id, judgeId, categoryId, contestId: finalContestId, userId })
    res.status(201).json(assignment)
  } catch (error) {
    log.error('Create assignment error', {
      error: error.message,
      stack: error.stack,
      judgeId: req.body?.judgeId,
      categoryId: req.body?.categoryId,
      contestId: req.body?.contestId
    })
    
    // If it's a known error (400), return the error message
    if (error.message && error.message.includes('already')) {
      return res.status(400).json({ error: error.message })
    }
    
    res.status(500).json({ error: 'Internal server error', details: error.message })
  }
}

const updateAssignment = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { id } = req.params
    const { status, notes, priority } = req.body
    const userId = req.user?.id
    const userRole = req.user?.role
    
    log.info('Update assignment requested', { assignmentId: id, status, notes, priority, userId, userRole })
    
    const assignment = await prisma.assignment.update({
      where: { id },
      data: {
        ...(status && { status }),
        ...(notes !== undefined && { notes }),
        ...(priority !== undefined && { priority }),
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })
    
    log.info('Assignment updated successfully', { assignmentId: id, userId })
    res.json(assignment)
  } catch (error) {
    log.error('Update assignment error', {
      error: error.message,
      stack: error.stack,
      assignmentId: req.params.id
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteAssignment = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { id } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role
    
    log.info('Delete assignment requested', { assignmentId: id, userId, userRole })
    
    await prisma.assignment.delete({
      where: { id }
    })
    
    log.info('Assignment deleted successfully', { assignmentId: id, userId })
    res.json({ message: 'Assignment deleted successfully' })
  } catch (error) {
    log.error('Delete assignment error', {
      error: error.message,
      stack: error.stack,
      assignmentId: req.params.id
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getJudgeAssignments = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { judgeId } = req.params
    const userId = req.user?.id
    
    log.debug('Fetching judge assignments', { judgeId, userId })
    
    const assignments = await prisma.assignment.findMany({
      where: { judgeId },
      include: {
        category: {
          include: {
            criteria: true,
            contestants: true
          }
        },
        contest: true,
        event: true
      },
      orderBy: [
        { priority: 'desc' },
        { assignedAt: 'desc' }
      ]
    })
    
    log.info('Judge assignments fetched successfully', { judgeId, count: assignments.length, userId })
    res.json(assignments)
  } catch (error) {
    log.error('Get judge assignments error', {
      error: error.message,
      stack: error.stack,
      judgeId: req.params.judgeId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getJudges = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const userId = req.user?.id
    
    log.debug('Fetching judges', { userId })
    
    const judges = await prisma.judge.findMany({
      select: {
        id: true,
        name: true,
        email: true,
        bio: true,
        isHeadJudge: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: { name: 'asc' }
    })

    log.info('Judges fetched successfully', { count: judges.length, userId })
    res.json(judges)
  } catch (error) {
    log.error('Get judges error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { contestId, eventId } = req.query
    const userId = req.user?.id
    
    log.debug('Fetching categories', { contestId, eventId, userId })
    
    const categories = await prisma.category.findMany({
      where: {
        ...(contestId && { contestId }),
        ...(eventId && { 
          contest: {
            eventId
          }
        })
      },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        criteria: true,
        contestants: true,
        judges: true
      }
    })

    log.info('Categories fetched successfully', { count: categories.length, contestId, eventId, userId })
    res.json(categories)
  } catch (error) {
    log.error('Get categories error', {
      error: error.message,
      stack: error.stack,
      contestId: req.query?.contestId,
      eventId: req.query?.eventId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const assignJudge = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { judgeId, categoryId, contestId, eventId, notes, priority } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    log.info('Assign judge requested', { judgeId, categoryId, contestId, eventId, notes, priority, userId, userRole })

    const assignment = await prisma.assignment.create({
      data: {
        judgeId,
        categoryId,
        contestId,
        eventId,
        assignedBy: req.user.id,
        notes,
        priority: priority || 1,
        status: 'PENDING'
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })

    log.info('Judge assigned successfully', { assignmentId: assignment.id, judgeId, categoryId, contestId, userId })
    res.status(201).json(assignment)
  } catch (error) {
    log.error('Assign judge error', {
      error: error.message,
      stack: error.stack,
      judgeId: req.body?.judgeId,
      categoryId: req.body?.categoryId,
      contestId: req.body?.contestId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const removeAssignment = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { assignmentId } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.info('Remove assignment requested', { assignmentId, userId, userRole })

    await prisma.assignment.delete({
      where: { id: assignmentId }
    })

    log.info('Assignment removed successfully', { assignmentId, userId })
    res.status(204).send()
  } catch (error) {
    log.error('Remove assignment error', {
      error: error.message,
      stack: error.stack,
      assignmentId: req.params.assignmentId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Contestant assignment functions
const getContestants = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const userId = req.user?.id
    
    log.debug('Fetching contestants', { userId })
    
    // Get all contestants
    const contestants = await prisma.contestant.findMany({
      select: {
        id: true,
        name: true,
        email: true,
        contestantNumber: true,
        bio: true,
        imagePath: true,
      },
      orderBy: { name: 'asc' }
    })

    log.info('Contestants fetched successfully', { count: contestants.length, userId })
    res.json(contestants)
  } catch (error) {
    log.error('Get contestants error', {
      error: error.message,
      stack: error.stack
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const assignContestantToCategory = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { categoryId, contestId, contestantId } = req.body
    const userId = req.user.id
    const userRole = req.user.role
    
    log.info('Assign contestant to category requested', { categoryId, contestId, contestantId, userId, userRole })
    
    if (!contestantId) {
      log.warn('Assign contestant failed: contestantId missing', { userId })
      return res.status(400).json({ error: 'contestantId is required' })
    }
    
    if (!categoryId && !contestId) {
      log.warn('Assign contestant failed: categoryId or contestId missing', { contestantId, userId })
      return res.status(400).json({ error: 'Either categoryId or contestId is required' })
    }
    
    let finalCategoryId = categoryId
    
    // If contestId provided without categoryId, get all categories in the contest
    if (contestId && !categoryId) {
      const categories = await prisma.category.findMany({
        where: { contestId }
      })
      
      if (categories.length === 0) {
        log.warn('Assign contestant failed: no categories found in contest', { contestId, contestantId, userId })
        return res.status(404).json({ error: 'No categories found in this contest' })
      }
      
      // Assign contestant to all categories in the contest
      const assignments = []
      for (const cat of categories) {
        const existing = await prisma.categoryContestant.findUnique({
          where: {
            categoryId_contestantId: {
              categoryId: cat.id,
              contestantId
            }
          }
        })
        
        if (!existing) {
          const assignment = await prisma.categoryContestant.create({
            data: {
              categoryId: cat.id,
              contestantId
            },
            include: {
              contestant: true,
              category: true
            }
          })
          assignments.push(assignment)
        }
      }
      
      log.info('Contestant assigned to multiple categories', { contestantId, contestId, assignmentCount: assignments.length, userId })
      return res.status(201).json({ message: `Assigned contestant to ${assignments.length} categories`, assignments })
    }
    
    // Check if assignment already exists
    const existing = await prisma.categoryContestant.findUnique({
      where: {
        categoryId_contestantId: {
          categoryId: finalCategoryId,
          contestantId
        }
      }
    })
    
    if (existing) {
      log.warn('Assign contestant failed: assignment already exists', { categoryId: finalCategoryId, contestantId, userId })
      return res.status(400).json({ error: 'Contestant already assigned to this category' })
    }
    
    // Create the assignment
    const assignment = await prisma.categoryContestant.create({
      data: {
        categoryId: finalCategoryId,
        contestantId
      },
      include: {
        contestant: true,
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })
    
    log.info('Contestant assigned to category successfully', { categoryId: finalCategoryId, contestantId, userId })
    res.status(201).json(assignment)
  } catch (error) {
    log.error('Assign contestant to category error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.body?.categoryId,
      contestId: req.body?.contestId,
      contestantId: req.body?.contestantId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const removeContestantFromCategory = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { categoryId, contestantId } = req.params
    const userId = req.user?.id
    const userRole = req.user?.role

    log.info('Remove contestant from category requested', { categoryId, contestantId, userId, userRole })

    await prisma.categoryContestant.delete({
      where: {
        categoryId_contestantId: {
          categoryId,
          contestantId
        }
      }
    })

    log.info('Contestant removed from category successfully', { categoryId, contestantId, userId })
    res.status(204).send()
  } catch (error) {
    log.error('Remove contestant from category error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId,
      contestantId: req.params.contestantId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAllContestantAssignments = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { categoryId, contestId } = req.query
    const userId = req.user?.id
    
    log.debug('Fetching all contestant assignments', { categoryId, contestId, userId })
    
    let where = {}
    if (categoryId) {
      where.categoryId = categoryId
    }
    if (contestId) {
      where.category = {
        contestId: contestId
      }
    }
    
    const assignments = await prisma.categoryContestant.findMany({
      where,
      include: {
        contestant: true,
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })
    
    log.info('Contestant assignments fetched successfully', { count: assignments.length, categoryId, contestId, userId })
    res.json(assignments)
  } catch (error) {
    log.error('Get all contestant assignments error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.query?.categoryId,
      contestId: req.query?.contestId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoryContestants = async (req, res) => {
  const log = createRequestLogger(req, 'assignments')
  try {
    const { categoryId } = req.params
    const userId = req.user?.id
    
    log.debug('Fetching category contestants', { categoryId, userId })
    
    const assignments = await prisma.categoryContestant.findMany({
      where: { categoryId },
      include: {
        contestant: {
          include: {
            users: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                pronouns: true,
                gender: true,
                imagePath: true,
                bio: true,
                contestantBio: true,
                phone: true,
                address: true
              }
            }
          }
        }
      }
    })
    
    // Map to return contestant data with user info included
    const contestants = assignments.map(a => ({
      id: a.contestant.id,
      name: a.contestant.name,
      email: a.contestant.email,
      contestantNumber: a.contestant.contestantNumber,
      bio: a.contestant.bio,
      imagePath: a.contestant.imagePath,
      createdAt: a.contestant.createdAt,
      updatedAt: a.contestant.updatedAt,
      user: a.contestant.users?.[0] || null,
      users: a.contestant.users || []
    }))
    
    log.info('Category contestants fetched successfully', { categoryId, count: contestants.length, userId })
    res.json(contestants)
  } catch (error) {
    log.error('Get category contestants error', {
      error: error.message,
      stack: error.stack,
      categoryId: req.params.categoryId
    })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllAssignments,
  createAssignment,
  updateAssignment,
  deleteAssignment,
  getJudgeAssignments,
  getJudges,
  getCategories,
  assignJudge,
  removeAssignment,
  getContestants,
  assignContestantToCategory,
  removeContestantFromCategory,
  getCategoryContestants,
  getAllContestantAssignments
}
