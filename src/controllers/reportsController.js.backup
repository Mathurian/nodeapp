const { PrismaClient } = require('@prisma/client')

const PDFDocument = require('pdfkit')
const ExcelJS = require("exceljs")
const createCsvWriter = require("csv-writer").createObjectCsvWriter
const fs = require('fs').promises
const path = require('path')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Helper function to calculate winners per contest with total possible scores
// Must be defined before generateReport uses it
const calculateContestWinners = async (contest) => {
  try {
    // Get all criteria for all categories to calculate total possible scores
    const allCriteria = await prisma.criterion.findMany({
      where: {
        categoryId: { in: contest.categories.map(c => c.id) }
      }
    })

    // Calculate total possible per category per judge (from criteria)
    const categoryMaxScoresFromCriteria = {}
    allCriteria.forEach(criterion => {
      if (!categoryMaxScoresFromCriteria[criterion.categoryId]) {
        categoryMaxScoresFromCriteria[criterion.categoryId] = 0
      }
      categoryMaxScoresFromCriteria[criterion.categoryId] += criterion.maxScore
    })
    
    // Build categoryMaxScores map: use criteria sum if available, otherwise use category scoreCap
    const categoryMaxScores = {}
    contest.categories.forEach(cat => {
      const criteriaSum = categoryMaxScoresFromCriteria[cat.id] || 0
      categoryMaxScores[cat.id] = criteriaSum > 0 ? criteriaSum : (cat.scoreCap || null)
    })

    // Aggregate scores across all categories in the contest
    const allScores = await prisma.score.findMany({
      where: {
        categoryId: { in: contest.categories.map(c => c.id) }
      },
      include: {
        contestant: true,
        judge: true,
        criterion: true,
        category: true
      }
    })

    // Group by contestant and sum scores across all categories
    const contestantTotals = {}
    allScores.forEach(score => {
      const contestantId = score.contestantId
      if (!contestantTotals[contestantId]) {
        contestantTotals[contestantId] = {
          contestant: score.contestant,
          totalScore: 0,
          totalPossibleScore: 0,
          categories: new Set(),
          categoryJudgePairs: new Set()
        }
      }
      if (score.score !== null) {
        contestantTotals[contestantId].totalScore += score.score
        // Track unique category-judge pairs for calculating possible score
        contestantTotals[contestantId].categoryJudgePairs.add(`${score.categoryId}-${score.judgeId}`)
      }
      contestantTotals[contestantId].categories.add(score.categoryId)
    })

    const winners = Object.values(contestantTotals).map(item => {
      // Calculate total possible: sum of max scores for each category-judge pair
      let totalPossible = 0
      let hasValidMaxScore = false
      item.categoryJudgePairs.forEach(pair => {
        const [categoryId] = pair.split('-')
        const categoryMax = categoryMaxScores[categoryId]
        if (categoryMax !== null && categoryMax !== undefined && categoryMax > 0) {
          totalPossible += categoryMax
          hasValidMaxScore = true
        }
      })
      const calculatedTotalPossible = hasValidMaxScore ? totalPossible : null
      return {
        contestant: item.contestant,
        totalScore: item.totalScore,
        totalPossibleScore: calculatedTotalPossible,
        categoriesParticipated: item.categories.size
      }
    }).sort((a, b) => b.totalScore - a.totalScore)

    return winners
  } catch (error) {
    console.error('Error calculating contest winners:', error)
    return []
  }
}

const getTemplates = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    // ReportTemplate model doesn't have a createdBy relation in the schema
    const templates = await prisma.reportTemplate.findMany({
      orderBy: { createdAt: 'desc' }
    })

    // Format templates - set createdBy to null since it doesn't exist in the schema
    const formattedTemplates = templates.map(template => ({
      ...template,
      createdBy: null
    }))

    res.json({ data: formattedTemplates })
  } catch (error) {
    log.error('Get report templates error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { name, template, parameters, type } = req.body

    const reportTemplate = await prisma.reportTemplate.create({
      data: {
        name,
        template: template || '{}',
        parameters: parameters || '{}',
        type: type || 'event'
      }
    })

    res.status(201).json(reportTemplate)
  } catch (error) {
    log.error('Create report template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params
    const { name, description, template, parameters } = req.body

    const reportTemplate = await prisma.reportTemplate.update({
      where: { id },
      data: {
        name,
        description,
        template,
        parameters
      }
    })

    res.json(reportTemplate)
  } catch (error) {
    log.error('Update report template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteTemplate = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    await prisma.reportTemplate.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    log.error('Delete report template error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  // Capture request variables for error logging
  let reportType, eventId, contestId, categoryId, format, templateId
  
  try {
    const bodyParams = req.body || {}
    templateId = bodyParams.templateId
    reportType = bodyParams.reportType
    // Extract eventId from bodyParams directly OR from nested parameters object
    eventId = bodyParams.eventId || bodyParams.parameters?.eventId
    contestId = bodyParams.contestId || bodyParams.parameters?.contestId
    categoryId = bodyParams.categoryId || bodyParams.parameters?.categoryId
    format = bodyParams.format
    const { parameters, includeDetails, dateRange } = bodyParams

    log.info('üîµ Generating report:', { 
      reportType, 
      eventId, 
      contestId, 
      categoryId,
      format,
      eventIdType: typeof eventId,
      eventIdValue: String(eventId || ''),
      bodyParamsKeys: Object.keys(bodyParams || {}),
      hasParameters: !!bodyParams?.parameters,
      parametersKeys: bodyParams?.parameters ? Object.keys(bodyParams.parameters) : [],
      hasBodyEventId: !!bodyParams.eventId,
      hasParamsEventId: !!bodyParams.parameters?.eventId
    })

    // Get app name from system settings
    const appNameSetting = await prisma.systemSetting.findFirst({
      where: { key: 'app_name' }
    })
    const appName = appNameSetting?.value || 'Event Manager'

    // Validate user is authenticated
    if (!req.user || !req.user.id) {
      log.error('Unauthorized: User not authenticated')
      return res.status(401).json({ error: 'Unauthorized', message: 'User must be authenticated to generate reports' })
    }

    // Route to specialized handlers for specific report types
    // These need to save to ReportInstance for consistency, so we'll handle them inline
    // Note: These report types will be handled inline below before the normal data fetching

    // Collect report data based on type
    let reportData = {
      reportType: reportType || 'general',
      appName: appName,
      generatedAt: new Date(),
      generatedBy: req.user.id,
    }

    // Handle JUDGE_PERFORMANCE report type
    if (reportType === 'JUDGE_PERFORMANCE') {
      const eventIdFilter = bodyParams.eventId || parameters?.eventId || eventId
      const judgeId = bodyParams.judgeId || parameters?.judgeId || req.body.judgeId
      const fetchJudgesOnly = bodyParams.fetchJudgesOnly || parameters?.fetchJudgesOnly || req.query?.fetchJudgesOnly === 'true' || req.query?.fetchJudgesOnly === true
      
      log.info('üîµ JUDGE_PERFORMANCE report:', {
        eventIdFilter: eventIdFilter,
        judgeId: judgeId,
        hasBodyEventId: !!bodyParams.eventId,
        hasParamsEventId: !!parameters?.eventId,
        hasBodyJudgeId: !!bodyParams.judgeId,
        hasParamsJudgeId: !!parameters?.judgeId,
        bodyParamsKeys: Object.keys(bodyParams || {})
      })
      
      // Event is required - judges are pulled from the event
      if (!eventIdFilter) {
        log.warn('JUDGE_PERFORMANCE report missing eventId', {
          bodyParamsKeys: Object.keys(bodyParams || {}),
          hasParameters: !!parameters,
          parametersKeys: parameters ? Object.keys(parameters) : []
        })
        return res.status(400).json({ error: 'eventId is required for JUDGE_PERFORMANCE reports. Judges will be pulled from the selected event.' })
      }
      
      try {
        // First, get all judges assigned to the event
        // Note: Contest has `judges` relation (which is ContestJudge[]), not `contestJudges`
        const event = await prisma.event.findUnique({
          where: { id: String(eventIdFilter).trim() },
          include: {
            contests: {
              include: {
                judges: {
                  include: {
                    judge: {
                      select: {
                        id: true,
                        name: true,
                        email: true
                      }
                    }
                  }
                },
                categories: {
                  include: {
                    judges: {
                      include: {
                        judge: {
                          select: {
                            id: true,
                            name: true,
                            email: true
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        })
        
        if (!event) {
          return res.status(404).json({ error: 'Event not found' })
        }
        
        // Collect all unique Judge IDs from the event
        // Note: Contest.judges is the relation name, not contestJudges
        const judgeIds = new Set()
        if (event.contests) {
          event.contests.forEach(contest => {
            if (contest.judges) {
              contest.judges.forEach(cj => {
                if (cj.judge && cj.judge.id) {
                  judgeIds.add(cj.judge.id)
                }
              })
            }
            if (contest.categories) {
              contest.categories.forEach(category => {
                if (category.judges) {
                  category.judges.forEach(catj => {
                    if (catj.judge && catj.judge.id) {
                      judgeIds.add(catj.judge.id)
                    }
                  })
                }
              })
            }
          })
        }
        
        // Now fetch the User records associated with these judges
        const judgeIdsArray = Array.from(judgeIds)
        if (judgeIdsArray.length === 0) {
          return res.status(400).json({ 
            error: 'No judges found for this event.',
            availableJudges: []
          })
        }
        
        // Fetch users who are judges and associated with these judge records
        // Note: User.judgeId is the foreign key to Judge.id
        let judgeUsers = []
        try {
          judgeUsers = await prisma.user.findMany({
            where: {
              role: 'JUDGE',
              judgeId: { in: judgeIdsArray }
            },
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true,
              judgeId: true
            }
          })
        } catch (userQueryError) {
          log.error('Failed to fetch judge users:', userQueryError, {
            error: userQueryError.message,
            judgeIdsArray: judgeIdsArray,
            judgeIdsArrayLength: judgeIdsArray.length
          })
          // If this fails, try without the judgeId filter
          judgeUsers = await prisma.user.findMany({
            where: {
              role: 'JUDGE'
            },
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true,
              judgeId: true
            }
          })
          // Filter to only those with matching judgeIds
          judgeUsers = judgeUsers.filter(u => u.judgeId && judgeIdsArray.includes(u.judgeId))
        }
        
        // Map: userId -> { user: User, judgeId: Judge.id }
        const eventJudges = new Map()
        judgeUsers.forEach(user => {
          if (user.judgeId) {
            eventJudges.set(user.id, {
              user: user,
              judgeId: user.judgeId
            })
          }
        })
        
        const judgesArray = Array.from(eventJudges.values())
        
        // If judgeId is provided, filter to that specific judge
        // Otherwise, return available judges (but allow report generation to continue if it's just for fetching the list)
        // Check if this is a request just to get available judges (indicated by a special flag or no judgeId)
        if (!judgeId) {
          log.info('JUDGE_PERFORMANCE report missing judgeId - found judges in event', {
            eventId: eventIdFilter,
            judgesCount: judgesArray.length
          })
          // If this is a request specifically to get available judges (indicated by fetchJudgesOnly flag)
          // return 200 with the judges list
          if (fetchJudgesOnly) {
            return res.status(200).json({ 
              availableJudges: judgesArray.map(j => ({ 
                id: j.user.id, 
                name: j.user.preferredName || j.user.name, 
                email: j.user.email 
              }))
            })
          }
          // Otherwise, return 400 error asking for judge selection (for actual report generation)
          return res.status(400).json({ 
            error: 'Please select a specific judge from the event.',
            availableJudges: judgesArray.map(j => ({ 
              id: j.user.id, 
              name: j.user.preferredName || j.user.name, 
              email: j.user.email 
            }))
          })
        }
        
        // Verify the selected judge (User) is actually assigned to this event
        const selectedJudgeData = judgesArray.find(j => j.user.id === String(judgeId).trim())
        if (!selectedJudgeData) {
          return res.status(400).json({ error: 'The selected judge is not assigned to this event.' })
        }
        
        const selectedJudge = selectedJudgeData.user
        const actualJudgeId = selectedJudgeData.judgeId // This is the Judge.id for score queries
        
        // Get judge's scores for this event
        // Note: Score.judgeId references Judge.id, not User.id
        const scoresWhere = { 
          judgeId: actualJudgeId,
          category: { contest: { eventId: String(eventIdFilter).trim() } }
        }
        
        const scores = await prisma.score.findMany({
          where: scoresWhere,
          include: {
            category: {
              include: {
                contest: {
                  include: {
                    event: { select: { id: true, name: true } }
                  }
                },
                criteria: {
                  select: { id: true, name: true, maxScore: true }
                }
              }
            },
            contestant: {
              select: { id: true, name: true, contestantNumber: true }
            },
            criterion: {
              select: { id: true, name: true, maxScore: true }
            }
          },
          orderBy: [
            { categoryId: 'asc' },
            { contestantId: 'asc' },
            { createdAt: 'desc' }
          ]
        })
        
        // Organize scores by category and contestant
        const scoresByCategory = {}
        scores.forEach(score => {
          const catId = score.categoryId
          if (!scoresByCategory[catId]) {
            scoresByCategory[catId] = {
              category: score.category,
              contestants: {}
            }
          }
          
          const contestantId = score.contestantId
          if (!scoresByCategory[catId].contestants[contestantId]) {
            scoresByCategory[catId].contestants[contestantId] = {
              contestant: score.contestant,
              scores: [],
              totalScore: 0,
              totalPossibleScore: 0
            }
          }
          
          const entry = scoresByCategory[catId].contestants[contestantId]
          entry.scores.push(score)
          if (score.score !== null) {
            entry.totalScore += score.score
          }
          const maxScore = score.criterion?.maxScore || 0
          if (maxScore > 0) {
            entry.totalPossibleScore += maxScore
          }
        })
        
        // Convert to array format
        const organizedScores = Object.values(scoresByCategory).map(catData => ({
          category: catData.category,
          contestants: Object.values(catData.contestants).map(contestantData => ({
            contestant: contestantData.contestant,
            scores: contestantData.scores,
            totalScore: contestantData.totalScore,
            totalPossibleScore: contestantData.totalPossibleScore,
            scoreDisplay: contestantData.totalPossibleScore > 0 
              ? `${contestantData.totalScore} out of ${contestantData.totalPossibleScore}`
              : `${contestantData.totalScore} points`
          }))
        }))
        
        // Calculate statistics
        const judgeStats = {
          totalScores: scores.length,
          averageScore: scores.length > 0 ? scores.reduce((sum, s) => sum + s.score, 0) / scores.length : 0,
          maxScore: scores.length > 0 ? Math.max(...scores.map(s => s.score)) : 0,
          minScore: scores.length > 0 ? Math.min(...scores.map(s => s.score)) : 0,
          uniqueCategories: new Set(scores.map(s => s.categoryId)).size,
          uniqueContestants: new Set(scores.map(s => s.contestantId)).size
        }
        
        reportData.judge = selectedJudge
        reportData.statistics = judgeStats
        reportData.scores = scores // Keep raw scores for backwards compatibility
        reportData.organizedScores = organizedScores // New organized format
        reportData.title = `Judge Performance: ${selectedJudge.preferredName || selectedJudge.name}`
        reportData.reportType = 'JUDGE_PERFORMANCE'
        log.info('‚úÖ Fetched judge performance data:', {
          judgeName: selectedJudge.preferredName || selectedJudge.name,
          scoresCount: scores.length,
          statistics: judgeStats
        })
      } catch (fetchError) {
        // Log the full Prisma error details
        const errorMessage = fetchError.message || 'Unknown error'
        const errorMeta = fetchError.meta || {}
        const errorDetails = {
          error: errorMessage,
          errorName: fetchError.name,
          errorCode: fetchError.code,
          errorMeta: errorMeta,
          errorStack: fetchError.stack?.substring(0, 500),
          judgeId: judgeId,
          eventId: eventIdFilter,
          // Include the actual Prisma error message
          prismaMessage: errorMessage,
          prismaCode: errorMeta.code || null,
          prismaTarget: errorMeta.target || null
        }
        log.error('Failed to fetch judge performance data:', fetchError, errorDetails)
        
        // Log to console as well for debugging
        console.error('Judge Performance Error Details:', JSON.stringify(errorDetails, null, 2))
        
        // Return more detailed error message
        return res.status(500).json({ 
          error: 'Failed to fetch judge data',
          message: errorMessage,
          details: errorMeta,
          code: errorMeta.code || null
        })
      }
    }
    
    // Handle CONTESTANT_SCORES report type
    if (reportType === 'CONTESTANT_SCORES') {
      const contestantId = bodyParams.contestantId || parameters?.contestantId
      const contestIdFilter = bodyParams.contestId || parameters?.contestId
      const eventIdFilter = bodyParams.eventId || parameters?.eventId
      
      log.info('üîµ CONTESTANT_SCORES report:', {
        contestantId: contestantId,
        contestId: contestIdFilter,
        eventId: eventIdFilter
      })
      
      try {
        // Build where clause for scores
        const scoresWhere = {}
        
        if (contestantId) {
          scoresWhere.contestantId = String(contestantId).trim()
        }
        
        if (contestIdFilter) {
          scoresWhere.category = { contestId: String(contestIdFilter).trim() }
        } else if (eventIdFilter) {
          scoresWhere.category = { contest: { eventId: String(eventIdFilter).trim() } }
        }
        
        // Fetch scores with contestant, category, contest, and judge info
        const scores = await prisma.score.findMany({
          where: scoresWhere,
          include: {
            contestant: {
              select: { id: true, name: true, contestantNumber: true }
            },
            category: {
              include: {
                contest: {
                  include: {
                    event: { select: { id: true, name: true } }
                  }
                }
              }
            },
            judge: {
              select: { id: true, name: true }
            },
            criterion: {
              select: { id: true, name: true, maxScore: true }
            }
          },
          orderBy: [
            { contestantId: 'asc' },
            { createdAt: 'desc' }
          ]
        })
        
        // Group scores by contestant
        const contestantScores = {}
        scores.forEach(score => {
          const cId = score.contestantId
          if (!contestantScores[cId]) {
            contestantScores[cId] = {
              contestant: score.contestant,
              scores: [],
              totalScore: 0,
              totalPossibleScore: 0,
              categories: new Set()
            }
          }
          contestantScores[cId].scores.push(score)
          if (score.score !== null) {
            contestantScores[cId].totalScore += score.score
          }
          const maxScore = score.criterion?.maxScore || 0
          if (maxScore > 0) {
            contestantScores[cId].totalPossibleScore += maxScore
          }
          contestantScores[cId].categories.add(score.categoryId)
        })
        
        // Convert to array and format
        const contestants = Object.values(contestantScores).map((item) => ({
          contestant: item.contestant,
          totalScore: item.totalScore,
          totalPossibleScore: item.totalPossibleScore > 0 ? item.totalPossibleScore : null,
          scoresCount: item.scores.length,
          categoriesCount: item.categories.size,
          scores: item.scores.slice(0, 50) // Limit to first 50 scores per contestant
        }))
        
        reportData.contestants = contestants
        reportData.totalContestants = contestants.length
        reportData.totalScores = scores.length
        reportData.title = `Contestant Scores Report${contestIdFilter ? ` - Contest` : eventIdFilter ? ` - Event` : ''}`
        reportData.reportType = 'CONTESTANT_SCORES'
        log.info('‚úÖ Fetched contestant scores data:', {
          contestantsCount: contestants.length,
          totalScores: scores.length
        })
      } catch (fetchError) {
        log.error('Failed to fetch contestant scores data:', fetchError, { error: fetchError.message })
        return res.status(500).json({ error: 'Failed to fetch contestant scores' })
      }
    }
    
    // Handle SYSTEM_ANALYTICS report type
    if (reportType === 'SYSTEM_ANALYTICS') {
      const startDate = bodyParams.startDate || parameters?.startDate
      const endDate = bodyParams.endDate || parameters?.endDate
      
      try {
        const dateFilter = {}
        if (startDate) dateFilter.gte = new Date(startDate)
        if (endDate) dateFilter.lte = new Date(endDate)
        
        // Get system statistics
        const [
          totalUsers,
          totalEvents,
          totalContests,
          totalCategories,
          totalScores,
          totalFiles,
          userActivity
        ] = await Promise.all([
          prisma.user.count(),
          prisma.event.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
          prisma.contest.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
          prisma.category.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
          prisma.score.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
          prisma.file.count({ where: Object.keys(dateFilter).length > 0 ? { uploadedAt: dateFilter } : {} }),
          prisma.activityLog.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} })
        ])
        
        // Get user role distribution
        const userRoles = await prisma.user.groupBy({
          by: ['role'],
          _count: { role: true },
          where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {}
        })
        
        reportData.overview = {
          totalUsers,
          totalEvents,
          totalContests,
          totalCategories,
          totalScores,
          totalFiles,
          userActivity
        }
        reportData.distributions = {
          userRoles: userRoles.map(r => ({ role: r.role, count: r._count.role }))
        }
        reportData.dateRange = { startDate, endDate }
        reportData.title = `System Analytics${startDate || endDate ? ` (${startDate || 'All Time'} - ${endDate || 'Now'})` : ' (All Time)'}`
        reportData.reportType = 'SYSTEM_ANALYTICS'
        log.debug('‚úÖ Fetched system analytics data')
      } catch (fetchError) {
        log.error('Failed to fetch system analytics data:', fetchError, { error: fetchError.message })
        return res.status(500).json({ error: 'Failed to fetch system analytics' })
      }
    }

    // Fetch data based on provided IDs - priority: categoryId > contestId > eventId
    // This ensures we always fetch data when IDs are provided, regardless of reportType string
    // Skip if we already have data from specialized handlers (judge or overview)
    if (!reportData.judge && !reportData.overview && categoryId) {
      // Category-specific report (highest priority)
      try {
        const category = await prisma.category.findUnique({
          where: { id: categoryId },
          include: {
            contest: {
              include: {
                event: {
                  select: { id: true, name: true, startDate: true, endDate: true }
                }
              }
            },
            scores: {
              include: {
                judge: {
                  select: { name: true }
                },
                contestant: {
                  select: { name: true, contestantNumber: true }
                },
                criterion: {
                  select: { name: true, maxScore: true }
                }
              }
            }
          }
        })
        if (category) {
          reportData.category = category
          reportData.contest = category.contest
          reportData.event = category.contest?.event
          reportData.title = `Category Report: ${category.name}`
          reportData.reportType = 'CATEGORY'
          log.debug('‚úÖ Fetched category data:', category.name)
        } else {
          log.warn('Category not found:', categoryId)
        }
      } catch (fetchError) {
        log.error('Failed to fetch category data:', fetchError, { error: fetchError.message, categoryId })
      }
    }
    
    if (!reportData.category && contestId) {
      // Contest results report
      try {
      const contest = await prisma.contest.findUnique({
        where: { id: contestId },
        include: {
            event: {
              select: { id: true, name: true, startDate: true, endDate: true }
            },
          categories: {
            include: {
                scores: {
                  include: {
                    judge: {
                      select: { name: true }
                    },
                    contestant: {
                      select: { name: true, contestantNumber: true }
                    },
                    criterion: {
                      select: { name: true, maxScore: true }
                    }
                  }
                }
            }
          }
        }
      })
        if (contest) {
      reportData.contest = contest
          reportData.event = contest.event
          reportData.title = `Contest Results: ${contest.name}`
          reportData.reportType = reportType === 'EVENT_SUMMARY' ? 'EVENT_SUMMARY' : 'CONTEST_RESULTS'
          log.debug('‚úÖ Fetched contest data:', contest.name)
        } else {
          log.warn('Contest not found:', contestId)
        }
      } catch (fetchError) {
        log.error('Failed to fetch contest data:', fetchError, { error: fetchError.message, contestId })
      }
    }
    
    // Fetch event data if eventId is provided and we don't already have category/contest data
    // This handles EVENT_SUMMARY reports specifically
    if (!reportData.category && !reportData.contest && eventId) {
      // Event summary report
      try {
        // Ensure eventId is a valid string
        const eventIdStr = String(eventId).trim()
        if (!eventIdStr || eventIdStr === 'undefined' || eventIdStr === 'null') {
          log.warn('‚ö†Ô∏è Event ID is empty or invalid, skipping event fetch:', { 
            eventId, 
            eventIdType: typeof eventId,
            eventIdStr: eventIdStr,
            reportType
          })
        } else {
          log.info('üîç Fetching event with ID:', {
            eventIdStr: String(eventIdStr),
            eventIdType: typeof eventIdStr,
            eventIdLength: String(eventIdStr).length,
            hasCategory: !!reportData.category,
            hasContest: !!reportData.contest,
            reportType,
            eventIdSource: 'bodyParams'
          })
          
          let event = null
          // Ensure eventIdStr is a valid string for Prisma
          const validEventId = String(eventIdStr).trim()
          if (!validEventId || validEventId.length < 10) {
            log.error('‚ùå Invalid eventId for Prisma query:', {
              eventIdStr: eventIdStr,
              validEventId: validEventId,
              length: validEventId.length
            })
            throw new Error(`Invalid eventId: ${validEventId}`)
          }
          
          try {
            log.info('üîç Executing Prisma query with eventId:', { 
              eventId: validEventId,
              eventIdType: typeof validEventId,
              eventIdLength: validEventId.length
            })
            
            // First try a simple query to verify the event exists
            const eventExists = await prisma.event.findUnique({
              where: { id: validEventId },
              select: { id: true, name: true }
            })
            
            if (!eventExists) {
              log.error('‚ùå Event does not exist with ID:', validEventId)
              event = null
            } else {
              log.info('‚úÖ Event exists, fetching full details:', { eventId: eventExists.id, eventName: eventExists.name })
              
              // Now fetch with full includes
              event = await prisma.event.findUnique({
                where: { id: validEventId },
              include: {
                contests: {
                  include: {
                    categories: {
                      include: {
                        scores: {
                          include: {
                            judge: {
                              select: { name: true }
                            },
                            contestant: {
                              select: { name: true, contestantNumber: true }
                            },
                            criterion: {
                              select: { name: true, maxScore: true }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              })
              
              log.info('üîç Full Prisma query completed:', {
                eventFound: !!event,
                eventId: validEventId,
                eventName: event?.name || 'N/A',
                eventIdType: typeof validEventId,
                eventIdLength: validEventId.length,
                contestsCount: event?.contests?.length || 0
              })
            }
          } catch (prismaError) {
            log.error('‚ùå Prisma error fetching event:', {
              error: prismaError.message,
              errorName: prismaError.name,
              errorCode: prismaError.code,
              eventId: validEventId,
              eventIdType: typeof validEventId,
              eventIdLength: validEventId?.length || 0,
              originalEventIdStr: eventIdStr,
              originalEventIdType: typeof eventIdStr,
              stack: prismaError.stack
            })
            // Don't throw - allow the report to continue without event data
            // Instead, just set event to null and continue
            event = null
          }
          
          if (event) {
            log.info('‚úÖ Event found, assigning to reportData:', {
              eventId: event.id,
              eventName: event.name,
              contestsCount: event.contests?.length || 0
            })
            
            reportData.event = event
            reportData.title = `Event Summary: ${event.name}`
            reportData.reportType = 'EVENT_SUMMARY'
            
            // Calculate winners for each contest in the event
            if (event.contests && event.contests.length > 0) {
              try {
                log.debug('Calculating winners for contests...')
                const contestsWithWinners = await Promise.all(
                  event.contests.map(async (contest) => {
                    const winners = await calculateContestWinners(contest)
                    return {
                      ...contest,
                      winners: winners
                    }
                  })
                )
                reportData.event.contests = contestsWithWinners
                log.debug(`‚úÖ Calculated winners for ${contestsWithWinners.length} contests`)
              } catch (winnersError) {
                log.warn('Failed to calculate winners for event contests:', winnersError.message)
              }
            }
            
            log.info('‚úÖ Fetched event data successfully:', {
              eventName: reportData.event.name,
              eventId: reportData.event.id,
              contestsCount: reportData.event.contests?.length || 0,
              reportDataHasEvent: !!reportData.event,
              reportDataKeys: Object.keys(reportData),
              reportDataEventId: reportData.event?.id
            })
          } else {
            log.error('‚ö†Ô∏è Event not found in database:', {
              eventIdStr: String(eventIdStr),
              validEventId: validEventId,
              eventIdLength: validEventId.length,
              eventIdType: typeof validEventId,
              searchedId: validEventId
            })
          }
        }
      } catch (fetchError) {
        log.error('‚ùå Failed to fetch event data:', fetchError, { 
          error: fetchError.message, 
          eventId: eventId,
          eventIdType: typeof eventId,
          eventIdStr: String(eventId),
          stack: fetchError.stack
        })
      }
    } else if (eventId && !reportData.category && !reportData.contest) {
      log.debug('‚ö†Ô∏è Event ID provided but condition not met for fetching:', {
        eventId,
        hasCategory: !!reportData.category,
        hasContest: !!reportData.contest,
        reportType
      })
    }

    // Set default title if none set
    if (!reportData.title) {
      reportData.title = `${reportType || 'General'} Report`
    }
    
    // Ensure reportType is set in reportData for PDF/Excel/CSV generation
    if (!reportData.reportType) {
      reportData.reportType = reportType || 'general'
    }
    
    // Debug logging to verify data was fetched
    log.debug('üìä Report data summary:', {
      reportType: reportData.reportType,
      hasEvent: !!reportData.event,
      hasContest: !!reportData.contest,
      hasCategory: !!reportData.category,
      eventName: reportData.event?.name,
      contestName: reportData.contest?.name,
      categoryName: reportData.category?.name,
      title: reportData.title
    })

    // Attempt to save report to history (non-blocking - report will still be generated)
    // If this fails, we'll still generate the report successfully
    let reportInstance = null
    try {
      // Ensure default template exists - wrap in try-catch to handle if it already exists
      let defaultTemplate
      try {
        // First try to find if template exists
        defaultTemplate = await prisma.reportTemplate.findUnique({
          where: { id: 'default' }
        })
        
        // If not found, create it
        if (!defaultTemplate) {
          try {
            defaultTemplate = await prisma.reportTemplate.create({
              data: {
          id: 'default',
          name: 'Default Report Template',
          type: 'general',
          template: '{}',
          parameters: '{}'
        }
      })
          } catch (createError) {
            log.warn('Could not create default template:', createError.message)
            defaultTemplate = null
          }
        }
      } catch (templateError) {
        log.warn('Error accessing templates table:', templateError.message)
        defaultTemplate = null
      }

      // Ensure all required fields are present and valid
      const reportName = String(`${reportType || 'General'} Report - ${new Date().toLocaleDateString()}`).substring(0, 255) // Ensure name fits in database
      const reportTypeValue = String(reportType || 'general').substring(0, 100) // Ensure type fits
      const reportFormat = String(format || 'json').substring(0, 50) // Ensure format fits
      const reportTemplateId = String(templateId || 'default').substring(0, 100) // Ensure templateId fits
      
      // Validate required fields - if any fail, skip history saving but continue report generation
      if (!req.user || !req.user.id) {
        log.warn('User ID validation failed in history save section - skipping history save')
        reportInstance = null
        // Exit early - continue with report generation
      } else if (!reportName || reportName.trim() === '') {
        log.warn('Report name is empty - skipping history save')
        reportInstance = null
        // Exit early - continue with report generation
      } else if (!reportTypeValue || reportTypeValue.trim() === '') {
        log.warn('Report type is empty - skipping history save')
        reportInstance = null
        // Exit early - continue with report generation
      } else if (!reportFormat || reportFormat.trim() === '') {
        log.warn('Report format is empty - skipping history save')
        reportInstance = null
        // Exit early - continue with report generation
      } else {
        // All validations passed, continue with history saving
      
      // Safely stringify reportData, handling circular references and large objects
      // We want to save the FULL report data, not just metadata
      let reportDataString = '{}'
      try {
        // Debug: Log what we're about to stringify
        log.info('üì¶ Preparing to stringify reportData:', {
          reportType: reportData.reportType,
          hasEvent: !!reportData.event,
          hasContest: !!reportData.contest,
          hasCategory: !!reportData.category,
          eventName: reportData.event?.name,
          eventId: reportData.event?.id,
          contestName: reportData.contest?.name,
          categoryName: reportData.category?.name,
          reportDataKeys: Object.keys(reportData),
          eventContestsCount: reportData.event?.contests?.length || 0
        })
        
        // CRITICAL CHECK: If this is an EVENT_SUMMARY but we don't have event data, log a warning
        if (reportData.reportType === 'EVENT_SUMMARY' && !reportData.event) {
          log.error('‚ùå CRITICAL: EVENT_SUMMARY report but reportData.event is missing!', {
            reportType: reportData.reportType,
            eventId: eventId,
            hasEvent: !!reportData.event,
            reportDataKeys: Object.keys(reportData)
          })
        }
        
        // Simple replacer that only handles dates and functions - don't remove circular refs
        // Prisma objects have circular refs but we want the data anyway
        const createSimpleReplacer = () => {
          return (key, value) => {
            // Skip functions
            if (typeof value === 'function') return undefined
            
            // Handle Date objects
            if (value instanceof Date) return value.toISOString()
            
            // Limit string length
            if (typeof value === 'string' && value.length > 5000) {
              return value.substring(0, 5000) + '...[truncated]'
            }
            
            return value
          }
        }
        
        // Convert Prisma objects to plain objects first to avoid serialization issues
        // Prisma objects have toJSON methods that might exclude nested data
        const plainReportData = {
          ...reportData,
          // Explicitly convert Prisma objects to plain objects
          event: reportData.event ? {
            ...reportData.event,
            contests: reportData.event.contests ? reportData.event.contests.map(c => ({
              ...c,
              winners: c.winners || [],
              categories: c.categories ? c.categories.map(cat => ({
                ...cat,
                scores: cat.scores || []
              })) : []
            })) : []
          } : undefined,
          contest: reportData.contest ? {
            ...reportData.contest,
            categories: reportData.contest.categories ? reportData.contest.categories.map(cat => ({
              ...cat,
              scores: cat.scores || []
            })) : []
          } : undefined,
          category: reportData.category ? {
            ...reportData.category,
            scores: reportData.category.scores || []
          } : undefined
        }
        
        // Remove undefined values
        Object.keys(plainReportData).forEach(key => {
          if (plainReportData[key] === undefined) {
            delete plainReportData[key]
          }
        })
        
        // Try to stringify - use plain objects instead of Prisma objects
        let fullString = ''
        try {
          // First, try simple stringify on plain object
          try {
            fullString = JSON.stringify(plainReportData)
            log.debug('‚úÖ Direct JSON.stringify succeeded', {
              length: fullString.length,
              hasEvent: fullString.includes('"event"'),
              preview: fullString.substring(0, 300)
            })
          } catch (simpleErr) {
            // If that fails, try with a simple replacer
            log.debug('Direct stringify failed, trying with replacer:', simpleErr.message)
            const replacer = createSimpleReplacer()
            fullString = JSON.stringify(plainReportData, replacer)
            log.debug('‚úÖ JSON.stringify with replacer succeeded', {
              length: fullString.length,
              hasEvent: fullString.includes('"event"')
            })
          }
          
          // Verify the stringified data actually contains the event
          if (fullString && reportData.event && !fullString.includes('"event"')) {
            log.warn('‚ö†Ô∏è Event data not found in stringified result despite reportData.event existing', {
              reportDataKeys: Object.keys(reportData),
              plainReportDataKeys: Object.keys(plainReportData),
              reportDataHasEvent: !!reportData.event,
              plainReportDataHasEvent: !!plainReportData.event,
              eventName: reportData.event?.name,
              stringPreview: fullString.substring(0, 300)
            })
            throw new Error('Event data missing from stringified result')
          }
          
          // Also verify it's not just an empty object
          if (fullString === '{}' || fullString.trim() === '{}') {
            log.warn('‚ö†Ô∏è Stringified result is empty object despite having reportData', {
              reportDataKeys: Object.keys(reportData),
              plainReportDataKeys: Object.keys(plainReportData),
              hasEvent: !!reportData.event
            })
            throw new Error('Stringified result is empty')
          }
        } catch (stringifyErr) {
          // If that fails, create a structure manually with ALL the data
          log.warn('‚ö†Ô∏è JSON.stringify failed, creating manual structure with event data:', stringifyErr.message)
          // Always create manual structure with ALL available data
          const manualData = {
            reportType: reportData.reportType,
            appName: reportData.appName,
            title: reportData.title,
            generatedAt: reportData.generatedAt?.toISOString?.() || new Date().toISOString(),
            generatedBy: reportData.generatedBy
          }
          
          // Always include event data if it exists - this is critical!
          if (reportData.event) {
            log.debug('üîµ Including event data in manual structure', {
              eventId: reportData.event.id,
              eventName: reportData.event.name,
              contestsCount: reportData.event.contests?.length || 0
            })
            manualData.event = {
              id: reportData.event.id,
              name: reportData.event.name,
              description: reportData.event.description,
              startDate: reportData.event.startDate,
              endDate: reportData.event.endDate,
              contests: reportData.event.contests ? reportData.event.contests.map(c => ({
                id: c.id,
                name: c.name,
                description: c.description,
                winners: c.winners || [],
                categories: c.categories ? c.categories.map(cat => ({
                  id: cat.id,
                  name: cat.name,
                  description: cat.description,
                  scoresCount: cat.scores?.length || 0
                })) : []
              })) : []
            }
          }
          
          // Include contest data if it exists
          if (reportData.contest) {
            manualData.contest = {
              id: reportData.contest.id,
              name: reportData.contest.name,
              description: reportData.contest.description,
              categories: reportData.contest.categories ? reportData.contest.categories.map(cat => ({
                id: cat.id,
                name: cat.name,
                description: cat.description,
                scores: cat.scores ? cat.scores.map(s => ({
                  id: s.id,
                  score: s.score,
                  contestantName: s.contestant?.name,
                  judgeName: s.judge?.name
                })) : []
              })) : []
            }
          }
          
          // Include category data if it exists
          if (reportData.category) {
            manualData.category = {
              id: reportData.category.id,
              name: reportData.category.name,
              description: reportData.category.description,
              scores: reportData.category.scores ? reportData.category.scores.map(s => ({
                id: s.id,
                score: s.score,
                contestantName: s.contestant?.name,
                judgeName: s.judge?.name,
                criterionName: s.criterion?.name,
                maxScore: s.criterion?.maxScore
              })) : []
            }
          }
          
          // Include judge data if it exists
          if (reportData.judge) {
            manualData.judge = reportData.judge
            if (reportData.statistics) manualData.statistics = reportData.statistics
            if (reportData.scores) manualData.scores = reportData.scores
          }
          
          // Include analytics data if it exists
          if (reportData.overview) {
            manualData.overview = reportData.overview
            if (reportData.distributions) manualData.distributions = reportData.distributions
            if (reportData.dateRange) manualData.dateRange = reportData.dateRange
          }
          
          try {
            fullString = JSON.stringify(manualData)
            log.debug('‚úÖ Manual structure stringified successfully', {
              length: fullString.length,
              hasEvent: fullString.includes('"event"'),
              eventName: manualData.event?.name
            })
          } catch (manualErr) {
            log.error('‚ùå Failed to stringify even manual structure:', manualErr.message)
            // Last resort: minimal structure with at least event name
            fullString = JSON.stringify({
              reportType: reportData.reportType || 'general',
              appName: reportData.appName || 'Event Manager',
              title: reportData.title || 'Report',
              generatedAt: new Date().toISOString(),
              event: reportData.event ? {
                id: reportData.event.id,
                name: reportData.event.name
              } : null,
              error: 'Report data serialization failed',
              errorMessage: manualErr.message
            })
          }
        }
        
        // Apply size limit (500KB max)
        reportDataString = fullString.length > 500000 
          ? fullString.substring(0, 500000) + '...[truncated]'
          : fullString
          
        log.debug('Report data stringified', { 
          originalSize: JSON.stringify(reportData).length,
          sanitizedSize: reportDataString.length,
          hasEvent: !!reportData.event,
          hasContest: !!reportData.contest,
          hasCategory: !!reportData.category,
          reportType: reportData.reportType,
          dataPreview: reportDataString.substring(0, 200)
        })
        
        // Validate that we actually have data, not just empty object
        if (reportDataString === '{}' || reportDataString.trim() === '{}') {
          log.warn('‚ö†Ô∏è Report data stringified to empty object!', {
            reportType: reportData.reportType,
            hasEvent: !!reportData.event,
            hasContest: !!reportData.contest,
            hasCategory: !!reportData.category,
            reportDataKeys: Object.keys(reportData)
          })
        }
      } catch (stringifyError) {
        log.warn('Failed to stringify full report data, attempting minimal version:', stringifyError.message)
        try {
          // Fallback: try to save at least the basic structure
          const minimalData = {
            reportType: reportData.reportType,
            appName: reportData.appName,
            title: reportData.title,
            generatedAt: reportData.generatedAt?.toISOString?.() || new Date().toISOString(),
            generatedBy: reportData.generatedBy,
            event: reportData.event ? {
              id: reportData.event.id,
              name: reportData.event.name,
              description: reportData.event.description,
              startDate: reportData.event.startDate,
              endDate: reportData.event.endDate
            } : null,
            contest: reportData.contest ? {
              id: reportData.contest.id,
              name: reportData.contest.name,
              description: reportData.contest.description
            } : null,
            category: reportData.category ? {
              id: reportData.category.id,
              name: reportData.category.name,
              description: reportData.category.description
            } : null,
            error: 'Full report data could not be serialized',
            errorMessage: stringifyError.message
          }
          reportDataString = JSON.stringify(minimalData)
        } catch (fallbackError) {
          log.error('Failed to create even minimal report data:', fallbackError.message)
          reportDataString = JSON.stringify({
            reportType: reportData.reportType || 'general',
            appName: reportData.appName || 'Event Manager',
            title: reportData.title || 'Report',
            generatedAt: new Date().toISOString(),
            error: 'Report data serialization failed'
          })
        }
      }
      
      // Only include templateId if default template exists
      const instanceData = {
        name: reportName.trim(),
        type: reportTypeValue.trim(),
        format: reportFormat.trim(),
        generatedById: String(req.user.id).trim(),
        data: reportDataString
      }
      
      // Only set templateId if we have a valid template (don't set to null explicitly - let schema default handle it)
      if (defaultTemplate && defaultTemplate.id) {
        instanceData.templateId = reportTemplateId.trim()
      }
      // If no template, don't set templateId (let it use the default from schema)
      
      log.debug('Creating report instance', {
        name: instanceData.name,
        type: instanceData.type,
        format: instanceData.format,
        generatedById: instanceData.generatedById,
        templateId: instanceData.templateId || 'null (using default)',
        dataLength: instanceData.data ? instanceData.data.length : 0,
        allFields: Object.keys(instanceData)
      })
      
      // Validate instanceData before creating - if validation fails, skip history saving
      if (!instanceData.name || !instanceData.type || !instanceData.format || !instanceData.generatedById) {
        const missingFields = []
        if (!instanceData.name) missingFields.push('name')
        if (!instanceData.type) missingFields.push('type')
        if (!instanceData.format) missingFields.push('format')
        if (!instanceData.generatedById) missingFields.push('generatedById')
        log.warn('Missing required fields for history save, skipping:', missingFields.join(', '))
        reportInstance = null
        // Don't throw - continue with report generation
      }
      
      try {
        reportInstance = await prisma.reportInstance.create({
          data: instanceData
        })
      log.debug('‚úÖ Saved report to history:', reportInstance.id)
      } catch (createError) {
        // If create fails, try without templateId (use schema default)
        if (createError.name === 'PrismaClientValidationError' && instanceData.templateId) {
          log.warn('Retrying report instance creation without templateId:', createError.message)
          delete instanceData.templateId
          try {
            reportInstance = await prisma.reportInstance.create({
              data: instanceData
            })
            log.debug('‚úÖ Saved report to history (retry without templateId):', reportInstance.id)
          } catch (retryError) {
            log.error('Failed to create report instance even without templateId:', retryError, {
              error: retryError.message,
              errorName: retryError.name,
              errorCode: retryError.code,
              prismaError: retryError.meta || retryError.cause,
              instanceDataKeys: Object.keys(instanceData),
              instanceDataValues: Object.fromEntries(
                Object.entries(instanceData).map(([k, v]) => [k, typeof v === 'string' ? v.substring(0, 50) : v])
              )
            })
            // Continue without saving to history - don't throw
          }
        } else {
          // Log the error but don't throw - we want to continue with report generation
          log.error('Failed to create report instance:', createError, {
            error: createError.message,
            errorName: createError.name,
            errorCode: createError.code,
            prismaError: createError.meta || createError.cause,
            instanceDataKeys: Object.keys(instanceData),
            instanceDataValues: Object.fromEntries(
              Object.entries(instanceData).map(([k, v]) => [k, typeof v === 'string' ? v.substring(0, 50) : v])
            )
          })
          // Continue without saving to history - don't throw
        }
      }
      } // Close the else block for validation
    } catch (error) {
      // Capture variables from outer scope for logging
      const errorReportType = reportType
      const errorFormat = format
      const errorTemplateId = templateId
      
      log.error('‚ö†Ô∏è Failed to save report to history:', error, { 
        error: error.message, 
        stack: error.stack,
        reportType: errorReportType,
        format: errorFormat,
        templateId: errorTemplateId,
        userId: req.user?.id,
        errorName: error.name,
        errorCode: error.code,
        prismaError: error.meta || error.cause,
        prismaErrorDetails: error.meta
      })
      // Don't fail the entire request if saving to history fails - we can still generate the report
      reportInstance = null
    }

    // Based on format, generate and return the appropriate file
    // Note: We generate the report even if saving to history failed
    const reportFormat = format || 'json'
    
    if (reportFormat === 'pdf') {
      return generatePDFReport(reportData, res, reportInstance?.id, req)
    } else if (reportFormat === 'excel' || reportFormat === 'xlsx') {
      return generateExcelReport(reportData, res, reportInstance?.id, req)
    } else if (reportFormat === 'csv') {
      return generateCSVReport(reportData, res, reportInstance?.id, req)
    }

    // Default: return JSON
    const report = {
      id: reportInstance?.id,
      reportType: reportType || 'general',
      format: format || 'json',
      eventId: reportData.event?.id || eventId,
      contestId: reportData.contest?.id || contestId,
      categoryId: reportData.category?.id || categoryId,
      title: reportData.title,
      data: reportData,
      generatedAt: reportInstance?.generatedAt || new Date(),
      generatedBy: req.user?.id || 'unknown',
      message: 'Report generated successfully'
    }
    
    log.debug('‚úÖ Sending JSON report response', { reportType: reportType || 'unknown', title: reportData.title })
    res.json({ data: report })
  } catch (error) {
    // If this is a Prisma validation error, try to still generate the report
    // without saving to history
    if (error.name === 'PrismaClientValidationError') {
      log.warn('‚ö†Ô∏è Prisma validation error detected, attempting to generate report without history:', {
        error: error.message,
        errorCode: error.code,
        prismaMeta: error.meta,
        prismaCause: error.cause,
        stack: error.stack
      })
      
      // Try to generate the report even if history saving failed
      try {
        // Check if reportData exists - if error happened early, create minimal reportData
        let safeReportData = reportData
        if (!safeReportData || typeof safeReportData !== 'object') {
          // Get app name from system settings if needed
          let appName = 'Event Manager'
          try {
            const appNameSetting = await prisma.systemSetting.findFirst({
              where: { key: 'app_name' }
            })
            appName = appNameSetting?.value || 'Event Manager'
          } catch (nameError) {
            log.warn('Could not fetch app name:', nameError.message)
          }
          
          safeReportData = {
            reportType: reportType || 'general',
            appName: appName,
            generatedAt: new Date(),
            generatedBy: req.user?.id || 'unknown',
            title: `Report - ${reportType || 'General'}`
          }
        }
        
        const report = {
          id: null,
          reportType: reportType || 'general',
          format: format || 'json',
          eventId: safeReportData.event?.id || eventId || null,
          contestId: safeReportData.contest?.id || contestId || null,
          categoryId: safeReportData.category?.id || categoryId || null,
          title: safeReportData.title || `Report - ${reportType || 'General'}`,
          data: safeReportData,
          generatedAt: new Date(),
          generatedBy: req.user?.id || 'unknown',
          message: 'Report generated successfully (history save failed)'
        }
        
        log.debug('‚úÖ Sending JSON report response (history save failed)', { 
          reportType: reportType || 'unknown', 
          title: safeReportData.title 
        })
        return res.json({ data: report })
      } catch (minimalError) {
        log.error('Failed to generate report after Prisma error:', minimalError, {
          error: minimalError.message,
          stack: minimalError.stack
        })
        // Fall through to regular error handling
      }
    }
    
    // Log full error details
    log.error('‚ùå Generate report error:', error, { 
      error: error.message, 
      stack: error.stack,
      errorName: error.name,
      errorCode: error.code,
      prismaError: error.meta || error.cause,
      prismaMeta: error.meta,
      prismaCause: error.cause,
      requestBody: {
        reportType: reportType || 'undefined',
        eventId: eventId || 'undefined',
        contestId: contestId || 'undefined',
        categoryId: categoryId || 'undefined',
        format: format || 'undefined',
        templateId: templateId || 'undefined'
      },
      hasUser: !!req.user,
      userId: req.user?.id || 'unknown'
    })
    res.status(500).json({ 
      error: 'Internal server error',
      message: error.message,
      details: process.env.NODE_ENV === 'development' ? error.stack : undefined
    })
  }
}

// Generate PDF report
// Note: calculateContestWinners is defined at the top of the file

// Helper function to calculate category total possible score
const calculateCategoryTotalPossible = async (category) => {
  if (!category.scores || category.scores.length === 0) {
    return null
  }

  try {
    // Get all criteria for this category from database
    const criteria = await prisma.criterion.findMany({
      where: { categoryId: category.id }
    })
    
    // Calculate total possible per judge (from criteria or scoreCap)
    const totalPossibleScorePerJudge = criteria.length > 0
      ? criteria.reduce((sum, criterion) => sum + (criterion.maxScore || 0), 0)
      : (category.scoreCap || 0)

    if (totalPossibleScorePerJudge <= 0) {
      return null
    }

    // Get unique judges who have scored
    const uniqueJudges = new Set()
    category.scores.forEach(score => {
      if (score.score !== null && score.judgeId) {
        uniqueJudges.add(score.judgeId)
      }
    })

    // Total possible = max score per judge * number of judges
    if (uniqueJudges.size > 0) {
      return totalPossibleScorePerJudge * uniqueJudges.size
    }

    return null
  } catch (error) {
    console.error('Error calculating category total possible:', error)
    return null
  }
}

const generatePDFReport = async (reportData, res, reportInstanceId, req) => {
  const log = createRequestLogger(req || {}, 'reports')
  try {
    log.debug('üìÑ Generating PDF report...')
    log.debug('Report data:', JSON.stringify(reportData, null, 2))
    
    return new Promise(async (resolve, reject) => {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 }
      })

      // Set headers first
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', `inline; filename="report-${Date.now()}.pdf"`)

      // Pipe PDF to response
      doc.pipe(res)

      // Handle PDF completion
      doc.on('end', () => {
        log.debug('‚úÖ PDF generation completed')
        resolve()
      })

      doc.on('error', (err) => {
        log.error('‚ùå PDF stream error:', err, { error: err.message, stack: err.stack })
        reject(err)
      })

      // Add content based on report type
      const appName = reportData.appName || 'Event Manager'
      const title = reportData.title || `${reportData.reportType || 'General'} Report`
      
      log.debug('Adding title to PDF...', { appName, title })
      doc.fontSize(20).font('Helvetica-Bold').text(title, { align: 'center' })
      doc.moveDown(0.5)
      doc.fontSize(12).font('Helvetica').text(appName, { align: 'center' })
      doc.moveDown(0.5)
      doc.fontSize(10).font('Helvetica').text(`Generated: ${new Date().toLocaleString()}`, { align: 'center' })
      doc.moveDown(2)

      // Generate content based on reportType
      // Handle SYSTEM_ANALYTICS first
      if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
        // System Analytics Report
        doc.fontSize(16).font('Helvetica-Bold').text('System Analytics', { align: 'left' })
        doc.moveDown()
        
        // Overview statistics
        doc.fontSize(12).font('Helvetica-Bold').text('Overview Statistics')
        doc.fontSize(10).font('Helvetica')
        const overview = reportData.overview
        doc.text(`Total Users: ${overview.totalUsers || 0}`)
        doc.text(`Total Events: ${overview.totalEvents || 0}`)
        doc.text(`Total Contests: ${overview.totalContests || 0}`)
        doc.text(`Total Categories: ${overview.totalCategories || 0}`)
        doc.text(`Total Scores: ${overview.totalScores || 0}`)
        doc.text(`Total Files: ${overview.totalFiles || 0}`)
        doc.text(`User Activity: ${overview.userActivity || 0}`)
        
        // Date range if provided
        if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
          doc.moveDown()
          doc.fontSize(10).font('Helvetica')
          if (reportData.dateRange.startDate) {
            doc.text(`Period Start: ${new Date(reportData.dateRange.startDate).toLocaleDateString()}`)
          }
          if (reportData.dateRange.endDate) {
            doc.text(`Period End: ${new Date(reportData.dateRange.endDate).toLocaleDateString()}`)
          }
        }
        
        // Distributions
        if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
          doc.moveDown()
          doc.fontSize(12).font('Helvetica-Bold').text('User Role Distribution')
          doc.fontSize(10).font('Helvetica')
          reportData.distributions.userRoles.forEach((role) => {
            doc.text(`${role.role}: ${role.count}`)
          })
        }
      } else if (reportData.event && (reportData.reportType === 'EVENT_SUMMARY' || reportData.reportType === 'event' || !reportData.contest && !reportData.category)) {
        // Event Summary Report
        const event = reportData.event
        doc.fontSize(16).font('Helvetica-Bold').text('Event Summary', { align: 'left' })
        doc.moveDown()
        doc.fontSize(12).font('Helvetica-Bold').text('Event Information')
        doc.fontSize(10).font('Helvetica')
        doc.text(`Name: ${event.name}`)
        if (event.description) doc.text(`Description: ${event.description}`)
        if (event.startDate) doc.text(`Start Date: ${new Date(event.startDate).toLocaleDateString()}`)
        if (event.endDate) doc.text(`End Date: ${new Date(event.endDate).toLocaleDateString()}`)
        
        if (event.contests && event.contests.length > 0) {
          doc.moveDown()
          doc.fontSize(12).font('Helvetica-Bold').text(`Contests and Winners (${event.contests.length})`)
          doc.fontSize(10).font('Helvetica')
          
          // Process each contest to show winners
          for (let i = 0; i < event.contests.length; i++) {
            const contest = event.contests[i]
          doc.moveDown(0.5)
            doc.fontSize(11).font('Helvetica-Bold').text(`${i + 1}. ${contest.name}`)
            doc.fontSize(10).font('Helvetica')
            
            if (contest.categories && contest.categories.length > 0) {
              doc.text(`   Categories: ${contest.categories.length}`)
            }
            
            // Calculate and display winners for this contest
            try {
              const winners = await calculateContestWinners(contest)
              if (winners && winners.length > 0) {
                doc.moveDown(0.25)
                doc.fontSize(10).font('Helvetica-Bold').text('   Winners:')
                doc.fontSize(9).font('Helvetica')
                
                winners.forEach((winner, idx) => {
                  const contestantName = winner.contestant?.preferredName || winner.contestant?.name || 'Unknown'
                  const scoreDisplay = winner.totalPossibleScore !== null && winner.totalPossibleScore > 0
                    ? `${winner.totalScore} out of ${winner.totalPossibleScore}`
                    : `${winner.totalScore} points`
                  // Use text-based rank indicators instead of emojis for better PDF compatibility
                  const rank = idx === 0 ? '1st' : idx === 1 ? '2nd' : idx === 2 ? '3rd' : `${idx + 1}th`
                  doc.text(`     ${rank}. ${contestantName}: ${scoreDisplay}`)
                })
              } else {
                doc.text('     No winners calculated (no scores available)')
              }
            } catch (error) {
              doc.text(`     Error calculating winners: ${error.message}`)
            }
          }
        }
      } else if (reportData.contest && (reportData.reportType === 'CONTEST_RESULTS' || reportData.reportType === 'contest' || !reportData.category)) {
        // Contest Results Report
        const contest = reportData.contest
        doc.fontSize(16).font('Helvetica-Bold').text('Contest Results', { align: 'left' })
        doc.moveDown()
        
        if (reportData.event) {
          doc.fontSize(11).font('Helvetica-Bold').text('Event:', { continued: true })
          doc.fontSize(10).font('Helvetica').text(` ${reportData.event.name}`)
          doc.moveDown(0.5)
        }
        
        doc.fontSize(12).font('Helvetica-Bold').text('Contest Information')
        doc.fontSize(10).font('Helvetica')
        doc.text(`Name: ${contest.name}`)
        if (contest.description) doc.text(`Description: ${contest.description}`)
        
        if (contest.categories && contest.categories.length > 0) {
          doc.moveDown()
          doc.fontSize(12).font('Helvetica-Bold').text('Categories and Results')
          doc.fontSize(10).font('Helvetica')
          
          // Process categories sequentially to handle async calculateCategoryTotalPossible
          for (let i = 0; i < contest.categories.length; i++) {
            const category = contest.categories[i]
            doc.moveDown(0.5)
            doc.fontSize(11).font('Helvetica-Bold').text(`${i + 1}. ${category.name}`)
            if (category.scores && category.scores.length > 0) {
              // Group scores by contestant
              const scoresByContestant = {}
              category.scores.forEach(score => {
                const contestantId = score.contestantId || 'unknown'
                if (!scoresByContestant[contestantId]) {
                  scoresByContestant[contestantId] = {
                    contestant: score.contestant,
                    scores: []
                  }
                }
                scoresByContestant[contestantId].scores.push(score)
              })
              
              // Calculate total possible for this category
              const categoryTotalPossible = await calculateCategoryTotalPossible(category)
              
              Object.values(scoresByContestant).forEach(({ contestant, scores }) => {
                const contestantName = contestant?.preferredName || contestant?.name || 'Unknown'
                const totalScore = scores.reduce((sum, s) => sum + (s.score || 0), 0)
                const scoreDisplay = categoryTotalPossible !== null
                  ? `${totalScore} out of ${categoryTotalPossible}`
                  : `${totalScore} points`
                doc.fontSize(9).text(`   ${contestantName}: ${scoreDisplay}`)
              })
            } else {
              doc.fontSize(9).text('   No scores recorded')
            }
          }
        }
      } else if (reportData.category) {
        // Category Report
        const category = reportData.category
        doc.fontSize(16).font('Helvetica-Bold').text('Category Report', { align: 'left' })
        doc.moveDown()
        
        if (reportData.event) {
          doc.fontSize(11).font('Helvetica-Bold').text('Event:', { continued: true })
          doc.fontSize(10).font('Helvetica').text(` ${reportData.event.name}`)
        }
      if (reportData.contest) {
          doc.fontSize(11).font('Helvetica-Bold').text('Contest:', { continued: true })
          doc.fontSize(10).font('Helvetica').text(` ${reportData.contest.name}`)
        }
        doc.moveDown()
        
        doc.fontSize(12).font('Helvetica-Bold').text('Category Information')
        doc.fontSize(10).font('Helvetica')
        doc.text(`Name: ${category.name}`)
        if (category.description) doc.text(`Description: ${category.description}`)
        
        if (category.scores && category.scores.length > 0) {
          doc.moveDown()
          doc.fontSize(12).font('Helvetica-Bold').text('Scores')
          doc.fontSize(10).font('Helvetica')
          
          const scoresByContestant = {}
          category.scores.forEach(score => {
            const contestantId = score.contestantId || 'unknown'
            if (!scoresByContestant[contestantId]) {
              scoresByContestant[contestantId] = {
                contestant: score.contestant,
                scores: []
              }
            }
            scoresByContestant[contestantId].scores.push(score)
          })
          
          // Calculate total possible for this category
          const categoryTotalPossible = await calculateCategoryTotalPossible(category)
          
          Object.values(scoresByContestant).forEach(({ contestant, scores }) => {
            const contestantName = contestant?.preferredName || contestant?.name || 'Unknown'
            const totalScore = scores.reduce((sum, s) => sum + (s.score || 0), 0)
            const scoreDisplay = categoryTotalPossible !== null
              ? `${totalScore} out of ${categoryTotalPossible}`
              : `${totalScore} points`
            doc.text(`${contestantName}: ${scoreDisplay}`)
          })
        }
      } else {
        // Generic report - show whatever data is available
        if (reportData.event) {
          doc.fontSize(14).font('Helvetica-Bold').text('Event Information')
          doc.fontSize(10).font('Helvetica')
          doc.text(`Name: ${reportData.event.name}`)
          if (reportData.event.description) doc.text(`Description: ${reportData.event.description}`)
          doc.moveDown()
        }
        
        if (reportData.contest) {
          doc.fontSize(14).font('Helvetica-Bold').text('Contest Information')
          doc.fontSize(10).font('Helvetica')
          doc.text(`Name: ${reportData.contest.name}`)
          if (reportData.contest.description) doc.text(`Description: ${reportData.contest.description}`)
        }
      }

      // Finalize PDF
      log.debug('Ending PDF document...')
      doc.end()
    })
    
  } catch (error) {
    log.error('‚ùå PDF generation error:', error, { error: error.message, stack: error.stack })
    throw error
  }
}

// Generate Excel report
const generateExcelReport = async (reportData, res, reportInstanceId, req) => {
  const log = createRequestLogger(req || {}, 'reports')
  try {
    log.debug('üìä Generating Excel report...')
    
    const appName = reportData.appName || 'Event Manager'
    const title = reportData.title || `${reportData.reportType || 'General'} Report`
    
    const workbook = new ExcelJS.Workbook()
    const worksheet = workbook.addWorksheet('Report')

    // Add title row
    worksheet.mergeCells('A1:B1')
    const titleRow = worksheet.getRow(1)
    titleRow.getCell(1).value = title
    titleRow.getCell(1).font = { size: 16, bold: true }
    titleRow.getCell(1).alignment = { horizontal: 'center', vertical: 'middle' }
    titleRow.height = 25

    // Add app name
    worksheet.mergeCells('A2:B2')
    const appRow = worksheet.getRow(2)
    appRow.getCell(1).value = appName
    appRow.getCell(1).font = { size: 12 }
    appRow.getCell(1).alignment = { horizontal: 'center', vertical: 'middle' }
    
    worksheet.addRow([]) // Empty row
    
    // Add data based on reportType
    // Handle SYSTEM_ANALYTICS first
    if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
      worksheet.addRow({ field: 'Report Type', value: 'System Analytics' })
      worksheet.addRow([])
      worksheet.addRow({ field: 'Overview Statistics', value: '' })
      const overview = reportData.overview
      worksheet.addRow({ field: 'Total Users', value: overview.totalUsers || 0 })
      worksheet.addRow({ field: 'Total Events', value: overview.totalEvents || 0 })
      worksheet.addRow({ field: 'Total Contests', value: overview.totalContests || 0 })
      worksheet.addRow({ field: 'Total Categories', value: overview.totalCategories || 0 })
      worksheet.addRow({ field: 'Total Scores', value: overview.totalScores || 0 })
      worksheet.addRow({ field: 'Total Files', value: overview.totalFiles || 0 })
      worksheet.addRow({ field: 'User Activity', value: overview.userActivity || 0 })
      
      if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
        worksheet.addRow([])
        if (reportData.dateRange.startDate) {
          worksheet.addRow({ field: 'Period Start', value: new Date(reportData.dateRange.startDate).toLocaleDateString() })
        }
        if (reportData.dateRange.endDate) {
          worksheet.addRow({ field: 'Period End', value: new Date(reportData.dateRange.endDate).toLocaleDateString() })
        }
      }
      
      if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
        worksheet.addRow([])
        worksheet.addRow({ field: 'User Role Distribution', value: '' })
        reportData.distributions.userRoles.forEach((role) => {
          worksheet.addRow({ field: role.role, value: role.count })
        })
      }
    } else if (reportData.event && (reportData.reportType === 'EVENT_SUMMARY' || reportData.reportType === 'event' || !reportData.contest && !reportData.category)) {
      const event = reportData.event
      worksheet.addRow({ field: 'Report Type', value: 'Event Summary' })
      worksheet.addRow({ field: 'Event Name', value: event.name })
      if (event.description) worksheet.addRow({ field: 'Description', value: event.description })
      if (event.startDate) worksheet.addRow({ field: 'Start Date', value: new Date(event.startDate).toLocaleDateString() })
      if (event.endDate) worksheet.addRow({ field: 'End Date', value: new Date(event.endDate).toLocaleDateString() })
      if (event.contests && event.contests.length > 0) {
        worksheet.addRow({ field: 'Number of Contests', value: event.contests.length })
        worksheet.addRow([])
        worksheet.addRow({ field: 'Contest Name', value: 'Winners' })
        
        // Process each contest to show winners
        for (const contest of event.contests) {
          try {
            const winners = await calculateContestWinners(contest)
            if (winners && winners.length > 0) {
              const winnersText = winners.map((winner, idx) => {
                const contestantName = winner.contestant?.preferredName || winner.contestant?.name || 'Unknown'
                const scoreDisplay = winner.totalPossibleScore !== null && winner.totalPossibleScore > 0
                  ? `${winner.totalScore} out of ${winner.totalPossibleScore}`
                  : `${winner.totalScore} points`
                // Use text-based rank indicators instead of emojis
                const rank = idx === 0 ? '1st' : idx === 1 ? '2nd' : idx === 2 ? '3rd' : `${idx + 1}th`
                return `${rank}. ${contestantName}: ${scoreDisplay}`
              }).join('; ')
              worksheet.addRow({ 
                field: contest.name, 
                value: winnersText || 'No winners'
              })
            } else {
              worksheet.addRow({ 
                field: contest.name, 
                value: 'No winners calculated (no scores available)'
              })
            }
          } catch (error) {
            worksheet.addRow({ 
              field: contest.name, 
              value: `Error: ${error.message}`
            })
          }
        }
      }
    } else if (reportData.contest && (reportData.reportType === 'CONTEST_RESULTS' || reportData.reportType === 'contest' || !reportData.category)) {
      const contest = reportData.contest
      worksheet.addRow({ field: 'Report Type', value: 'Contest Results' })
      if (reportData.event) worksheet.addRow({ field: 'Event', value: reportData.event.name })
      worksheet.addRow({ field: 'Contest Name', value: contest.name })
      if (contest.description) worksheet.addRow({ field: 'Description', value: contest.description })
      
      if (contest.categories && contest.categories.length > 0) {
        worksheet.addRow([])
        worksheet.addRow({ field: 'Category', value: 'Results' })
        // Process categories sequentially to handle async calculateCategoryTotalPossible
        for (const category of contest.categories) {
          if (category.scores && category.scores.length > 0) {
            const scoresByContestant = {}
            category.scores.forEach(score => {
              const contestantId = score.contestantId || 'unknown'
              if (!scoresByContestant[contestantId]) {
                scoresByContestant[contestantId] = {
                  contestant: score.contestant,
                  scores: []
                }
              }
              scoresByContestant[contestantId].scores.push(score)
            })
            const totalPoints = Object.values(scoresByContestant).reduce((sum, { scores }) => 
              sum + scores.reduce((s, score) => s + (score.score || 0), 0), 0)
            // Calculate total possible for this category
            const categoryTotalPossible = await calculateCategoryTotalPossible(category)
            const scoreText = categoryTotalPossible !== null
              ? `${totalPoints} out of ${categoryTotalPossible}`
              : `${totalPoints} points`
            worksheet.addRow({ field: category.name, value: `${Object.keys(scoresByContestant).length} contestants, ${scoreText}` })
          } else {
            worksheet.addRow({ field: category.name, value: 'No scores recorded' })
          }
        }
      }
    } else if (reportData.category) {
      const category = reportData.category
      worksheet.addRow({ field: 'Report Type', value: 'Category Report' })
      if (reportData.event) worksheet.addRow({ field: 'Event', value: reportData.event.name })
      if (reportData.contest) worksheet.addRow({ field: 'Contest', value: reportData.contest.name })
      worksheet.addRow({ field: 'Category Name', value: category.name })
      if (category.description) worksheet.addRow({ field: 'Description', value: category.description })
      
      if (category.scores && category.scores.length > 0) {
        worksheet.addRow([])
        worksheet.addRow({ field: 'Contestant', value: 'Total Score' })
        const scoresByContestant = {}
        category.scores.forEach(score => {
          const contestantId = score.contestantId || 'unknown'
          if (!scoresByContestant[contestantId]) {
            scoresByContestant[contestantId] = {
              contestant: score.contestant,
              scores: []
            }
          }
          scoresByContestant[contestantId].scores.push(score)
        })
        // Calculate total possible for this category
        const categoryTotalPossible = await calculateCategoryTotalPossible(category)
        
        Object.values(scoresByContestant).forEach(({ contestant, scores }) => {
          const contestantName = contestant?.preferredName || contestant?.name || 'Unknown'
          const totalScore = scores.reduce((sum, s) => sum + (s.score || 0), 0)
          const scoreDisplay = categoryTotalPossible !== null
            ? `${totalScore} out of ${categoryTotalPossible}`
            : `${totalScore} points`
          worksheet.addRow({ field: contestantName, value: scoreDisplay })
        })
      }
    } else {
      // Generic report
    if (reportData.event) {
      worksheet.addRow({ field: 'Event Name', value: reportData.event.name })
        if (reportData.event.description) worksheet.addRow({ field: 'Description', value: reportData.event.description })
    }
    if (reportData.contest) {
      worksheet.addRow({ field: 'Contest Name', value: reportData.contest.name })
      }
    }

    // Set column widths
    worksheet.columns = [
      { header: 'Field', key: 'field', width: 30 },
      { header: 'Value', key: 'value', width: 50 }
    ]
    
    // Format header row if it exists
    const headerRowNum = reportData.reportType === 'EVENT_SUMMARY' ? 5 : 
                        reportData.reportType === 'CONTEST_RESULTS' ? 5 : 
                        reportData.category ? 6 : 4
    if (worksheet.getRow(headerRowNum)) {
      worksheet.getRow(headerRowNum).font = { bold: true }
    }

    const buffer = await workbook.xlsx.writeBuffer()

    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', `attachment; filename="${title.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.xlsx"`)
    res.send(buffer)
    log.debug('‚úÖ Excel generation completed')
  } catch (error) {
    log.error('‚ùå Excel generation error:', error, { error: error.message, stack: error.stack })
    throw error
  }
}

// Generate CSV report
const generateCSVReport = async (reportData, res, reportInstanceId, req) => {
  // Note: CSV generation needs to be async-aware for calculateContestWinners and calculateCategoryTotalPossible
  const log = createRequestLogger(req || {}, 'reports')
  try {
    log.debug('üìù Generating CSV report...')
    
    const appName = reportData.appName || 'Event Manager'
    const title = reportData.title || `${reportData.reportType || 'General'} Report`
    
    let csvContent = `${title}\n`
    csvContent += `${appName}\n`
    csvContent += `Generated: ${new Date().toLocaleString()}\n\n`
    csvContent += 'Field,Value\n'
    
    // Add data based on reportType
    // Handle SYSTEM_ANALYTICS first
    if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
      csvContent += `Report Type,System Analytics\n`
      csvContent += `\nOverview Statistics,\n`
      const overview = reportData.overview
      csvContent += `Total Users,${overview.totalUsers || 0}\n`
      csvContent += `Total Events,${overview.totalEvents || 0}\n`
      csvContent += `Total Contests,${overview.totalContests || 0}\n`
      csvContent += `Total Categories,${overview.totalCategories || 0}\n`
      csvContent += `Total Scores,${overview.totalScores || 0}\n`
      csvContent += `Total Files,${overview.totalFiles || 0}\n`
      csvContent += `User Activity,${overview.userActivity || 0}\n`
      
      if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
        csvContent += `\n`
        if (reportData.dateRange.startDate) {
          csvContent += `Period Start,${new Date(reportData.dateRange.startDate).toLocaleDateString()}\n`
        }
        if (reportData.dateRange.endDate) {
          csvContent += `Period End,${new Date(reportData.dateRange.endDate).toLocaleDateString()}\n`
        }
      }
      
      if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
        csvContent += `\nUser Role Distribution,\n`
        reportData.distributions.userRoles.forEach((role) => {
          csvContent += `${role.role},${role.count}\n`
        })
      }
    } else if (reportData.event && (reportData.reportType === 'EVENT_SUMMARY' || reportData.reportType === 'event' || !reportData.contest && !reportData.category)) {
      const event = reportData.event
      csvContent += `Report Type,Event Summary\n`
      csvContent += `Event Name,${event.name}\n`
      if (event.description) csvContent += `Description,"${event.description.replace(/"/g, '""')}"\n`
      if (event.startDate) csvContent += `Start Date,${new Date(event.startDate).toLocaleDateString()}\n`
      if (event.endDate) csvContent += `End Date,${new Date(event.endDate).toLocaleDateString()}\n`
      if (event.contests && event.contests.length > 0) {
        csvContent += `Number of Contests,${event.contests.length}\n`
        csvContent += `\nContest Name,Winners\n`
        
        // Process each contest to show winners
        for (const contest of event.contests) {
          try {
            const winners = await calculateContestWinners(contest)
            if (winners && winners.length > 0) {
              const winnersText = winners.map((winner, idx) => {
                const contestantName = winner.contestant?.preferredName || winner.contestant?.name || 'Unknown'
                const scoreDisplay = winner.totalPossibleScore !== null && winner.totalPossibleScore > 0
                  ? `${winner.totalScore} out of ${winner.totalPossibleScore}`
                  : `${winner.totalScore} points`
                // Use text-based rank indicators instead of emojis
                const rank = idx === 0 ? '1st' : idx === 1 ? '2nd' : idx === 2 ? '3rd' : `${idx + 1}th`
                return `${rank}. ${contestantName}: ${scoreDisplay}`
              }).join('; ')
              csvContent += `${contest.name},"${winnersText.replace(/"/g, '""')}"\n`
            } else {
              csvContent += `${contest.name},No winners calculated (no scores available)\n`
            }
          } catch (error) {
            csvContent += `${contest.name},"Error: ${error.message.replace(/"/g, '""')}"\n`
          }
        }
      }
    } else if (reportData.contest && (reportData.reportType === 'CONTEST_RESULTS' || reportData.reportType === 'contest' || !reportData.category)) {
      const contest = reportData.contest
      csvContent += `Report Type,Contest Results\n`
      if (reportData.event) csvContent += `Event,${reportData.event.name}\n`
      csvContent += `Contest Name,${contest.name}\n`
      if (contest.description) csvContent += `Description,"${contest.description.replace(/"/g, '""')}"\n`
      
      if (contest.categories && contest.categories.length > 0) {
        csvContent += `\nCategory,Results\n`
        // Process categories sequentially to handle async calculateCategoryTotalPossible
        for (const category of contest.categories) {
          if (category.scores && category.scores.length > 0) {
            const scoresByContestant = {}
            category.scores.forEach(score => {
              const contestantId = score.contestantId || 'unknown'
              if (!scoresByContestant[contestantId]) {
                scoresByContestant[contestantId] = { contestant: score.contestant, scores: [] }
              }
              scoresByContestant[contestantId].scores.push(score)
            })
            const totalPoints = Object.values(scoresByContestant).reduce((sum, { scores }) => 
              sum + scores.reduce((s, score) => s + (score.score || 0), 0), 0)
            // Calculate total possible for this category
            const categoryTotalPossible = await calculateCategoryTotalPossible(category)
            const scoreText = categoryTotalPossible !== null
              ? `${totalPoints} out of ${categoryTotalPossible}`
              : `${totalPoints} points`
            csvContent += `${category.name},"${Object.keys(scoresByContestant).length} contestants, ${scoreText}"\n`
          } else {
            csvContent += `${category.name},No scores recorded\n`
          }
        }
      }
    } else if (reportData.category) {
      const category = reportData.category
      csvContent += `Report Type,Category Report\n`
      if (reportData.event) csvContent += `Event,${reportData.event.name}\n`
      if (reportData.contest) csvContent += `Contest,${reportData.contest.name}\n`
      csvContent += `Category Name,${category.name}\n`
      if (category.description) csvContent += `Description,"${category.description.replace(/"/g, '""')}"\n`
      
      if (category.scores && category.scores.length > 0) {
        csvContent += `\nContestant,Total Score\n`
        const scoresByContestant = {}
        category.scores.forEach(score => {
          const contestantId = score.contestantId || 'unknown'
          if (!scoresByContestant[contestantId]) {
            scoresByContestant[contestantId] = { contestant: score.contestant, scores: [] }
          }
          scoresByContestant[contestantId].scores.push(score)
        })
        // Calculate total possible for this category
        const categoryTotalPossible = await calculateCategoryTotalPossible(category)
        
        Object.values(scoresByContestant).forEach(({ contestant, scores }) => {
          const contestantName = contestant?.preferredName || contestant?.name || 'Unknown'
          const totalScore = scores.reduce((sum, s) => sum + (s.score || 0), 0)
          const scoreDisplay = categoryTotalPossible !== null
            ? `${totalScore} out of ${categoryTotalPossible}`
            : `${totalScore} points`
          csvContent += `${contestantName},"${scoreDisplay}"\n`
        })
      }
    } else {
      // Generic report
    if (reportData.event) {
      csvContent += `Event Name,${reportData.event.name}\n`
        if (reportData.event.description) csvContent += `Description,"${reportData.event.description.replace(/"/g, '""')}"\n`
    }
    if (reportData.contest) {
      csvContent += `Contest Name,${reportData.contest.name}\n`
    }
    }

    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', `attachment; filename="${title.replace(/[^a-z0-9]/gi, '_')}-${Date.now()}.csv"`)
    res.send(csvContent)
    log.debug('‚úÖ CSV generation completed')
  } catch (error) {
    log.error('‚ùå CSV generation error:', error, { error: error.message, stack: error.stack })
    throw error
  }
}

// Helper function to generate HTML for PDF
const generateReportHTML = (reportData) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Event Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #333; padding-bottom: 20px; }
        .content { margin: 20px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background-color: #4CAF50; color: white; font-weight: bold; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        .section { margin-bottom: 30px; }
        .section-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #333; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Event Manager Report</h1>
        <p>Generated on: ${new Date().toLocaleString()}</p>
      </div>
      <div class="content">
        ${reportData.event ? `
          <div class="section">
            <div class="section-title">Event Information</div>
            <table>
              <tr><th>Field</th><th>Value</th></tr>
              <tr><td>Event Name</td><td>${reportData.event.name}</td></tr>
              <tr><td>Description</td><td>${reportData.event.description || 'N/A'}</td></tr>
              <tr><td>Start Date</td><td>${new Date(reportData.event.startDate).toLocaleDateString()}</td></tr>
              <tr><td>End Date</td><td>${new Date(reportData.event.endDate).toLocaleDateString()}</td></tr>
              <tr><td>Status</td><td>${reportData.event.status || 'N/A'}</td></tr>
            </table>
          </div>
        ` : ''}
        ${reportData.contest ? `
          <div class="section">
            <div class="section-title">Contest Information</div>
            <table>
              <tr><th>Field</th><th>Value</th></tr>
              <tr><td>Contest Name</td><td>${reportData.contest.name}</td></tr>
              <tr><td>Description</td><td>${reportData.contest.description || 'N/A'}</td></tr>
            </table>
          </div>
        ` : ''}
      </div>
    </body>
    </html>
  `
}

const getHistory = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const history = await prisma.reportInstance.findMany({
      include: {
        template: true,
        generatedBy: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { generatedAt: 'desc' },
      take: 100
    })

    res.json(history)
  } catch (error) {
    log.error('Get report history error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate comprehensive event report
const generateEventReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { eventId, includeDetails = false, format = 'JSON' } = req.body

    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                scores: {
                  include: {
                    judge: {
                      select: {
                        id: true,
                        name: true,
                        email: true
                      }
                    },
                    contestant: {
                      select: {
                        id: true,
                        name: true,
                        email: true,
                        contestantNumber: true
                      }
                    },
                    criterion: {
                      select: {
                        id: true,
                        name: true,
                        description: true,
                        maxScore: true
                      }
                    }
                  }
                },
                contestants: {
                  include: {
                    user: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true,
                        contestantAge: true,
                        contestantSchool: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Calculate comprehensive statistics
    const eventStats = {
      totalContests: event.contests.length,
      totalCategories: event.contests.reduce((sum, contest) => sum + contest.categories.length, 0),
      totalContestants: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.contestants.length, 0), 0),
      totalScores: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.scores.length, 0), 0)
    }

    // Generate contest summaries
    const contestSummaries = event.contests.map(contest => {
      const contestStats = {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        totalCategories: contest.categories.length,
        totalContestants: contest.categories.reduce((sum, category) => sum + category.contestants.length, 0),
        totalScores: contest.categories.reduce((sum, category) => sum + category.scores.length, 0)
      }

      if (includeDetails) {
        contestStats.categories = contest.categories.map(category => {
          const categoryStats = {
            id: category.id,
            name: category.name,
            description: category.description,
            maxScore: category.maxScore,
            totalContestants: category.contestants.length,
            totalScores: category.scores.length,
            averageScore: category.scores.length > 0 ? 
              category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0
          }

          // Calculate contestant rankings
          const contestantScores = category.scores.reduce((acc, score) => {
            const key = score.contestantId
            if (!acc[key]) {
              acc[key] = {
                contestant: score.contestant,
                scores: [],
                totalScore: 0
              }
            }
            acc[key].scores.push(score)
            acc[key].totalScore += score.score
            return acc
          }, {})

          categoryStats.contestantRankings = Object.values(contestantScores)
            .map(group => ({
              contestant: group.contestant,
              totalScore: group.totalScore,
              averageScore: group.totalScore / group.scores.length,
              scoreCount: group.scores.length
            }))
            .sort((a, b) => b.totalScore - a.totalScore)
            .map((ranking, index) => ({ ...ranking, rank: index + 1 }))

          return categoryStats
        })
      }

      return contestStats
    })

    const report = {
      event: {
        id: event.id,
        name: event.name,
        description: event.description,
        startDate: event.startDate,
        endDate: event.endDate,
        location: event.location,
        maxContestants: event.maxContestants,
        status: event.status
      },
      statistics: eventStats,
      contests: contestSummaries,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Event Report - ${event.name}`,
        type: 'EVENT_REPORT',
        parameters: JSON.stringify({ eventId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Event report generated successfully'
    })
  } catch (error) {
    log.error('Generate event report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate contest results report
const generateContestResultsReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { contestId, includeDetails = false, format = 'JSON' } = req.body

    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            scores: {
              include: {
                judge: {
                  select: {
                    id: true,
                    name: true,
                    email: true
                  }
                },
                contestant: {
                  select: {
                    id: true,
                    name: true,
                    email: true,
                    contestantNumber: true
                  }
                },
                criterion: {
                  select: {
                    id: true,
                    name: true,
                    description: true,
                    maxScore: true
                  }
                }
              }
            },
            contestants: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true,
                    contestantAge: true,
                    contestantSchool: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Calculate contest statistics
    const contestStats = {
      totalCategories: contest.categories.length,
      totalContestants: contest.categories.reduce((sum, category) => sum + category.contestants.length, 0),
      totalScores: contest.categories.reduce((sum, category) => sum + category.scores.length, 0)
    }

    // Generate category results
    const categoryResults = contest.categories.map(category => {
      const categoryStats = {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore,
        totalContestants: category.contestants.length,
        totalScores: category.scores.length
      }

      // Calculate contestant rankings
      const contestantScores = category.scores.reduce((acc, score) => {
        const key = score.contestantId
        if (!acc[key]) {
          acc[key] = {
            contestant: score.contestant,
            scores: [],
            totalScore: 0
          }
        }
        acc[key].scores.push(score)
        acc[key].totalScore += score.score
        return acc
      }, {})

      categoryStats.contestantRankings = Object.values(contestantScores)
        .map(group => ({
          contestant: group.contestant,
          totalScore: group.totalScore,
          averageScore: group.totalScore / group.scores.length,
          scoreCount: group.scores.length
        }))
        .sort((a, b) => b.totalScore - a.totalScore)
        .map((ranking, index) => ({ ...ranking, rank: index + 1 }))

      if (includeDetails) {
        categoryStats.scoreDetails = category.scores.map(score => ({
          id: score.id,
          judge: score.judge,
          contestant: score.contestant,
          criterion: score.criterion,
          score: score.score,
          comments: score.comments,
          createdAt: score.createdAt
        }))
      }

      return categoryStats
    })

    const report = {
      contest: {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        eventName: contest.event.name,
        startDate: contest.startDate,
        endDate: contest.endDate
      },
      statistics: contestStats,
      categories: categoryResults,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Contest Results Report - ${contest.name}`,
        type: 'CONTEST_RESULTS',
        parameters: JSON.stringify({ contestId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Contest results report generated successfully'
    })
  } catch (error) {
    log.error('Generate contest results report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate judge performance report
const generateJudgePerformanceReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { judgeId, eventId, includeDetails = false, format = 'JSON' } = req.body

    const judge = await prisma.user.findUnique({
      where: { id: judgeId },
      select: {
        id: true,
        name: true,
        preferredName: true,
        email: true,
        role: true,
        judgeBio: true,
        judgeSpecialties: true,
        judgeCertifications: true
      }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    // Get judge's scores
    const scores = await prisma.score.findMany({
      where: {
        judgeId: judgeId,
        ...(eventId && {
          event: { id: eventId }
        })
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          select: {
            id: true,
            name: true,
            email: true,
            contestantNumber: true
          }
        },
        criterion: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    // Calculate judge statistics
    const judgeStats = {
      totalScores: scores.length,
      averageScore: scores.length > 0 ? scores.reduce((sum, score) => sum + score.score, 0) / scores.length : 0,
      maxScore: Math.max(...scores.map(s => s.score), 0),
      minScore: Math.min(...scores.map(s => s.score), 0),
      uniqueCategories: new Set(scores.map(s => s.categoryId)).size,
      uniqueContestants: new Set(scores.map(s => s.contestantId)).size
    }

    // Group scores by category
    const categoryPerformance = scores.reduce((acc, score) => {
      const categoryId = score.categoryId
      if (!acc[categoryId]) {
        acc[categoryId] = {
          category: score.category,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[categoryId].scores.push(score)
      acc[categoryId].totalScore += score.score
      return acc
    }, {})

    // Calculate averages for each category
    Object.values(categoryPerformance).forEach(category => {
      category.averageScore = category.scores.length > 0 ? category.totalScore / category.scores.length : 0
    })

    const report = {
      judge: {
        id: judge.id,
        name: judge.preferredName || judge.name, // Use preferredName if available, fallback to name
        email: judge.email,
        role: judge.role,
        bio: judge.judgeBio,
        specialties: judge.judgeSpecialties ? JSON.parse(judge.judgeSpecialties) : [],
        certifications: judge.judgeCertifications ? JSON.parse(judge.judgeCertifications) : []
      },
      statistics: judgeStats,
      categoryPerformance: Object.values(categoryPerformance),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    if (includeDetails) {
      report.scoreDetails = scores.map(score => ({
        id: score.id,
        category: score.category,
        contestant: score.contestant,
        criterion: score.criterion,
        score: score.score,
        comments: score.comments,
        createdAt: score.createdAt
      }))
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Judge Performance Report - ${judge.preferredName || judge.name}`,
        type: 'JUDGE_PERFORMANCE',
        parameters: JSON.stringify({ judgeId, eventId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Judge performance report generated successfully'
    })
  } catch (error) {
    log.error('Generate judge performance report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate system analytics report
const generateSystemAnalyticsReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { startDate, endDate, includeDetails = false, format = 'JSON' } = req.body

    const dateFilter = {
      ...(startDate && { gte: new Date(startDate) }),
      ...(endDate && { lte: new Date(endDate) })
    }

    // Get system statistics
    const [
      totalUsers,
      totalEvents,
      totalContests,
      totalCategories,
      totalScores,
      totalFiles,
      userActivity,
      eventActivity,
      scoreActivity
    ] = await Promise.all([
      prisma.user.count(),
      prisma.event.count({ where: { createdAt: dateFilter } }),
      prisma.contest.count({ where: { createdAt: dateFilter } }),
      prisma.category.count({ where: { createdAt: dateFilter } }),
      prisma.score.count({ where: { createdAt: dateFilter } }),
      prisma.file.count({ where: { uploadedAt: dateFilter } }),
      prisma.activityLog.count({ where: { createdAt: dateFilter } }),
      prisma.event.count({ where: { createdAt: dateFilter } }),
      prisma.score.count({ where: { createdAt: dateFilter } })
    ])

    // Get user role distribution
    const userRoles = await prisma.user.groupBy({
      by: ['role'],
      _count: { role: true },
      where: { createdAt: dateFilter }
    })

    // Get event status distribution
    const eventStatuses = await prisma.event.groupBy({
      by: ['status'],
      _count: { status: true },
      where: { createdAt: dateFilter }
    })

    // Get file category distribution
    const fileCategories = await prisma.file.groupBy({
      by: ['category'],
      _count: { category: true },
      where: { uploadedAt: dateFilter }
    })

    const analytics = {
      overview: {
        totalUsers,
        totalEvents,
        totalContests,
        totalCategories,
        totalScores,
        totalFiles,
        userActivity,
        eventActivity,
        scoreActivity
      },
      distributions: {
        userRoles: userRoles.map(role => ({
          role: role.role,
          count: role._count.role
        })),
        eventStatuses: eventStatuses.map(status => ({
          status: status.status,
          count: status._count.status
        })),
        fileCategories: fileCategories.map(category => ({
          category: category.category,
          count: category._count.category
        }))
      },
      period: {
        startDate: startDate || null,
        endDate: endDate || null
      }
    }

    if (includeDetails) {
      // Get detailed activity logs
      const activityLogs = await prisma.activityLog.findMany({
        where: { createdAt: dateFilter },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 1000
      })

      analytics.activityLogs = activityLogs.map(log => ({
        id: log.id,
        action: log.action,
        entityType: log.entityType,
        entityId: log.entityId,
        details: log.details,
        user: log.user,
        createdAt: log.createdAt
      }))
    }

    const report = {
      analytics,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `System Analytics Report - ${startDate || 'All Time'}`,
        type: 'SYSTEM_ANALYTICS',
        parameters: JSON.stringify({ startDate, endDate, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'System analytics report generated successfully'
    })
  } catch (error) {
    log.error('Generate system analytics report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get all reports
const getAllReports = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { page = 1, limit = 10, type, status } = req.query

    const whereClause = {
      ...(type && { type }),
      ...(status && { status })
    }

    const reports = await prisma.report.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: parseInt(limit)
    })

    const totalReports = await prisma.report.count({ where: whereClause })

    res.json({
      data: reports.map(report => ({
        ...report,
        generatedBy: report.user ? {
          name: report.user.preferredName || report.user.name,
          email: report.user.email
        } : null,
        createdBy: report.user ? {
          name: report.user.preferredName || report.user.name,
          email: report.user.email
        } : null
      })),
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReports,
        pages: Math.ceil(totalReports / limit)
      }
    })
  } catch (error) {
    log.error('Get all reports error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get report by ID
const getReportById = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    const report = await prisma.report.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    res.json(report)
  } catch (error) {
    log.error('Get report by ID error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete report
const deleteReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    const report = await prisma.report.findUnique({
      where: { id }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Delete associated file if exists
    if (report.filePath) {
      try {
        await fs.unlink(report.filePath)
      } catch (error) {
        log.error('Error deleting report file:', error, { error: error.message, stack: error.stack })
      }
    }

    await prisma.report.delete({
      where: { id }
    })

    res.json({ message: 'Report deleted successfully' })
  } catch (error) {
    log.error('Delete report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export report to file
const exportReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params
    const { format = 'JSON' } = req.body

    const report = await prisma.report.findUnique({
      where: { id }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Generate file path
    const fileName = `${report.name.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.${format.toLowerCase()}`
    const filePath = path.join(__dirname, '..', '..', 'reports', fileName)

    // Create reports directory if it doesn't exist
    await fs.mkdir(path.dirname(filePath), { recursive: true })

    // Export based on format
    let fileContent
    switch (format.toUpperCase()) {
      case 'JSON':
        fileContent = JSON.stringify(report, null, 2)
        break
      case 'CSV':
        // Convert report to CSV format
        fileContent = convertToCSV(report)
        break
      case 'XML':
        // Convert report to XML format
        fileContent = convertToXML(report)
        break
      default:
        return res.status(400).json({ error: 'Unsupported export format' })
    }

    // Write file
    await fs.writeFile(filePath, fileContent, 'utf8')

    // Update report with file path
    await prisma.report.update({
      where: { id },
      data: {
        filePath,
        fileSize: fileContent.length,
        status: 'EXPORTED'
      }
    })

    res.json({
      message: 'Report exported successfully',
      filePath,
      fileName,
      fileSize: fileContent.length
    })
  } catch (error) {
    log.error('Export report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper function to convert report to CSV
const convertToCSV = (report) => {
  // Implementation for CSV conversion
  return 'CSV conversion not implemented yet'
}

// Helper function to convert report to XML
const convertToXML = (report) => {
  // Implementation for XML conversion
  return 'XML conversion not implemented yet'
}

// Email report to recipients
const emailReport = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params
    const { recipients, subject, message } = req.body

    if (!recipients || recipients.length === 0) {
      return res.status(400).json({ error: 'Recipients are required' })
    }

    // Get the report instance
    const reportInstance = await prisma.reportHistory.findUnique({
      where: { id },
      include: {
        template: true,
        user: {
          select: {
            name: true,
            email: true
          }
        }
      }
    })

    if (!reportInstance) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Import email controller
    const emailController = require('./emailController')
    
    // Create email content
    const emailContent = `
      <h2>Report: \${reportInstance.name}</h2>
      <p>\${message || 'Please find the attached report.'}</p>
      <hr>
      <p><strong>Report Details:</strong></p>
      <ul>
        <li><strong>Template:</strong> \${reportInstance.template.name}</li>
        <li><strong>Generated By:</strong> \${reportInstance.user.name}</li>
        <li><strong>Generated At:</strong> \${new Date(reportInstance.createdAt).toLocaleString()}</li>
      </ul>
      <p>This report was generated from the Event Manager system.</p>
    `

    // Send email with report attachment
    await emailController.sendReportEmail({
      to: recipients,
      subject: subject || `Report: \${reportInstance.name}`,
      html: emailContent,
      attachments: reportInstance.fileUrl ? [{
        filename: `\${reportInstance.name}.pdf`,
        path: reportInstance.fileUrl
      }] : []
    })

    res.json({
      message: 'Report emailed successfully',
      recipients: recipients.length,
      reportName: reportInstance.name
    })

  } catch (error) {
    log.error('Email report error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Failed to email report' })
  }
}

const getReportInstances = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { search, type, status } = req.query
    
    const where = {}
    if (search) {
      // Search by both name and type
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { type: { contains: search, mode: 'insensitive' } }
      ]
    }
    if (type) {
      if (where.OR) {
        // If we have OR conditions, add type filter with AND
        where.type = type
      } else {
        where.type = type
      }
    }
    
    const instances = await prisma.reportInstance.findMany({
      where,
      include: {
        template: true,
        generatedBy: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      },
      orderBy: { generatedAt: 'desc' }
    })

    // Parse the data field and map instances to include parsed data and proper metadata
    const mappedInstances = instances.map(instance => {
      let parsedData = {}
      try {
        if (instance.data && instance.data !== '{}' && instance.data.trim() !== '') {
          parsedData = JSON.parse(instance.data)
        }
      } catch (parseError) {
        log.warn('Failed to parse report data:', { instanceId: instance.id, error: parseError.message })
        parsedData = { error: 'Failed to parse report data' }
      }

      return {
        id: instance.id,
        name: instance.name,
        type: instance.type,
        format: instance.format,
        generatedAt: instance.generatedAt,
        templateId: instance.templateId,
        generatedBy: instance.generatedBy ? {
          name: instance.generatedBy.preferredName || instance.generatedBy.name,
          email: instance.generatedBy.email
        } : null,
        createdBy: instance.generatedBy ? {
          name: instance.generatedBy.preferredName || instance.generatedBy.name,
          email: instance.generatedBy.email
        } : null,
        // Include parsed data for easier access
        data: parsedData,
        // Also include raw data string for backward compatibility
        rawData: instance.data,
        template: instance.template
      }
    })

    res.json({ data: mappedInstances })
  } catch (error) {
    log.error('Get report instances error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteReportInstance = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    await prisma.reportInstance.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    log.error('Delete report instance error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Send report via email
const sendReportEmail = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  
  // Declare all variables at function scope to avoid ReferenceError in catch block
  let reportInstance = null
  let reportData = null
  let reportBuffer = null
  let reportFilename = 'report'
  let contentType = 'application/pdf'
  let reportName = 'Report'
  let emailRecipients = []
  
  try {
    const { 
      reportId, 
      userId, 
      toEmail, 
      recipients, 
      subject, 
      message,
      templateId, // Optional: email template ID for formatting
      // Optional: generate report on-the-fly
      reportType,
      eventId,
      contestId,
      categoryId,
      format = 'pdf'
    } = req.body

    // Determine recipients
    emailRecipients = []
    
    if (recipients && Array.isArray(recipients)) {
      // Already an array of emails
      emailRecipients = recipients
    } else if (userId) {
      // Get user email
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { email: true, name: true }
      })
      if (!user || !user.email) {
        return res.status(400).json({ error: 'User not found or has no email address' })
      }
      emailRecipients = [user.email]
    } else if (toEmail) {
      // Custom email address
      emailRecipients = [toEmail]
    } else {
      return res.status(400).json({ 
        error: 'Recipients are required. Please provide userId, toEmail, or recipients array.' 
      })
    }

    if (emailRecipients.length === 0) {
      return res.status(400).json({ error: 'No valid email recipients found' })
    }

    // If reportId is provided, use existing report
    if (reportId) {
      reportInstance = await prisma.reportInstance.findUnique({
        where: { id: reportId },
        include: {
          template: true,
          generatedBy: {
            select: {
              name: true,
              email: true
            }
          }
        }
      })

      if (!reportInstance) {
        return res.status(404).json({ error: 'Report not found' })
      }

      const reportFormat = reportInstance.format || format || 'pdf'
      reportFilename = `${reportInstance.name || reportInstance.template?.name || 'report'}-${reportInstance.id}`
      
      // If report has fileUrl, use it, otherwise generate from data
      const fs = require('fs')
      const path = require('path')
      
      if (reportInstance.fileUrl && fs.existsSync(reportInstance.fileUrl)) {
        try {
          reportBuffer = await fs.promises.readFile(reportInstance.fileUrl)
          log.debug('Loaded report from file', { fileUrl: reportInstance.fileUrl, bufferSize: reportBuffer.length })
        } catch (fileError) {
          log.warn('Failed to read report file, will generate from data', { fileUrl: reportInstance.fileUrl, error: fileError.message })
          // Fall through to generate from data
        }
      }
      
      // If buffer still not loaded, generate from data
      if (!reportBuffer && reportInstance.data) {
        try {
          // Generate report from stored data
          reportData = typeof reportInstance.data === 'string' 
            ? JSON.parse(reportInstance.data)
            : reportInstance.data
          
          log.debug('Generating report buffer from data', { 
            format: reportFormat, 
            hasData: !!reportData,
            dataType: typeof reportData,
            dataKeys: reportData ? Object.keys(reportData) : [],
            hasEvent: !!reportData?.event,
            hasContest: !!reportData?.contest,
            hasCategory: !!reportData?.category,
            reportType: reportData?.reportType
          })
          
          // Check if reportData actually has content or is just template metadata
          const hasActualData = reportData && (
            reportData.event || 
            reportData.contest || 
            reportData.category || 
            reportData.contestants ||
            reportData.judge ||
            reportData.overview ||
            (reportData.reportType && reportData.reportType !== 'general')
          )
          
          if (!hasActualData) {
            log.warn('Report data appears to be empty or only template metadata, attempting to regenerate', {
              reportId: reportId,
              reportType: reportInstance.type,
              dataKeys: reportData ? Object.keys(reportData) : []
            })
            
            // Try to extract event/contest/category IDs and other parameters from stored data first
            let extractedEventId = reportData?.eventId || reportData?.event?.id
            let extractedContestId = reportData?.contestId || reportData?.contest?.id
            let extractedCategoryId = reportData?.categoryId || reportData?.category?.id
            let extractedStartDate = reportData?.dateRange?.startDate || reportData?.startDate
            let extractedEndDate = reportData?.dateRange?.endDate || reportData?.endDate
            let extractedJudgeId = reportData?.judgeId || reportData?.judge?.id
            let extractedContestantId = reportData?.contestantId || reportData?.contestant?.id
            
            // If not found in parsed data, try to extract from reportInstance.data string
            if (!extractedEventId || !extractedContestId || !extractedCategoryId) {
              try {
                const rawDataStr = typeof reportInstance.data === 'string' ? reportInstance.data : JSON.stringify(reportInstance.data)
                // Try to extract IDs using regex from the JSON string
                const eventIdMatch = rawDataStr.match(/"eventId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"id"\s*:\s*"([^"]+)"[^}]*"name"[^}]*"event/i)
                const contestIdMatch = rawDataStr.match(/"contestId"\s*:\s*"([^"]+)"/)
                const categoryIdMatch = rawDataStr.match(/"categoryId"\s*:\s*"([^"]+)"/)
                
                if (eventIdMatch && !extractedEventId) extractedEventId = eventIdMatch[1]
                if (contestIdMatch && !extractedContestId) extractedContestId = contestIdMatch[1]
                if (categoryIdMatch && !extractedCategoryId) extractedCategoryId = categoryIdMatch[1]
                
                log.debug('Extracted IDs from raw data:', { extractedEventId, extractedContestId, extractedCategoryId })
              } catch (extractError) {
                log.warn('Failed to extract IDs from raw data:', extractError.message)
              }
            }
            
            const reportTypeFromInstance = reportInstance.type || 'EVENT_SUMMARY'
            
            // Create regenerate request with extracted IDs and parameters
            const regenerateReq = { 
              ...req, 
              body: { 
                reportType: reportTypeFromInstance,
                eventId: extractedEventId,
                contestId: extractedContestId,
                categoryId: extractedCategoryId,
                startDate: extractedStartDate,
                endDate: extractedEndDate,
                judgeId: extractedJudgeId,
                contestantId: extractedContestantId,
                parameters: {
                  startDate: extractedStartDate,
                  endDate: extractedEndDate,
                  judgeId: extractedJudgeId,
                  contestantId: extractedContestantId
                }
              } 
            }
            
            log.info('Attempting to regenerate report:', {
              reportType: reportTypeFromInstance,
              eventId: extractedEventId,
              contestId: extractedContestId,
              categoryId: extractedCategoryId
            })
            
            try {
              reportData = await generateReportData(regenerateReq)
              log.info('‚úÖ Successfully regenerated report data', {
                hasEvent: !!reportData.event,
                hasContest: !!reportData.contest,
                reportType: reportData.reportType
              })
            } catch (regenError) {
              log.error('Failed to regenerate report data:', regenError)
              // Fall through to try using the original (even if empty) data
            }
          }
          
          // Generate report buffer based on format
          if (reportFormat === 'pdf' || format === 'pdf') {
            reportBuffer = await generatePDFBuffer(reportData)
            contentType = 'application/pdf'
            reportFilename += '.pdf'
          } else if (reportFormat === 'excel' || format === 'excel' || format === 'xlsx') {
            reportBuffer = await generateExcelBuffer(reportData)
            contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            reportFilename += '.xlsx'
          } else if (reportFormat === 'csv' || format === 'csv') {
            reportBuffer = await generateCSVBuffer(reportData)
            contentType = 'text/csv'
            reportFilename += '.csv'
          } else {
            log.warn('Unknown report format, defaulting to PDF', { format: reportFormat })
            reportBuffer = await generatePDFBuffer(reportData)
            contentType = 'application/pdf'
            reportFilename += '.pdf'
          }
          
          log.debug('Report buffer generated', { bufferSize: reportBuffer?.length, format: reportFormat })
        } catch (parseError) {
          log.error('Failed to parse or generate report', { 
            error: parseError.message, 
            stack: parseError.stack,
            dataLength: reportInstance.data?.length,
            dataType: typeof reportInstance.data,
            reportId: reportId
          })
          
          // Try to regenerate the report instead of failing
          log.info('Attempting to regenerate report as fallback')
          try {
            // Try to extract IDs and parameters from the parsed data or raw string
            let extractedEventId, extractedContestId, extractedCategoryId, extractedStartDate, extractedEndDate, extractedJudgeId, extractedContestantId
            try {
              const rawDataStr = typeof reportInstance.data === 'string' ? reportInstance.data : JSON.stringify(reportInstance.data || '{}')
              const eventIdMatch = rawDataStr.match(/"eventId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"event"\s*:\s*{[^}]*"id"\s*:\s*"([^"]+)"/)
              const contestIdMatch = rawDataStr.match(/"contestId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"contest"\s*:\s*{[^}]*"id"\s*:\s*"([^"]+)"/)
              const categoryIdMatch = rawDataStr.match(/"categoryId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"category"\s*:\s*{[^}]*"id"\s*:\s*"([^"]+)"/)
              const startDateMatch = rawDataStr.match(/"startDate"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"dateRange"\s*:\s*{[^}]*"startDate"\s*:\s*"([^"]+)"/)
              const endDateMatch = rawDataStr.match(/"endDate"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"dateRange"\s*:\s*{[^}]*"endDate"\s*:\s*"([^"]+)"/)
              const judgeIdMatch = rawDataStr.match(/"judgeId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"judge"\s*:\s*{[^}]*"id"\s*:\s*"([^"]+)"/)
              const contestantIdMatch = rawDataStr.match(/"contestantId"\s*:\s*"([^"]+)"/) || rawDataStr.match(/"contestant"\s*:\s*{[^}]*"id"\s*:\s*"([^"]+)"/)
              
              if (eventIdMatch) extractedEventId = eventIdMatch[1]
              if (contestIdMatch) extractedContestId = contestIdMatch[1]
              if (categoryIdMatch) extractedCategoryId = categoryIdMatch[1]
              if (startDateMatch) extractedStartDate = startDateMatch[1]
              if (endDateMatch) extractedEndDate = endDateMatch[1]
              if (judgeIdMatch) extractedJudgeId = judgeIdMatch[1]
              if (contestantIdMatch) extractedContestantId = contestantIdMatch[1]
            } catch (extractError) {
              log.warn('Could not extract IDs from report data for fallback regeneration')
            }
            
            const reportTypeFromInstance = reportInstance.type || 'EVENT_SUMMARY'
            const regenerateReq = { 
              ...req, 
              body: { 
                reportType: reportTypeFromInstance,
                eventId: extractedEventId,
                contestId: extractedContestId,
                categoryId: extractedCategoryId,
                startDate: extractedStartDate,
                endDate: extractedEndDate,
                judgeId: extractedJudgeId,
                contestantId: extractedContestantId,
                parameters: {
                  startDate: extractedStartDate,
                  endDate: extractedEndDate,
                  judgeId: extractedJudgeId,
                  contestantId: extractedContestantId
                }
              } 
            }
            reportData = await generateReportData(regenerateReq)
            
            // Generate buffer from regenerated data
            const reportFormatFallback = reportInstance.format || format || 'pdf'
            if (reportFormatFallback === 'pdf' || reportFormatFallback === 'pdf') {
              reportBuffer = await generatePDFBuffer(reportData)
              contentType = 'application/pdf'
              reportFilename += '.pdf'
            } else if (reportFormatFallback === 'excel' || reportFormatFallback === 'xlsx') {
              reportBuffer = await generateExcelBuffer(reportData)
              contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
              reportFilename += '.xlsx'
            } else {
              reportBuffer = await generatePDFBuffer(reportData)
              contentType = 'application/pdf'
              reportFilename += '.pdf'
            }
            log.info('‚úÖ Successfully regenerated and generated report buffer as fallback')
          } catch (regenError) {
            log.error('Failed to regenerate report as fallback:', regenError)
            return res.status(500).json({ error: 'Failed to generate report from data', details: parseError.message })
          }
        }
      } else if (!reportBuffer) {
        log.error('No report data available', { 
          hasFileUrl: !!reportInstance.fileUrl,
          hasData: !!reportInstance.data,
          dataLength: reportInstance.data?.length
        })
        return res.status(500).json({ error: 'Report has no data or file available' })
      }
    } else if (reportType) {
      // Generate report on-the-fly
      const { startDate, endDate, judgeId, contestantId } = req.body
      const generateReq = { 
        ...req, 
        body: { 
          reportType, 
          eventId, 
          contestId, 
          categoryId, 
          startDate,
          endDate,
          judgeId,
          contestantId,
          format,
          parameters: {
            startDate,
            endDate,
            judgeId,
            contestantId
          }
        } 
      }
      reportData = await generateReportData(generateReq)
      
      // Generate report buffer
      if (format === 'pdf') {
        reportBuffer = await generatePDFBuffer(reportData)
        contentType = 'application/pdf'
        reportFilename = `${reportType}-report-${Date.now()}.pdf`
      } else if (format === 'excel' || format === 'xlsx') {
        reportBuffer = await generateExcelBuffer(reportData)
        contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        reportFilename = `${reportType}-report-${Date.now()}.xlsx`
      } else if (format === 'csv') {
        reportBuffer = await generateCSVBuffer(reportData)
        contentType = 'text/csv'
        reportFilename = `${reportType}-report-${Date.now()}.csv`
      }
    } else {
      return res.status(400).json({ 
        error: 'Either reportId or reportType must be provided' 
      })
    }

    // Generate email content - check if templateId is provided
    // Note: templateId is already extracted from req.body at the top of the function
    reportName = reportInstance?.name || reportInstance?.template?.name || `${reportType || 'Report'} Report`
    const generatedBy = reportInstance?.generatedBy?.preferredName || reportInstance?.generatedBy?.name || req.user?.preferredName || req.user?.name || 'System'
    const generatedAt = reportInstance?.generatedAt || new Date()
    
    let emailContent = null
    let emailSubject = subject || `Report: ${reportName}`
    
    // Log templateId if provided for debugging
    if (templateId) {
      log.info('Email template ID provided', { templateId, reportId, reportName })
    } else {
      log.debug('No email template ID provided, using default format', { reportId, reportName })
    }
    
    // If templateId is provided, render using email template
    if (templateId) {
      try {
        const emailTemplate = await prisma.emailTemplate.findUnique({
          where: { id: templateId }
        })
        
        if (emailTemplate) {
          log.info('Email template found, rendering with template', { 
            templateId, 
            templateName: emailTemplate.name,
            hasHeader: !!emailTemplate.headerHtml,
            hasFooter: !!emailTemplate.footerHtml,
            hasLogo: !!emailTemplate.logoUrl,
            hasBody: !!emailTemplate.body
          })
          
          // Prepare variables for template
          const templateVariables = {
            reportName,
            generatedBy,
            generatedAt: new Date(generatedAt).toLocaleString(),
            message: message || 'Please find the attached report.',
            // Add report data variables if available
            eventName: reportData?.event?.name || null,
            contestName: reportData?.contest?.name || null,
            categoryName: reportData?.category?.name || null
          }
          
          log.debug('Template variables prepared', { 
            variableKeys: Object.keys(templateVariables),
            hasMessage: !!message,
            hasEventName: !!templateVariables.eventName,
            hasContestName: !!templateVariables.contestName
          })
          
          // Render email content using template
          emailContent = renderEmailTemplate(emailTemplate, templateVariables)
          
          if (emailContent) {
            log.info('Email template rendered successfully', { 
              templateId,
              contentLength: emailContent.length,
              hasContent: !!emailContent
            })
          } else {
            log.warn('Email template rendered but content is empty', { templateId })
          }
          
          // If template has a subject, use it (replace variables)
          if (emailTemplate.subject) {
            let processedSubject = emailTemplate.subject
            Object.keys(templateVariables).forEach(key => {
              const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
              processedSubject = processedSubject.replace(regex, templateVariables[key] || '')
            })
            emailSubject = processedSubject
            log.info('Using template subject', { 
              originalSubject: subject, 
              templateSubject: emailSubject,
              templateId
            })
          } else {
            log.debug('Template has no subject, using provided subject', { 
              subject: emailSubject,
              templateId
            })
          }
        } else {
          log.warn('Email template not found in database', { templateId })
        }
      } catch (templateError) {
        log.error('Failed to render email template:', templateError, { templateId, error: templateError.message })
      }
    }
    
    // Fallback to default email content if no template or template rendering failed
    if (!emailContent) {
      log.debug('Using default email content (no template or template rendering failed)', {
        hadTemplateId: !!templateId,
        templateId: templateId || null
      })
      emailContent = `
        <h2>Report: ${reportName}</h2>
        <p>Generated by: ${generatedBy}</p>
        <p>Generated at: ${new Date(generatedAt).toLocaleString()}</p>
        ${message ? `<p>${message}</p>` : '<p>Please find the attached report.</p>'}
        <hr>
        <p><small>This report was generated from the Event Manager system.</small></p>
      `
    }
    
    // Final log before sending
    log.info('Email prepared, ready to send', {
      hasContent: !!emailContent,
      contentLength: emailContent ? emailContent.length : 0,
      subject: emailSubject,
      recipientsCount: emailRecipients.length,
      usedTemplate: !!templateId && emailContent && !emailContent.includes('<h2>Report:'), // Simple check if template was used
      templateId: templateId || null
    })

    // Validate report buffer before sending
    if (!reportBuffer || !Buffer.isBuffer(reportBuffer)) {
      log.error('Invalid report buffer generated', {
        hasBuffer: !!reportBuffer,
        isBuffer: Buffer.isBuffer(reportBuffer),
        reportId: reportId,
        reportType: reportType
      })
      return res.status(500).json({ error: 'Failed to generate report buffer' })
    }
    
    // Send email with report attachment (use emailSubject which may have been set by template)
    const emailService = require('./emailController')
    const emailResult = await emailService.sendReportEmail({
      to: emailRecipients,
      subject: emailSubject,
      reportData: reportBuffer,
      filename: reportFilename,
      contentType: contentType,
      html: emailContent
    }, req)

    // Log email status for each recipient
    for (const recipient of emailRecipients) {
      try {
        await prisma.emailLog.create({
          data: {
            to: recipient,
            subject: emailSubject,
            status: emailResult.success ? 'SENT' : 'FAILED',
            sentAt: new Date(),
            messageId: emailResult.messageId || null,
            errorMessage: emailResult.error || null
          }
        })
      } catch (logError) {
        // Email logging is optional, don't fail the request if it fails
        log.warn('Failed to log email:', logError.message)
      }
    }

    res.json({
      message: 'Report emailed successfully',
      recipients: emailRecipients,
      recipientCount: emailRecipients.length,
      reportName: reportName,
      messageId: emailResult.messageId
    })
  } catch (error) {
    log.error('Send report email error:', error, { 
      error: error.message, 
      stack: error.stack,
      reportId: req.body?.reportId,
      reportType: req.body?.reportType,
      recipients: req.body?.toEmail || req.body?.recipients || req.body?.userId,
      hasReportBuffer: reportBuffer !== null && reportBuffer !== undefined,
      reportBufferSize: reportBuffer && Buffer.isBuffer(reportBuffer) ? reportBuffer.length : null
    })
    
    // Log failed email - use existing emailRecipients or extract from request
    if (emailRecipients.length === 0) {
      if (req.body?.toEmail) {
        emailRecipients = Array.isArray(req.body.toEmail) ? req.body.toEmail : [req.body.toEmail]
      } else if (req.body?.recipients) {
        emailRecipients = Array.isArray(req.body.recipients) ? req.body.recipients : [req.body.recipients]
      } else if (req.body?.userId) {
        try {
          const user = await prisma.user.findUnique({
            where: { id: req.body.userId },
            select: { email: true }
          })
          if (user?.email) {
            emailRecipients = [user.email]
          }
        } catch (userError) {
          log.warn('Failed to get user email for logging', { userId: req.body.userId, error: userError.message })
        }
      }
      
      if (emailRecipients.length === 0) {
        emailRecipients = ['unknown']
      }
    }
    
    for (const recipient of emailRecipients) {
      try {
        await prisma.emailLog.create({
          data: {
            to: recipient,
            subject: req.body?.subject || 'Report Email',
            status: 'FAILED',
            sentAt: new Date(),
            errorMessage: error.message
          }
        })
      } catch (logError) {
        // Email logging is optional
        log.warn('Failed to log email error:', logError.message)
      }
    }
    
    // Provide more detailed error message for debugging
    const errorMessage = error.message || 'Unknown error occurred'
    const isSmtpError = errorMessage.includes('SMTP') || errorMessage.includes('smtp') || errorMessage.includes('transporter') || errorMessage.includes('settings not configured')
    
    res.status(500).json({ 
      error: 'Failed to send report email',
      message: errorMessage,
      details: process.env.NODE_ENV === 'development' ? {
        stack: error.stack,
        reportId: req.body?.reportId,
        hasReportBuffer: reportBuffer !== null && reportBuffer !== undefined
      } : undefined,
      suggestion: isSmtpError ? 'Please check SMTP settings in System Settings > Email Settings' : undefined
    })
  }
}

// Helper function to render email template with layout and formatting
const renderEmailTemplate = (template, variables = {}) => {
  try {
    // Build CSS styles from template settings
    const styles = []
    if (template.backgroundColor) styles.push(`background-color: ${template.backgroundColor}`)
    if (template.textColor) styles.push(`color: ${template.textColor}`)
    if (template.fontFamily) styles.push(`font-family: ${template.fontFamily}`)
    if (template.fontSize) styles.push(`font-size: ${template.fontSize}`)
    if (template.borderStyle) styles.push(`border-style: ${template.borderStyle}`)
    if (template.borderColor) styles.push(`border-color: ${template.borderColor}`)
    if (template.borderWidth) styles.push(`border-width: ${template.borderWidth}`)
    if (template.borderRadius) styles.push(`border-radius: ${template.borderRadius}`)
    if (template.padding) styles.push(`padding: ${template.padding}`)
    if (template.margin) styles.push(`margin: ${template.margin}`)
    
    const styleString = styles.length > 0 ? ` style="${styles.join('; ')}"` : ''
    
    // Build logo HTML if provided
    let logoHtml = ''
    if (template.logoUrl) {
      const logoAlign = template.logoPosition === 'top-center' ? 'center' : 
                        template.logoPosition === 'top-right' ? 'right' : 'left'
      logoHtml = `<div style="text-align: ${logoAlign}; margin-bottom: 20px;">
        <img src="${template.logoUrl}" alt="Logo" style="max-width: 200px; height: auto;" />
      </div>`
    }
    
    // Replace variables in subject if provided
    let processedSubject = template.subject || 'Report'
    Object.keys(variables).forEach(key => {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
      processedSubject = processedSubject.replace(regex, variables[key] || '')
    })
    
    // Replace variables in header HTML
    let processedHeader = template.headerHtml || ''
    Object.keys(variables).forEach(key => {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
      processedHeader = processedHeader.replace(regex, variables[key] || '')
    })
    
    // Process body content
    let processedBody = template.body || ''
    Object.keys(variables).forEach(key => {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
      processedBody = processedBody.replace(regex, variables[key] || '')
    })
    
    // Replace variables in footer HTML
    let processedFooter = template.footerHtml || ''
    Object.keys(variables).forEach(key => {
      const regex = new RegExp(`\\{\\{${key}\\}\\}`, 'g')
      processedFooter = processedFooter.replace(regex, variables[key] || '')
    })
    
    // Build main content - use contentWrapper if provided, otherwise use body
    let mainContent = processedBody
    if (template.contentWrapper) {
      const wrapperContent = template.contentWrapper.replace(/\{\{content\}\}/g, processedBody || '')
      mainContent = wrapperContent
    }
    
    // Build complete email HTML with template structure
    const layoutClass = template.layoutType || 'single-column'
    const primaryColorStyle = template.primaryColor ? ` color: ${template.primaryColor};` : ''
    
    const emailHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: ${template.fontFamily || 'Arial, sans-serif'};
      font-size: ${template.fontSize || '14px'};
      color: ${template.textColor || '#000000'};
      background-color: ${template.backgroundColor || '#ffffff'};
    }
    .email-container {
      max-width: 600px;
      margin: 0 auto;
      ${template.backgroundColor ? `background-color: ${template.backgroundColor};` : ''}
      ${template.borderStyle && template.borderColor && template.borderWidth ? 
        `border: ${template.borderWidth} ${template.borderStyle} ${template.borderColor};` : ''}
      ${template.borderRadius ? `border-radius: ${template.borderRadius};` : ''}
      ${template.padding ? `padding: ${template.padding};` : 'padding: 20px;'}
      ${template.margin ? `margin: ${template.margin};` : ''}
    }
    .email-header {
      ${template.primaryColor ? `color: ${template.primaryColor};` : ''}
      margin-bottom: 20px;
    }
    .email-body {
      line-height: 1.6;
      margin: 20px 0;
    }
    .email-footer {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid ${template.borderColor || '#e5e7eb'};
      font-size: 12px;
      color: #666;
    }
    ${template.layoutType === 'two-column' ? `
    .content-columns {
      display: table;
      width: 100%;
    }
    .content-left {
      display: table-cell;
      width: 60%;
      padding-right: 15px;
    }
    .content-right {
      display: table-cell;
      width: 40%;
      padding-left: 15px;
    }
    ` : ''}
  </style>
</head>
<body>
  <div class="email-container">
    ${logoHtml}
    ${processedHeader ? `<div class="email-header">${processedHeader}</div>` : ''}
    <div class="email-body">
      ${mainContent}
    </div>
    ${processedFooter ? `<div class="email-footer">${processedFooter}</div>` : ''}
  </div>
</body>
</html>
    `
    
    return emailHtml
  } catch (error) {
    console.error('Error rendering email template:', error)
    // Return minimal fallback HTML
    return `
      <html>
        <body>
          <p>${variables.message || 'Please find the attached report.'}</p>
        </body>
      </html>
    `
  }
}

// Helper function to generate report data (used for email regeneration)
// This calls the main generateReport logic to ensure all report types are handled correctly
const generateReportData = async (req) => {
  const log = createRequestLogger(req, 'reports')
  const { reportType, eventId, contestId, categoryId, startDate, endDate, judgeId, contestantId, format } = req.body
  
  // Create a mock response object to capture the report data
  let capturedReportData = null
  const mockRes = {
    json: (data) => {
      capturedReportData = data.data || data
      return mockRes
    },
    status: (code) => {
      return mockRes
    }
  }
  
  // Use the main generateReport logic to ensure all report types are handled
  // We'll call it synchronously by creating a new request with all parameters
  const generateReq = {
    ...req,
    body: {
      reportType,
      eventId,
      contestId,
      categoryId,
      startDate,
      endDate,
      judgeId,
      contestantId,
      format: format || 'pdf',
      // Include parameters if they exist
      parameters: req.body.parameters || {
        startDate,
        endDate,
        judgeId,
        contestantId
      }
    }
  }
  
  try {
    // Call the main generateReport function's internal logic
    // Instead of calling generateReport directly (which sends a response), we'll replicate its core logic
    const bodyParams = generateReq.body
    const parameters = bodyParams.parameters || {}
    
    // Fetch app name from settings
    const appNameSetting = await prisma.systemSetting.findFirst({
      where: { key: 'app_name' }
    })
    const appName = appNameSetting?.value || 'Event Manager'
    
    let reportData = {
      reportType: reportType || 'general',
      generatedAt: new Date(),
      generatedBy: req.user?.id || 'system',
      appName: appName
    }
    
    // Handle SYSTEM_ANALYTICS report type
    if (reportType === 'SYSTEM_ANALYTICS') {
      const startDate = bodyParams.startDate || parameters?.startDate
      const endDate = bodyParams.endDate || parameters?.endDate
      
      const dateFilter = {}
      if (startDate) dateFilter.gte = new Date(startDate)
      if (endDate) dateFilter.lte = new Date(endDate)
      
      // Get system statistics
      const [
        totalUsers,
        totalEvents,
        totalContests,
        totalCategories,
        totalScores,
        totalFiles,
        userActivity
      ] = await Promise.all([
        prisma.user.count(),
        prisma.event.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
        prisma.contest.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
        prisma.category.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
        prisma.score.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} }),
        prisma.file.count({ where: Object.keys(dateFilter).length > 0 ? { uploadedAt: dateFilter } : {} }),
        prisma.activityLog.count({ where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {} })
      ])
      
      // Get user role distribution
      const userRoles = await prisma.user.groupBy({
        by: ['role'],
        _count: { role: true },
        where: Object.keys(dateFilter).length > 0 ? { createdAt: dateFilter } : {}
      })
      
      reportData.overview = {
        totalUsers,
        totalEvents,
        totalContests,
        totalCategories,
        totalScores,
        totalFiles,
        userActivity
      }
      reportData.distributions = {
        userRoles: userRoles.map(r => ({ role: r.role, count: r._count.role }))
      }
      reportData.dateRange = { startDate, endDate }
      reportData.title = `System Analytics${startDate || endDate ? ` (${startDate || 'All Time'} - ${endDate || 'Now'})` : ' (All Time)'}`
      reportData.reportType = 'SYSTEM_ANALYTICS'
    }
    // Handle JUDGE_PERFORMANCE report type
    else if (reportType === 'JUDGE_PERFORMANCE') {
      // Extract judgeId and eventId
      const judgeId = bodyParams.judgeId || parameters?.judgeId
      const eventIdForJudge = bodyParams.eventId || parameters?.eventId || eventId
      
      if (!eventIdForJudge) {
        throw new Error('Event ID is required for Judge Performance reports')
      }
      
      if (!judgeId) {
        throw new Error('Judge ID is required for Judge Performance reports')
      }
      
      // Fetch judge data - similar to main generateReport logic
      const judge = await prisma.user.findUnique({
        where: { id: judgeId },
        include: {
          judge: true
        }
      })
      
      if (!judge || !judge.judge) {
        throw new Error('Judge not found')
      }
      
      // Fetch scores for this judge in this event
      const scores = await prisma.score.findMany({
        where: {
          judgeId: judge.judge.id,
          category: {
            contest: {
              eventId: eventIdForJudge
            }
          }
        },
        include: {
          category: {
            include: {
              contest: {
                include: {
                  event: true
                }
              }
            }
          },
          contestant: true,
          criterion: true
        }
      })
      
      reportData.judge = {
        id: judge.id,
        name: judge.preferredName || judge.name,
        email: judge.email,
        role: judge.role
      }
      reportData.scores = scores
      reportData.title = `Judge Performance Report: ${judge.preferredName || judge.name}`
      reportData.reportType = 'JUDGE_PERFORMANCE'
    }
    // Handle other report types with event/contest/category data
    else {
      // Fetch data based on provided IDs - priority: categoryId > contestId > eventId
      if (categoryId) {
        const category = await prisma.category.findUnique({
          where: { id: categoryId },
          include: {
            contest: {
              include: {
                event: {
                  select: { id: true, name: true, startDate: true, endDate: true }
                }
              }
            },
            scores: {
              include: {
                judge: {
                  select: { name: true }
                },
                contestant: {
                  select: { name: true, contestantNumber: true }
                },
                criterion: {
                  select: { name: true, maxScore: true }
                }
              }
            }
          }
        })
        if (category) {
          reportData.category = category
          reportData.contest = category.contest
          reportData.event = category.contest?.event
          reportData.title = `Category Report: ${category.name}`
          reportData.reportType = reportType || 'CATEGORY'
        }
      } else if (contestId) {
        const contest = await prisma.contest.findUnique({
          where: { id: contestId },
          include: {
            event: {
              select: { id: true, name: true, startDate: true, endDate: true }
            },
            categories: {
              include: {
                scores: {
                  include: {
                    judge: {
                      select: { name: true }
                    },
                    contestant: {
                      select: { name: true, contestantNumber: true }
                    },
                    criterion: {
                      select: { name: true, maxScore: true }
                    }
                  }
                }
              }
            }
          }
        })
        if (contest) {
          reportData.contest = contest
          reportData.event = contest.event
          reportData.title = `Contest Results: ${contest.name}`
          reportData.reportType = reportType === 'EVENT_SUMMARY' ? 'EVENT_SUMMARY' : 'CONTEST_RESULTS'
        }
      } else if (eventId) {
        const event = await prisma.event.findUnique({
          where: { id: eventId },
          include: {
            contests: {
              include: {
                categories: {
                  include: {
                    scores: {
                      include: {
                        judge: {
                          select: { name: true }
                        },
                        contestant: {
                          select: { name: true, contestantNumber: true }
                        },
                        criterion: {
                          select: { name: true, maxScore: true }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        })
        if (event) {
          reportData.event = event
          reportData.title = `Event Summary: ${event.name}`
          reportData.reportType = reportType || 'EVENT_SUMMARY'
        }
      }
    }
    
    return reportData
  } catch (error) {
    log.error('Error in generateReportData helper:', error, { error: error.message, stack: error.stack })
    throw error
  }
}

// Helper functions to generate report buffers
const generatePDFBuffer = async (reportData) => {
  return new Promise((resolve, reject) => {
    const PDFDocument = require('pdfkit')
    const doc = new PDFDocument({ size: 'A4', margin: 50 })
    const chunks = []
    
    doc.on('data', chunk => chunks.push(chunk))
    doc.on('end', () => resolve(Buffer.concat(chunks)))
    doc.on('error', reject)
    
    // Add report content
    const title = reportData.title || 'Report'
    const appName = reportData.appName || 'Event Manager'
    doc.fontSize(20).font('Helvetica-Bold').text(title, { align: 'center' })
    doc.moveDown(0.5)
    doc.fontSize(12).font('Helvetica').text(appName, { align: 'center' })
    doc.moveDown(0.5)
    doc.fontSize(10).font('Helvetica').text(`Type: ${reportData.reportType}`, { align: 'left' })
    doc.moveDown(0.5)
    doc.text(`Generated: ${new Date(reportData.generatedAt || new Date()).toLocaleString()}`, { align: 'left' })
    doc.moveDown()
    
    // Add report-specific content
    // Handle SYSTEM_ANALYTICS first
    if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
      doc.fontSize(14).font('Helvetica-Bold').text('Overview Statistics', { align: 'left' })
      doc.fontSize(10).font('Helvetica')
      const overview = reportData.overview
      doc.text(`Total Users: ${overview.totalUsers || 0}`)
      doc.text(`Total Events: ${overview.totalEvents || 0}`)
      doc.text(`Total Contests: ${overview.totalContests || 0}`)
      doc.text(`Total Categories: ${overview.totalCategories || 0}`)
      doc.text(`Total Scores: ${overview.totalScores || 0}`)
      doc.text(`Total Files: ${overview.totalFiles || 0}`)
      doc.text(`User Activity: ${overview.userActivity || 0}`)
      
      if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
        doc.moveDown()
        if (reportData.dateRange.startDate) {
          doc.text(`Period Start: ${new Date(reportData.dateRange.startDate).toLocaleDateString()}`)
        }
        if (reportData.dateRange.endDate) {
          doc.text(`Period End: ${new Date(reportData.dateRange.endDate).toLocaleDateString()}`)
        }
      }
      
      if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
        doc.moveDown()
        doc.fontSize(12).font('Helvetica-Bold').text('User Role Distribution')
        doc.fontSize(10).font('Helvetica')
        reportData.distributions.userRoles.forEach((role) => {
          doc.text(`${role.role}: ${role.count}`)
        })
      }
    } else if (reportData.event) {
      doc.fontSize(14).font('Helvetica-Bold').text(`Event: ${reportData.event.name}`)
      doc.moveDown()
    } else if (reportData.contest) {
      doc.fontSize(14).font('Helvetica-Bold').text(`Contest: ${reportData.contest.name}`)
      doc.moveDown()
    } else if (reportData.category) {
      doc.fontSize(14).font('Helvetica-Bold').text(`Category: ${reportData.category.name}`)
      doc.moveDown()
    }
    
    doc.end()
  })
}

const generateExcelBuffer = async (reportData) => {
  const ExcelJS = require('exceljs')
  const workbook = new ExcelJS.Workbook()
  const worksheet = workbook.addWorksheet('Report')
  
  worksheet.columns = [
    { header: 'Field', key: 'field', width: 20 },
    { header: 'Value', key: 'value', width: 40 }
  ]
  
  worksheet.addRow({ field: 'Report Type', value: reportData.reportType })
  worksheet.addRow({ field: 'Generated At', value: new Date(reportData.generatedAt || new Date()).toLocaleString() })
  
  // Handle SYSTEM_ANALYTICS first
  if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
    worksheet.addRow([])
    worksheet.addRow({ field: 'Overview Statistics', value: '' })
    const overview = reportData.overview
    worksheet.addRow({ field: 'Total Users', value: overview.totalUsers || 0 })
    worksheet.addRow({ field: 'Total Events', value: overview.totalEvents || 0 })
    worksheet.addRow({ field: 'Total Contests', value: overview.totalContests || 0 })
    worksheet.addRow({ field: 'Total Categories', value: overview.totalCategories || 0 })
    worksheet.addRow({ field: 'Total Scores', value: overview.totalScores || 0 })
    worksheet.addRow({ field: 'Total Files', value: overview.totalFiles || 0 })
    worksheet.addRow({ field: 'User Activity', value: overview.userActivity || 0 })
    
    if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
      worksheet.addRow([])
      if (reportData.dateRange.startDate) {
        worksheet.addRow({ field: 'Period Start', value: new Date(reportData.dateRange.startDate).toLocaleDateString() })
      }
      if (reportData.dateRange.endDate) {
        worksheet.addRow({ field: 'Period End', value: new Date(reportData.dateRange.endDate).toLocaleDateString() })
      }
    }
    
    if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
      worksheet.addRow([])
      worksheet.addRow({ field: 'User Role Distribution', value: '' })
      reportData.distributions.userRoles.forEach((role) => {
        worksheet.addRow({ field: role.role, value: role.count })
      })
    }
  } else if (reportData.event) {
    worksheet.addRow({ field: 'Event', value: reportData.event.name })
  }
  if (reportData.contest) {
    worksheet.addRow({ field: 'Contest', value: reportData.contest.name })
  }
  if (reportData.category) {
    worksheet.addRow({ field: 'Category', value: reportData.category.name })
  }
  
  return await workbook.xlsx.writeBuffer()
}

const generateCSVBuffer = async (reportData) => {
  const csvRows = []
  csvRows.push(['Field', 'Value'])
  csvRows.push(['Report Type', reportData.reportType])
  csvRows.push(['Generated At', new Date(reportData.generatedAt || new Date()).toLocaleString()])
  
  // Handle SYSTEM_ANALYTICS first
  if (reportData.reportType === 'SYSTEM_ANALYTICS' && reportData.overview) {
    csvRows.push([])
    csvRows.push(['Overview Statistics', ''])
    const overview = reportData.overview
    csvRows.push(['Total Users', overview.totalUsers || 0])
    csvRows.push(['Total Events', overview.totalEvents || 0])
    csvRows.push(['Total Contests', overview.totalContests || 0])
    csvRows.push(['Total Categories', overview.totalCategories || 0])
    csvRows.push(['Total Scores', overview.totalScores || 0])
    csvRows.push(['Total Files', overview.totalFiles || 0])
    csvRows.push(['User Activity', overview.userActivity || 0])
    
    if (reportData.dateRange && (reportData.dateRange.startDate || reportData.dateRange.endDate)) {
      csvRows.push([])
      if (reportData.dateRange.startDate) {
        csvRows.push(['Period Start', new Date(reportData.dateRange.startDate).toLocaleDateString()])
      }
      if (reportData.dateRange.endDate) {
        csvRows.push(['Period End', new Date(reportData.dateRange.endDate).toLocaleDateString()])
      }
    }
    
    if (reportData.distributions && reportData.distributions.userRoles && reportData.distributions.userRoles.length > 0) {
      csvRows.push([])
      csvRows.push(['User Role Distribution', ''])
        reportData.distributions.userRoles.forEach((role) => {
          csvRows.push([role.role, role.count])
        })
    }
  } else if (reportData.event) {
    csvRows.push(['Event', reportData.event.name])
  }
  if (reportData.contest) {
    csvRows.push(['Contest', reportData.contest.name])
  }
  if (reportData.category) {
    csvRows.push(['Category', reportData.category.name])
  }
  
  return Buffer.from(csvRows.map(row => row.map(cell => `"${String(cell)}"`).join(',')).join('\n'))
}


// Export report to PDF
const exportToPDF = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    const reportInstance = await prisma.reportInstance.findUnique({
      where: { id }
    })

    if (!reportInstance) {
      return res.status(404).json({ error: "Report not found" })
    }

    // Parse report data
    const reportData = JSON.parse(reportInstance.data)
    
    // Generate PDF using PDFKit (already implemented in generatePDFReport)
    return generatePDFReport(reportData, res, reportInstance.id)
  } catch (error) {
    log.error("Export to PDF error:", error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: "Internal server error" })
  }
}

// Export report to Excel
const exportToExcel = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    const reportInstance = await prisma.reportInstance.findUnique({
      where: { id }
    })

    if (!reportInstance) {
      return res.status(404).json({ error: "Report not found" })
    }

    // Parse report data
    const reportData = JSON.parse(reportInstance.data)
    
    // Generate Excel using existing function
    return generateExcelReport(reportData, res, reportInstance.id)
  } catch (error) {
    log.error("Export to Excel error:", error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: "Internal server error" })
  }
}

// Export report to CSV
const exportToCSV = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { id } = req.params

    const reportInstance = await prisma.reportInstance.findUnique({
      where: { id }
    })

    if (!reportInstance) {
      return res.status(404).json({ error: "Report not found" })
    }

    // Parse report data
    const reportData = JSON.parse(reportInstance.data)
    
    // Generate CSV using existing function
    return generateCSVReport(reportData, res, reportInstance.id)
  } catch (error) {
    log.error("Export to CSV error:", error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: "Internal server error" })
  }
}

// Generate individual contestant reports
const generateContestantReports = async (req, res) => {
  const log = createRequestLogger(req, 'reports')
  try {
    const { eventId, contestId, format } = req.body
    
    log.debug('üîµ Generating contestant reports:', { eventId, contestId, format })

    // Fetch contest with contestants and their scores
    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        categories: {
          include: {
            contestants: {
              include: {
                contestant: {
                  include: {
                    scores: {
                      include: {
                        category: true,
                        judge: {
                          include: {
                            user: {
                              select: {
                                name: true,
                                email: true
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Collect unique contestants
    const contestants = []
    contest.categories.forEach(category => {
      category.contestants.forEach(cc => {
        if (!contestants.find(c => c.id === cc.contestant.id)) {
          contestants.push(cc.contestant)
        }
      })
    })

    log.debug(`üìä Found ${contestants.length} contestants`)

    // Generate reports for each contestant
    const reports = []
    for (const contestant of contestants) {
      const reportData = {
        reportType: 'contestant',
        generatedAt: new Date(),
        generatedBy: req.user.id,
        contestant: {
          id: contestant.id,
          name: contestant.name,
          email: contestant.email,
          gender: contestant.gender,
          pronouns: contestant.pronouns,
          bio: contestant.bio,
          scores: contestant.scores.map(score => ({
            category: score.category.name,
            score: score.score,
            judge: score.judge.user.name,
            comments: score.comments,
            createdAt: score.createdAt
          }))
        },
        contest: {
          id: contest.id,
          name: contest.name,
          description: contest.description
        }
      }

      // Save to history
      let reportInstance
      try {
        reportInstance = await prisma.reportInstance.create({
          data: {
            name: `Contestant Report - ${contestant.name}`,
            type: 'contestant',
            format: format || 'pdf',
            generatedById: req.user.id,
            templateId: 'default',
            data: JSON.stringify(reportData)
          }
        })
        reports.push({
          id: reportInstance.id,
          contestantId: contestant.id,
          contestantName: contestant.name,
          format: format || 'pdf'
        })
        log.debug(`‚úÖ Generated report for ${contestant.name}`)
  } catch (error) {
        log.error(`‚ö†Ô∏è Failed to save report for ${contestant.name}:`, error, { error: error.message, stack: error.stack })
      }
    }

    res.json({
      message: `Generated ${reports.length} contestant reports`,
      reports
    })

  } catch (error) {
    log.error('‚ùå Generate contestant reports error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Note: generateReportHTML function is defined at line 272
module.exports = {
  exportToPDF,
  exportToExcel,
  exportToCSV,
  getTemplates,
  createTemplate,
  updateTemplate,
  deleteTemplate,
  generateReport,
  sendReportEmail,
  getReportInstances,
  deleteReportInstance,
  getHistory,
  generateEventReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  generateContestResultsReport,
  generateContestantReports
}
