const { PrismaClient } = require('@prisma/client')
const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Certify a specific contestant's scores in a category (judge-level)
const certifyContestantScores = async (req, res) => {
  const log = createRequestLogger(req, 'judgecontestantcertification')
  try {
    const { categoryId, contestantId } = req.params
    const { comments } = req.body
    const userId = req.user.id

    if (!userId) {
      return res.status(400).json({ error: 'User must be authenticated' })
    }

    // Get the judge table ID from the user
    const judgeId = req.user.judgeId

    if (!judgeId) {
      return res.status(400).json({ error: 'User must be linked to a judge' })
    }

    // Check if judge is assigned to this category (assignments use userId)
    // First, get the category to find its contestId
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      select: { id: true, contestId: true }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Check for category-level OR contest-level assignment
    const assignment = await prisma.assignment.findFirst({
      where: {
        judgeId: userId,
        OR: [
          { categoryId },
          { contestId: category.contestId, categoryId: null }
        ],
        status: { in: ['ACTIVE', 'COMPLETED', 'PENDING'] }
      }
    })

    if (!assignment) {
      return res.status(403).json({ error: 'Not assigned to this category' })
    }

    // Verify all scores for this contestant have been submitted (scores use judge table ID)
    const scores = await prisma.score.findMany({
      where: {
        categoryId,
        contestantId,
        judgeId: judgeId
      }
    })

    if (!scores || scores.length === 0) {
      return res.status(400).json({ error: 'No scores found for this contestant' })
    }

    // Check if already certified (using judge table ID)
    const existing = await prisma.judgeContestantCertification.findFirst({
      where: {
        categoryId,
        judgeId: judgeId,
        contestantId
      }
    })

    if (existing) {
      return res.status(400).json({ error: 'Already certified for this contestant' })
    }

    // Create certification record (judgeId references Judge table)
    const certification = await prisma.judgeContestantCertification.create({
      data: {
        categoryId,
        judgeId: judgeId,
        contestantId,
        comments: comments || null
      },
      include: {
        category: true,
        contestant: true,
        judge: true
      }
    })

    res.status(201).json({
      message: 'Contestant scores certified successfully',
      certification
    })
  } catch (error) {
    log.error('Certify contestant scores error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Check if judge has certified all contestants in a category
const getCategoryCertificationStatus = async (req, res) => {
  const log = createRequestLogger(req, 'judgecontestantcertification')
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    const judgeId = req.user.judgeId

    if (!userId) {
      return res.status(400).json({ error: 'User must be authenticated' })
    }

    // For ADMIN/ORGANIZER, return overall category status (all judges)
    // For JUDGE, return status for specific judge
    if ((userRole === 'ADMIN' || userRole === 'ORGANIZER') && !judgeId) {
      // Get all contestants in this category
      const categoryContestants = await prisma.categoryContestant.findMany({
        where: { categoryId },
        include: { contestant: true }
      })

      // Get all certifications for all judges in this category
      const allCertifications = await prisma.judgeContestantCertification.findMany({
        where: { categoryId },
        include: { judge: true }
      })

      // Check if category is certified by any judge
      const categoryCertified = await prisma.judgeCertification.findFirst({
        where: { categoryId }
      })

      // Count how many judges have certified each contestant
      const contestantCertificationCounts = new Map()
      categoryContestants.forEach(cc => {
        const count = allCertifications.filter(c => c.contestantId === cc.contestantId).length
        contestantCertificationCounts.set(cc.contestantId, count)
      })

      const progress = {
        totalContestants: categoryContestants.length,
        certifiedContestants: categoryContestants.filter(cc => contestantCertificationCounts.get(cc.contestantId) > 0).length,
        canCertifyCategory: false, // ADMIN/ORGANIZER don't certify at judge level
        isCategoryCertified: !!categoryCertified,
        totalsCertified: !!categoryCertified, // For compatibility with frontend
        contestants: categoryContestants.map(cc => ({
          contestant: cc.contestant,
          certified: contestantCertificationCounts.get(cc.contestantId) > 0,
          certificationCount: contestantCertificationCounts.get(cc.contestantId) || 0
        }))
      }

      return res.json(progress)
    }

    // For JUDGE role, require judgeId
    if (!judgeId) {
      return res.status(400).json({ error: 'User must be linked to a judge' })
    }

    // Get all contestants in this category
    const categoryContestants = await prisma.categoryContestant.findMany({
      where: { categoryId },
      include: { contestant: true }
    })

    // Get all certifications for this judge in this category (using judge table ID)
    const certifications = await prisma.judgeContestantCertification.findMany({
      where: {
        categoryId,
        judgeId: judgeId
      }
    })

    // Check if category is already certified by this judge (using judge table ID)
    const categoryCertified = await prisma.judgeCertification.findFirst({
      where: {
        categoryId,
        judgeId: judgeId
      }
    })

    const progress = {
      totalContestants: categoryContestants.length,
      certifiedContestants: certifications.length,
      canCertifyCategory: categoryContestants.length === certifications.length && !categoryCertified,
      isCategoryCertified: !!categoryCertified,
      contestants: categoryContestants.map(cc => ({
        contestant: cc.contestant,
        certified: certifications.some(c => c.contestantId === cc.contestantId),
        certification: certifications.find(c => c.contestantId === cc.contestantId)
      }))
    }

    res.json(progress)
  } catch (error) {
    log.error('Get category certification status error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Certify the entire category (after all contestants certified)
const certifyCategory = async (req, res) => {
  const log = createRequestLogger(req, 'judgecontestantcertification')
  try {
    const { categoryId } = req.params
    const { signatureName } = req.body
    const userId = req.user.id
    const judgeId = req.user.judgeId

    if (!userId || !judgeId) {
      return res.status(400).json({ error: 'User must be authenticated and linked to a judge' })
    }

    if (!signatureName) {
      return res.status(400).json({ error: 'Signature name is required' })
    }

    // Check if category is already certified (using judge table ID)
    const existing = await prisma.judgeCertification.findFirst({
      where: {
        categoryId,
        judgeId: judgeId
      }
    })

    if (existing) {
      return res.status(400).json({ error: 'Category already certified' })
    }

    // Verify all contestants are certified by this judge
    const categoryContestants = await prisma.categoryContestant.findMany({
      where: { categoryId }
    })

    const certifications = await prisma.judgeContestantCertification.findMany({
      where: {
        categoryId,
        judgeId: judgeId
      }
    })

    if (certifications.length !== categoryContestants.length) {
      return res.status(400).json({ 
        error: 'All contestants must be certified before certifying the category',
        required: categoryContestants.length,
        certified: certifications.length
      })
    }

    // Create category-level certification (using judge table ID)
    const categoryCertification = await prisma.judgeCertification.create({
      data: {
        categoryId,
        judgeId: judgeId,
        signatureName
      },
      include: {
        category: true,
        judge: true
      }
    })

    res.status(201).json({
      message: 'Category certified successfully',
      certification: categoryCertification
    })
  } catch (error) {
    log.error('Certify category error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  certifyContestantScores,
  getCategoryCertificationStatus,
  certifyCategory
}

