const { PrismaClient } = require('@prisma/client')
const crypto = require('crypto')

const prisma = require('../utils/prisma')
const { createRequestLogger } = require('../utils/logger')

// Generate signature for winner verification
const generateSignature = (userId, categoryId, userRole, ipAddress, userAgent) => {
  const timestamp = new Date().toISOString()
  const data = `${userId}-${categoryId}-${userRole}-${timestamp}-${ipAddress || ''}-${userAgent || ''}`
  return crypto.createHash('sha256').update(data).digest('hex')
}

// Get winners by category with signature verification
const getWinnersByCategory = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId } = req.params
    const userRole = req.user.role

    // Get category with contest and event info
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        contestants: {
          include: {
            contestant: true
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Get all criteria for this category to calculate total possible score
    const criteria = await prisma.criterion.findMany({
      where: { categoryId }
    })
    const totalPossibleScorePerJudge = criteria.reduce((sum, criterion) => sum + criterion.maxScore, 0)
    
    // If no criteria defined, use category's scoreCap as default max score per judge
    const defaultMaxScorePerJudge = totalPossibleScorePerJudge > 0 
      ? totalPossibleScorePerJudge 
      : (category.scoreCap || null)

    // Get all scores for this category
    const scores = await prisma.score.findMany({
      where: { categoryId },
      include: {
        contestant: true,
        judge: true,
        criterion: true
      }
    })

    // Get judges assigned to this category
    const categoryJudges = await prisma.categoryJudge.findMany({
      where: { categoryId }
    })

    // Calculate total scores per contestant
    const contestantScores = {}
    scores.forEach(score => {
      const contestantId = score.contestantId
      if (!contestantScores[contestantId]) {
        contestantScores[contestantId] = {
          contestant: score.contestant,
          totalScore: 0,
          totalPossibleScore: 0,
          scores: [],
          judgesScored: new Set()
        }
      }
      if (score.score !== null) {
        contestantScores[contestantId].totalScore += score.score
        contestantScores[contestantId].judgesScored.add(score.judgeId)
      }
      contestantScores[contestantId].scores.push(score)
    })

    // Calculate total possible scores and sort by total score
    const contestants = Object.values(contestantScores).map(contestant => {
      const judgesCount = contestant.judgesScored.size
      // Use defaultMaxScorePerJudge (from criteria or category scoreCap) * number of judges
      const calculatedTotalPossible = defaultMaxScorePerJudge !== null && judgesCount > 0
        ? defaultMaxScorePerJudge * judgesCount 
        : null
      contestant.totalPossibleScore = calculatedTotalPossible
      return contestant
    }).sort((a, b) => b.totalScore - a.totalScore)

    // Contest-level certifications gating
    const contestCerts = await prisma.contestCertification.findMany({
      where: { contestId: category.contestId }
    })
    const rolesCertified = new Set(contestCerts.map(c => c.role))
    const requiredContestRoles = ['TALLY_MASTER', 'AUDITOR']
    const hasRequiredPrechecks = requiredContestRoles.every(r => rolesCertified.has(r))
    const hasFinalApproval = rolesCertified.has('BOARD') || rolesCertified.has('ORGANIZER')

    // ADMIN and ORGANIZER can see regardless; EMCEE needs final approval
    const canShowWinners = ['ADMIN', 'ORGANIZER'].includes(userRole)
      ? true
      : (userRole === 'EMCEE' ? hasFinalApproval : (hasRequiredPrechecks && hasFinalApproval))

    // Signatures are still returned for audit trail
    const signatures = await prisma.winnerSignature.findMany({
      where: { categoryId },
      include: { user: true }
    })
    const allSigned = hasRequiredPrechecks && hasFinalApproval
    const boardSigned = rolesCertified.has('BOARD')
    const requiredRoles = ['TALLY_MASTER', 'AUDITOR', 'BOARD', 'ORGANIZER']

    res.json({
      category,
      contestants: canShowWinners ? contestants : [],
      signatures,
      allSigned,
      boardSigned,
      canShowWinners,
      requiredRoles,
      message: canShowWinners ? 'Winners available' : 'Waiting for required contest certifications'
    })
  } catch (error) {
    log.error('Get winners by category error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper function to get winners by contest (internal use)
const getWinnersByContestInternal = async (contestId, userRole, includeCategoryBreakdown = true) => {
  try {
    // Get contest with categories
    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            contestants: {
              include: {
                contestant: true
              }
            }
          }
        }
      }
    })

    if (!contest) {
      throw new Error('Contest not found')
    }

    // Contest-level certifications gating
    const contestCerts = await prisma.contestCertification.findMany({
      where: { contestId: contest.id }
    })
    const rolesCertified = new Set(contestCerts.map(c => c.role))
    const requiredContestRoles = ['TALLY_MASTER', 'AUDITOR']
    const hasRequiredPrechecks = requiredContestRoles.every(r => rolesCertified.has(r))
    const hasFinalApproval = rolesCertified.has('BOARD') || rolesCertified.has('ORGANIZER')
    const canShowWinners = ['ADMIN', 'ORGANIZER'].includes(userRole)
      ? true
      : (userRole === 'EMCEE' ? hasFinalApproval : (hasRequiredPrechecks && hasFinalApproval))

    // If not including category breakdown, aggregate all contestant scores across all categories
    if (!includeCategoryBreakdown) {
      // Get all criteria for all categories to calculate total possible scores
      const allCriteria = await prisma.criterion.findMany({
        where: {
          categoryId: { in: contest.categories.map(c => c.id) }
        }
      })

      // Calculate total possible per category per judge (from criteria)
      const categoryMaxScoresFromCriteria = {}
      allCriteria.forEach(criterion => {
        if (!categoryMaxScoresFromCriteria[criterion.categoryId]) {
          categoryMaxScoresFromCriteria[criterion.categoryId] = 0
        }
        categoryMaxScoresFromCriteria[criterion.categoryId] += criterion.maxScore
      })
      
      // Build categoryMaxScores map: use criteria sum if available, otherwise use category scoreCap
      const categoryMaxScores = {}
      contest.categories.forEach(cat => {
        const criteriaSum = categoryMaxScoresFromCriteria[cat.id] || 0
        categoryMaxScores[cat.id] = criteriaSum > 0 ? criteriaSum : (cat.scoreCap || null)
      })

      // Aggregate scores across all categories in the contest
      const allScores = await prisma.score.findMany({
        where: {
          categoryId: { in: contest.categories.map(c => c.id) }
        },
        include: {
          contestant: true,
          judge: true,
          criterion: true,
          category: true
        }
      })

      // Group by contestant and sum scores across all categories
      const contestantTotals = {}
      allScores.forEach(score => {
        const contestantId = score.contestantId
        if (!contestantTotals[contestantId]) {
          contestantTotals[contestantId] = {
            contestant: score.contestant,
            totalScore: 0,
            totalPossibleScore: 0,
            categories: new Set(),
            categoryJudgePairs: new Set()
          }
        }
        if (score.score !== null) {
          contestantTotals[contestantId].totalScore += score.score
          // Track unique category-judge pairs for calculating possible score
          contestantTotals[contestantId].categoryJudgePairs.add(`${score.categoryId}-${score.judgeId}`)
        }
        contestantTotals[contestantId].categories.add(score.categoryId)
      })

      const overallWinners = Object.values(contestantTotals).map(item => {
        // Calculate total possible: sum of max scores for each category-judge pair
        let totalPossible = 0
        let hasValidMaxScore = false
        item.categoryJudgePairs.forEach(pair => {
          const [categoryId] = pair.split('-')
          const categoryMax = categoryMaxScores[categoryId]
          // categoryMax can be a number (from criteria or scoreCap) or null
          if (categoryMax !== null && categoryMax !== undefined && categoryMax > 0) {
            totalPossible += categoryMax
            hasValidMaxScore = true
          }
        })
        // Return calculated total if we have valid max scores, otherwise null
        const calculatedTotalPossible = hasValidMaxScore ? totalPossible : null
        return {
          contestant: item.contestant,
          totalScore: item.totalScore,
          totalPossibleScore: calculatedTotalPossible,
          categoriesParticipated: item.categories.size
        }
      }).sort((a, b) => b.totalScore - a.totalScore)

      return {
        contest,
        contestants: canShowWinners ? overallWinners : [],
        canShowWinners,
        message: 'Contest winners retrieved (overall)'
      }
    }

    // Include category breakdown (default behavior)
    const categoryResults = []

    for (const category of contest.categories) {
      // Get criteria for this category to calculate total possible score
      const criteria = await prisma.criterion.findMany({
        where: { categoryId: category.id }
      })
      const totalPossibleScorePerJudge = criteria.reduce((sum, criterion) => sum + criterion.maxScore, 0)
      
      // If no criteria defined, use category's scoreCap as default max score per judge
      const defaultMaxScorePerJudge = totalPossibleScorePerJudge > 0 
        ? totalPossibleScorePerJudge 
        : (category.scoreCap || null)

      // Get scores for this category
      const scores = await prisma.score.findMany({
        where: { categoryId: category.id },
        include: {
          contestant: true,
          judge: true,
          criterion: true
        }
      })

      // Calculate scores
      const contestantScores = {}
      scores.forEach(score => {
        const contestantId = score.contestantId
        if (!contestantScores[contestantId]) {
          contestantScores[contestantId] = {
            contestant: score.contestant,
            totalScore: 0,
            totalPossibleScore: 0,
            scores: [],
            judgesScored: new Set()
          }
        }
        if (score.score !== null) {
          contestantScores[contestantId].totalScore += score.score
          contestantScores[contestantId].judgesScored.add(score.judgeId)
        }
        contestantScores[contestantId].scores.push(score)
      })

      const contestants = Object.values(contestantScores).map(contestant => {
        const judgesCount = contestant.judgesScored.size
        // Use defaultMaxScorePerJudge (from criteria or category scoreCap) * number of judges
        const calculatedTotalPossible = defaultMaxScorePerJudge !== null && judgesCount > 0
          ? defaultMaxScorePerJudge * judgesCount 
          : null
        contestant.totalPossibleScore = calculatedTotalPossible
        return contestant
      }).sort((a, b) => b.totalScore - a.totalScore)

      // Signatures still included for audit trail
      const signatures = await prisma.winnerSignature.findMany({
        where: { categoryId: category.id },
        include: { user: true }
      })
      const allSigned = hasRequiredPrechecks && hasFinalApproval
      const boardSigned = rolesCertified.has('BOARD')

      categoryResults.push({
        category,
        contestants: canShowWinners ? contestants : [],
        signatures,
        allSigned,
        boardSigned,
        canShowWinners
      })
    }

    return {
      contest,
      categories: categoryResults,
      canShowWinners,
      message: 'Contest winners retrieved'
    }
  } catch (error) {
    log.error('Get winners by contest error:', error, { error: error.message, stack: error.stack })
    throw error
  }
}

// Get winners by contest (API endpoint)
const getWinnersByContest = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { contestId } = req.params
    const userRole = req.user.role
    
    const result = await getWinnersByContestInternal(contestId, userRole)
    res.json(result)
  } catch (error) {
    log.error('Get winners by contest error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Sign winners (add signature)
const signWinners = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    const ipAddress = req.ip || req.connection.remoteAddress
    const userAgent = req.headers['user-agent']

    // Check if user already signed this category
    const existingSignature = await prisma.winnerSignature.findFirst({
      where: {
        categoryId,
        userId
      }
    })

    if (existingSignature) {
      return res.status(400).json({ error: 'User has already signed this category' })
    }

    // Generate signature
    const signature = generateSignature(userId, categoryId, userRole, ipAddress, userAgent)

    // Create signature record
    const winnerSignature = await prisma.winnerSignature.create({
      data: {
        categoryId,
        contestId: req.body.contestId,
        eventId: req.body.eventId,
        userId,
        userRole,
        signature,
        ipAddress,
        userAgent
      },
      include: {
        user: true,
        category: true
      }
    })

    res.json({
      message: 'Winners signed successfully',
      signature: winnerSignature
    })
  } catch (error) {
    log.error('Sign winners error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get signature status for a category
const getSignatureStatus = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId } = req.params

    const signatures = await prisma.winnerSignature.findMany({
      where: { categoryId },
      include: {
        user: true
      }
    })

    const requiredRoles = ['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    const signedRoles = signatures.map(sig => sig.userRole)
    const allSigned = requiredRoles.every(role => signedRoles.includes(role))
    const boardSigned = signatures.some(sig => sig.userRole === 'BOARD')

    res.json({
      signatures,
      allSigned,
      boardSigned,
      requiredRoles,
      signedRoles,
      missingRoles: requiredRoles.filter(role => !signedRoles.includes(role))
    })
  } catch (error) {
    log.error('Get signature status error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification progress for all roles
const getCertificationProgress = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId } = req.params

    // Get all certifications for this category
    const [judgeCertifications, tallyCertifications, auditorCertifications, boardCertifications] = await Promise.all([
      prisma.judgeCertification.findMany({
        where: { categoryId },
        include: { judge: { include: { user: true } } }
      }),
      prisma.tallyMasterCertification.findMany({
        where: { categoryId }
      }),
      prisma.auditorCertification.findMany({
        where: { categoryId }
      }),
      prisma.winnerSignature.findMany({
        where: { categoryId, userRole: 'BOARD' },
        include: { user: true }
      })
    ])

    // Get all judges assigned to this category
    const categoryJudges = await prisma.categoryJudge.findMany({
      where: { categoryId },
      include: { judge: { include: { user: true } } }
    })

    const progress = {
      judges: {
        total: categoryJudges.length,
        certified: judgeCertifications.length,
        certifications: judgeCertifications.map(cert => ({
          judgeId: cert.judgeId,
          judgeName: cert.judge.user.name,
          signatureName: cert.signatureName,
          certifiedAt: cert.certifiedAt
        }))
      },
      tallyMaster: {
        certified: tallyCertifications.length > 0,
        certification: tallyCertifications[0] || null
      },
      auditor: {
        certified: auditorCertifications.length > 0,
        certification: auditorCertifications[0] || null
      },
      board: {
        certified: boardCertifications.length > 0,
        certification: boardCertifications[0] || null
      }
    }

    res.json(progress)
  } catch (error) {
    log.error('Get certification progress error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification status for specific role
const getRoleCertificationStatus = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId, role } = req.params
    const userId = req.user.id

    let certification = null
    let canCertify = false

    switch (role.toUpperCase()) {
      case 'JUDGE':
        certification = await prisma.judgeCertification.findFirst({
          where: { categoryId, judgeId: req.user.judgeId }
        })
        canCertify = !certification && req.user.role === 'JUDGE'
        break

      case 'TALLY_MASTER':
        certification = await prisma.tallyMasterCertification.findFirst({
          where: { categoryId }
        })
        canCertify = !certification && req.user.role === 'TALLY_MASTER'
        break

      case 'AUDITOR':
        certification = await prisma.auditorCertification.findFirst({
          where: { categoryId }
        })
        canCertify = !certification && req.user.role === 'AUDITOR'
        break

      case 'BOARD':
        certification = await prisma.winnerSignature.findFirst({
          where: { categoryId, userId, userRole: 'BOARD' }
        })
        canCertify = !certification && req.user.role === 'BOARD'
        break

      default:
        return res.status(400).json({ error: 'Invalid role' })
    }

    res.json({
      role: role.toUpperCase(),
      certified: !!certification,
      certification,
      canCertify,
      userId
    })
  } catch (error) {
    log.error('Get role certification status error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Certify scores for specific role
const certifyScores = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId } = req.params
    const { signatureName, comments } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    if (!signatureName) {
      return res.status(400).json({ error: 'Signature name is required' })
    }

    let certification = null

    switch (userRole) {
      case 'JUDGE':
        if (!req.user.judgeId) {
          return res.status(400).json({ error: 'User must be linked to a judge' })
        }
        certification = await prisma.judgeCertification.create({
          data: {
            categoryId,
            judgeId: req.user.judgeId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'TALLY_MASTER':
        certification = await prisma.tallyMasterCertification.create({
          data: {
            categoryId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'AUDITOR':
        certification = await prisma.auditorCertification.create({
          data: {
            categoryId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'BOARD': {
        const signature = generateSignature(userId, categoryId, 'BOARD', req.ip, req.get('User-Agent'))
        certification = await prisma.winnerSignature.create({
          data: {
            categoryId,
            contestId: req.body.contestId,
            eventId: req.body.eventId,
            userId,
            userRole: 'BOARD',
            signature
          }
        })
        break
      }

      default:
        return res.status(403).json({ error: 'Role not authorized to certify' })
    }

    res.status(201).json({
      message: 'Scores certified successfully',
      certification,
      role: userRole
    })
  } catch (error) {
    log.error('Certify scores error:', error, { error: error.message, stack: error.stack })
    if (error.code === 'P2002') {
      res.status(400).json({ error: 'Scores already certified by this role' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// General getWinners - returns appropriate winners based on filters
const getWinners = async (req, res) => {
  const log = createRequestLogger(req, 'winners')
  try {
    const { categoryId, contestId, eventId } = req.query

    if (categoryId) {
      return getWinnersByCategory(req, res)
    } else if (contestId) {
      return getWinnersByContest(req, res)
    } else if (eventId) {
      // Get winners by event (all contests in event)
      const event = await prisma.event.findUnique({
        where: { id: eventId },
        include: {
          contests: {
            include: {
              categories: true
            }
          }
        }
      })

      if (!event) {
        return res.status(404).json({ error: 'Event not found' })
      }

      const contestResults = []

      for (const contest of event.contests) {
        // Get overall contest winners (aggregated across all categories, no breakdown)
        const contestWinnersData = await getWinnersByContestInternal(contest.id, req.user.role, false)
        
        contestResults.push({
          contest: {
            id: contest.id,
            name: contest.name,
            description: contest.description
          },
          contestants: contestWinnersData.contestants || [],
          canShowWinners: contestWinnersData.canShowWinners || false
        })
      }

      res.json({
        event: {
          id: event.id,
          name: event.name,
          description: event.description,
          startDate: event.startDate,
          endDate: event.endDate
        },
        contests: contestResults
      })
    } else {
      return res.status(400).json({ error: 'categoryId, contestId, or eventId is required' })
    }
  } catch (error) {
    log.error('Get winners error:', error, { error: error.message, stack: error.stack })
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getWinners,
  getWinnersByCategory,
  getWinnersByContest,
  signWinners,
  getSignatureStatus,
  getCertificationProgress,
  getRoleCertificationStatus,
  certifyScores
}
